{"version":3,"file":"index.esm.js","sources":["../node_modules/zustand/esm/vanilla.mjs","../node_modules/use-sync-external-store/shim/index.js","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js","../node_modules/use-sync-external-store/shim/with-selector.js","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js","../node_modules/zustand/esm/index.mjs","../node_modules/immer/dist/immer.mjs","../node_modules/zustand/esm/middleware/immer.mjs","../src/utils/constants.ts","../src/utils/getAreaViewport.ts","../src/utils/math.ts","../src/utils/vec2.ts","../src/utils/AreaIdContext.ts","../src/utils/areaRowToMinSize.ts","../src/utils/areaToParentRow.ts","../src/utils/areaToViewport.ts","../src/utils/areaUtils.ts","../src/utils/joinArea.ts","../src/utils/color/convertColor.ts","../src/utils/color/cssColors.ts","../src/types/actions.ts","../src/store/registries/areaRegistry.ts","../src/utils/validation.ts","../node_modules/zustand/esm/middleware.mjs","../node_modules/uuid/dist/esm-browser/stringify.js","../node_modules/uuid/dist/esm-browser/rng.js","../node_modules/uuid/dist/esm-browser/native.js","../node_modules/uuid/dist/esm-browser/v4.js","../src/utils/history.ts","../src/store/spaceStore.ts","../src/utils/toolsEventBus.ts","../src/store/areaStore.ts","../src/store/contextMenuStore.ts","../src/actions/handlers/actionRegistry.ts","../src/store/registries/coreRegistry.ts","../src/hooks/useAreaDragAndDrop.ts","../node_modules/lucide-react/dist/esm/shared/src/utils.js","../node_modules/lucide-react/dist/esm/defaultAttributes.js","../node_modules/lucide-react/dist/esm/Icon.js","../node_modules/lucide-react/dist/esm/createLucideIcon.js","../node_modules/lucide-react/dist/esm/icons/app-window.js","../node_modules/lucide-react/dist/esm/icons/arrow-big-down.js","../node_modules/lucide-react/dist/esm/icons/copy.js","../node_modules/lucide-react/dist/esm/icons/ellipsis-vertical.js","../node_modules/lucide-react/dist/esm/icons/ellipsis.js","../node_modules/lucide-react/dist/esm/icons/external-link.js","../node_modules/lucide-react/dist/esm/icons/file-down.js","../node_modules/lucide-react/dist/esm/icons/file-up.js","../node_modules/lucide-react/dist/esm/icons/folder-open.js","../node_modules/lucide-react/dist/esm/icons/history.js","../node_modules/lucide-react/dist/esm/icons/lock-open.js","../node_modules/lucide-react/dist/esm/icons/lock.js","../node_modules/lucide-react/dist/esm/icons/maximize-2.js","../node_modules/lucide-react/dist/esm/icons/minimize-2.js","../node_modules/lucide-react/dist/esm/icons/plus.js","../node_modules/lucide-react/dist/esm/icons/square-pen.js","../node_modules/lucide-react/dist/esm/icons/trash.js","../node_modules/lucide-react/dist/esm/icons/x.js","../src/actions/handlers/useRegisterActionHandler.ts","../src/hooks/useTranslation.ts","../src/components/SwitchAreatypeContextMenu.tsx","../src/components/handlers/AreaDragButton.tsx","../src/components/AreaTabs.tsx","../src/components/handlers/areaDragFromCorner.ts","../src/components/AreaErrorBoundary.tsx","../src/hooks/useContextMenu.ts","../src/components/ScreenSwitcher.tsx","../src/hooks/useScreenManagement.ts","../src/utils/toolsRegistry.ts","../src/hooks/useToolsCleanup.ts","../src/components/ToolsSlot.tsx","../src/hooks/useToolsState.ts","../src/hooks/useToolsScreenState.ts","../src/components/AreaComponent.tsx","../src/components/AreaStack.tsx","../src/components/AreaPreview.tsx","../src/components/Area.tsx","../src/components/handlers/areaDragResize.ts","../src/components/AreaRowSeparators.tsx","../src/components/DropZone.tsx","../src/components/AreaToOpenPreview.tsx","../src/components/JoinAreaPreview.tsx","../src/components/ContextMenu.tsx","../src/providers/ContextMenuProvider.tsx","../src/components/DetachedWindowCleanup.tsx","../src/store/spaceHistoryStore.ts","../src/types/spaceTypes.ts","../src/hooks/useArea.ts","../src/providers/KarmycInitializer.tsx","../src/store/registries/keyboardShortcutRegistry.ts","../src/providers/KarmycProvider.tsx","../src/utils/keyboard.ts","../src/components/Karmyc.tsx","../src/utils/objectEquality.ts","../node_modules/zustand/esm/shallow.mjs","../node_modules/zustand/esm/traditional.mjs","../src/hooks/useSpace.ts","../src/components/menus/SpaceMenu.tsx","../src/hooks/useRegisterAreaType.ts","../src/hooks/useKarmyc.ts","../src/hooks/usePluginSystem.ts","../src/hooks/useSpaceHistory.ts","../src/hooks/useAreaKeyboardShortcuts.ts"],"sourcesContent":["const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","/**\n * @license React\n * use-sync-external-store-shim.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"react\");\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is,\n  useState = React.useState,\n  useEffect = React.useEffect,\n  useLayoutEffect = React.useLayoutEffect,\n  useDebugValue = React.useDebugValue;\nfunction useSyncExternalStore$2(subscribe, getSnapshot) {\n  var value = getSnapshot(),\n    _useState = useState({ inst: { value: value, getSnapshot: getSnapshot } }),\n    inst = _useState[0].inst,\n    forceUpdate = _useState[1];\n  useLayoutEffect(\n    function () {\n      inst.value = value;\n      inst.getSnapshot = getSnapshot;\n      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n    },\n    [subscribe, value, getSnapshot]\n  );\n  useEffect(\n    function () {\n      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n      return subscribe(function () {\n        checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n      });\n    },\n    [subscribe]\n  );\n  useDebugValue(value);\n  return value;\n}\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  inst = inst.value;\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(inst, nextValue);\n  } catch (error) {\n    return !0;\n  }\n}\nfunction useSyncExternalStore$1(subscribe, getSnapshot) {\n  return getSnapshot();\n}\nvar shim =\n  \"undefined\" === typeof window ||\n  \"undefined\" === typeof window.document ||\n  \"undefined\" === typeof window.document.createElement\n    ? useSyncExternalStore$1\n    : useSyncExternalStore$2;\nexports.useSyncExternalStore =\n  void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n","/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"react\"),\n  shim = require(\"use-sync-external-store/shim\");\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is,\n  useSyncExternalStore = shim.useSyncExternalStore,\n  useRef = React.useRef,\n  useEffect = React.useEffect,\n  useMemo = React.useMemo,\n  useDebugValue = React.useDebugValue;\nexports.useSyncExternalStoreWithSelector = function (\n  subscribe,\n  getSnapshot,\n  getServerSnapshot,\n  selector,\n  isEqual\n) {\n  var instRef = useRef(null);\n  if (null === instRef.current) {\n    var inst = { hasValue: !1, value: null };\n    instRef.current = inst;\n  } else inst = instRef.current;\n  instRef = useMemo(\n    function () {\n      function memoizedSelector(nextSnapshot) {\n        if (!hasMemo) {\n          hasMemo = !0;\n          memoizedSnapshot = nextSnapshot;\n          nextSnapshot = selector(nextSnapshot);\n          if (void 0 !== isEqual && inst.hasValue) {\n            var currentSelection = inst.value;\n            if (isEqual(currentSelection, nextSnapshot))\n              return (memoizedSelection = currentSelection);\n          }\n          return (memoizedSelection = nextSnapshot);\n        }\n        currentSelection = memoizedSelection;\n        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;\n        var nextSelection = selector(nextSnapshot);\n        if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n          return (memoizedSnapshot = nextSnapshot), currentSelection;\n        memoizedSnapshot = nextSnapshot;\n        return (memoizedSelection = nextSelection);\n      }\n      var hasMemo = !1,\n        memoizedSnapshot,\n        memoizedSelection,\n        maybeGetServerSnapshot =\n          void 0 === getServerSnapshot ? null : getServerSnapshot;\n      return [\n        function () {\n          return memoizedSelector(getSnapshot());\n        },\n        null === maybeGetServerSnapshot\n          ? void 0\n          : function () {\n              return memoizedSelector(maybeGetServerSnapshot());\n            }\n      ];\n    },\n    [getSnapshot, getServerSnapshot, selector, isEqual]\n  );\n  var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n  useEffect(\n    function () {\n      inst.hasValue = !0;\n      inst.value = value;\n    },\n    [value]\n  );\n  useDebugValue(value);\n  return value;\n};\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      shim = require(\"use-sync-external-store/shim\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useSyncExternalStore = shim.useSyncExternalStore,\n      useRef = React.useRef,\n      useEffect = React.useEffect,\n      useMemo = React.useMemo,\n      useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector,\n      isEqual\n    ) {\n      var instRef = useRef(null);\n      if (null === instRef.current) {\n        var inst = { hasValue: !1, value: null };\n        instRef.current = inst;\n      } else inst = instRef.current;\n      instRef = useMemo(\n        function () {\n          function memoizedSelector(nextSnapshot) {\n            if (!hasMemo) {\n              hasMemo = !0;\n              memoizedSnapshot = nextSnapshot;\n              nextSnapshot = selector(nextSnapshot);\n              if (void 0 !== isEqual && inst.hasValue) {\n                var currentSelection = inst.value;\n                if (isEqual(currentSelection, nextSnapshot))\n                  return (memoizedSelection = currentSelection);\n              }\n              return (memoizedSelection = nextSnapshot);\n            }\n            currentSelection = memoizedSelection;\n            if (objectIs(memoizedSnapshot, nextSnapshot))\n              return currentSelection;\n            var nextSelection = selector(nextSnapshot);\n            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n              return (memoizedSnapshot = nextSnapshot), currentSelection;\n            memoizedSnapshot = nextSnapshot;\n            return (memoizedSelection = nextSelection);\n          }\n          var hasMemo = !1,\n            memoizedSnapshot,\n            memoizedSelection,\n            maybeGetServerSnapshot =\n              void 0 === getServerSnapshot ? null : getServerSnapshot;\n          return [\n            function () {\n              return memoizedSelector(getSnapshot());\n            },\n            null === maybeGetServerSnapshot\n              ? void 0\n              : function () {\n                  return memoizedSelector(maybeGetServerSnapshot());\n                }\n          ];\n        },\n        [getSnapshot, getServerSnapshot, selector, isEqual]\n      );\n      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n      useEffect(\n        function () {\n          inst.hasValue = !0;\n          inst.value = value;\n        },\n        [value]\n      );\n      useDebugValue(value);\n      return value;\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n","import { createStore } from 'zustand/vanilla';\nexport * from 'zustand/vanilla';\nimport ReactExports from 'react';\nimport useSyncExternalStoreExports from 'use-sync-external-store/shim/with-selector.js';\n\nconst { useDebugValue } = ReactExports;\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;\nlet didWarnAboutEqualityFn = false;\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity, equalityFn) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && equalityFn && !didWarnAboutEqualityFn) {\n    console.warn(\n      \"[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937\"\n    );\n    didWarnAboutEqualityFn = true;\n  }\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\nexport { create, react as default, useStore };\n","// src/utils/env.ts\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\");\n\n// src/utils/errors.ts\nvar errors = process.env.NODE_ENV !== \"production\" ? [\n  // All error codes, starting by 0:\n  function(plugin) {\n    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`;\n  },\n  function(thing) {\n    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;\n  },\n  \"This object has been frozen and should not be mutated\",\n  function(data) {\n    return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n  },\n  \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n  \"Immer forbids circular references\",\n  \"The first or second argument to `produce` must be a function\",\n  \"The third argument to `produce` must be a function or undefined\",\n  \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n  \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n  function(thing) {\n    return `'current' expects a draft, got: ${thing}`;\n  },\n  \"Object.defineProperty() cannot be used on an Immer draft\",\n  \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n  \"Immer only supports deleting array indices\",\n  \"Immer only supports setting array indices and the 'length' property\",\n  function(thing) {\n    return `'original' expects a draft, got: ${thing}`;\n  }\n  // Note: if more errors are added, the errorOffset in Patches.ts should be increased\n  // See Patches.ts for additional errors\n] : [];\nfunction die(error, ...args) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const e = errors[error];\n    const msg = typeof e === \"function\" ? e.apply(null, args) : e;\n    throw new Error(`[Immer] ${msg}`);\n  }\n  throw new Error(\n    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n  );\n}\n\n// src/utils/common.ts\nvar getPrototypeOf = Object.getPrototypeOf;\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value)\n    return false;\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);\n}\nvar objectCtorString = Object.prototype.constructor.toString();\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\")\n    return false;\n  const proto = getPrototypeOf(value);\n  if (proto === null) {\n    return true;\n  }\n  const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  if (Ctor === Object)\n    return true;\n  return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\nfunction original(value) {\n  if (!isDraft(value))\n    die(15, value);\n  return value[DRAFT_STATE].base_;\n}\nfunction each(obj, iter) {\n  if (getArchtype(obj) === 0 /* Object */) {\n    Reflect.ownKeys(obj).forEach((key) => {\n      iter(key, obj[key], obj);\n    });\n  } else {\n    obj.forEach((entry, index) => iter(index, entry, obj));\n  }\n}\nfunction getArchtype(thing) {\n  const state = thing[DRAFT_STATE];\n  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;\n}\nfunction has(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.get(prop) : thing[prop];\n}\nfunction set(thing, propOrOldValue, value) {\n  const t = getArchtype(thing);\n  if (t === 2 /* Map */)\n    thing.set(propOrOldValue, value);\n  else if (t === 3 /* Set */) {\n    thing.add(value);\n  } else\n    thing[propOrOldValue] = value;\n}\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction isMap(target) {\n  return target instanceof Map;\n}\nfunction isSet(target) {\n  return target instanceof Set;\n}\nfunction latest(state) {\n  return state.copy_ || state.base_;\n}\nfunction shallowCopy(base, strict) {\n  if (isMap(base)) {\n    return new Map(base);\n  }\n  if (isSet(base)) {\n    return new Set(base);\n  }\n  if (Array.isArray(base))\n    return Array.prototype.slice.call(base);\n  const isPlain = isPlainObject(base);\n  if (strict === true || strict === \"class_only\" && !isPlain) {\n    const descriptors = Object.getOwnPropertyDescriptors(base);\n    delete descriptors[DRAFT_STATE];\n    let keys = Reflect.ownKeys(descriptors);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const desc = descriptors[key];\n      if (desc.writable === false) {\n        desc.writable = true;\n        desc.configurable = true;\n      }\n      if (desc.get || desc.set)\n        descriptors[key] = {\n          configurable: true,\n          writable: true,\n          // could live with !!desc.set as well here...\n          enumerable: desc.enumerable,\n          value: base[key]\n        };\n    }\n    return Object.create(getPrototypeOf(base), descriptors);\n  } else {\n    const proto = getPrototypeOf(base);\n    if (proto !== null && isPlain) {\n      return { ...base };\n    }\n    const obj = Object.create(proto);\n    return Object.assign(obj, base);\n  }\n}\nfunction freeze(obj, deep = false) {\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))\n    return obj;\n  if (getArchtype(obj) > 1) {\n    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n  Object.freeze(obj);\n  if (deep)\n    Object.entries(obj).forEach(([key, value]) => freeze(value, true));\n  return obj;\n}\nfunction dontMutateFrozenCollections() {\n  die(2);\n}\nfunction isFrozen(obj) {\n  return Object.isFrozen(obj);\n}\n\n// src/utils/plugins.ts\nvar plugins = {};\nfunction getPlugin(pluginKey) {\n  const plugin = plugins[pluginKey];\n  if (!plugin) {\n    die(0, pluginKey);\n  }\n  return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n  if (!plugins[pluginKey])\n    plugins[pluginKey] = implementation;\n}\n\n// src/core/scope.ts\nvar currentScope;\nfunction getCurrentScope() {\n  return currentScope;\n}\nfunction createScope(parent_, immer_) {\n  return {\n    drafts_: [],\n    parent_,\n    immer_,\n    // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n    canAutoFreeze_: true,\n    unfinalizedDrafts_: 0\n  };\n}\nfunction usePatchesInScope(scope, patchListener) {\n  if (patchListener) {\n    getPlugin(\"Patches\");\n    scope.patches_ = [];\n    scope.inversePatches_ = [];\n    scope.patchListener_ = patchListener;\n  }\n}\nfunction revokeScope(scope) {\n  leaveScope(scope);\n  scope.drafts_.forEach(revokeDraft);\n  scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n  if (scope === currentScope) {\n    currentScope = scope.parent_;\n  }\n}\nfunction enterScope(immer2) {\n  return currentScope = createScope(currentScope, immer2);\n}\nfunction revokeDraft(draft) {\n  const state = draft[DRAFT_STATE];\n  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */)\n    state.revoke_();\n  else\n    state.revoked_ = true;\n}\n\n// src/core/finalize.ts\nfunction processResult(result, scope) {\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\n  const baseDraft = scope.drafts_[0];\n  const isReplaced = result !== void 0 && result !== baseDraft;\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified_) {\n      revokeScope(scope);\n      die(4);\n    }\n    if (isDraftable(result)) {\n      result = finalize(scope, result);\n      if (!scope.parent_)\n        maybeFreeze(scope, result);\n    }\n    if (scope.patches_) {\n      getPlugin(\"Patches\").generateReplacementPatches_(\n        baseDraft[DRAFT_STATE].base_,\n        result,\n        scope.patches_,\n        scope.inversePatches_\n      );\n    }\n  } else {\n    result = finalize(scope, baseDraft, []);\n  }\n  revokeScope(scope);\n  if (scope.patches_) {\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\n  }\n  return result !== NOTHING ? result : void 0;\n}\nfunction finalize(rootScope, value, path) {\n  if (isFrozen(value))\n    return value;\n  const state = value[DRAFT_STATE];\n  if (!state) {\n    each(\n      value,\n      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)\n    );\n    return value;\n  }\n  if (state.scope_ !== rootScope)\n    return value;\n  if (!state.modified_) {\n    maybeFreeze(rootScope, state.base_, true);\n    return state.base_;\n  }\n  if (!state.finalized_) {\n    state.finalized_ = true;\n    state.scope_.unfinalizedDrafts_--;\n    const result = state.copy_;\n    let resultEach = result;\n    let isSet2 = false;\n    if (state.type_ === 3 /* Set */) {\n      resultEach = new Set(result);\n      result.clear();\n      isSet2 = true;\n    }\n    each(\n      resultEach,\n      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)\n    );\n    maybeFreeze(rootScope, result, false);\n    if (path && rootScope.patches_) {\n      getPlugin(\"Patches\").generatePatches_(\n        state,\n        path,\n        rootScope.patches_,\n        rootScope.inversePatches_\n      );\n    }\n  }\n  return state.copy_;\n}\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n  if (process.env.NODE_ENV !== \"production\" && childValue === targetObject)\n    die(5);\n  if (isDraft(childValue)) {\n    const path = rootPath && parentState && parentState.type_ !== 3 /* Set */ && // Set objects are atomic since they have no keys.\n    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;\n    const res = finalize(rootScope, childValue, path);\n    set(targetObject, prop, res);\n    if (isDraft(res)) {\n      rootScope.canAutoFreeze_ = false;\n    } else\n      return;\n  } else if (targetIsSet) {\n    targetObject.add(childValue);\n  }\n  if (isDraftable(childValue) && !isFrozen(childValue)) {\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n      return;\n    }\n    finalize(rootScope, childValue);\n    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== \"symbol\" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))\n      maybeFreeze(rootScope, childValue);\n  }\n}\nfunction maybeFreeze(scope, value, deep = false) {\n  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n    freeze(value, deep);\n  }\n}\n\n// src/core/proxy.ts\nfunction createProxyProxy(base, parent) {\n  const isArray = Array.isArray(base);\n  const state = {\n    type_: isArray ? 1 /* Array */ : 0 /* Object */,\n    // Track which produce call this is associated with.\n    scope_: parent ? parent.scope_ : getCurrentScope(),\n    // True for both shallow and deep changes.\n    modified_: false,\n    // Used during finalization.\n    finalized_: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned_: {},\n    // The parent draft state.\n    parent_: parent,\n    // The base state.\n    base_: base,\n    // The base proxy.\n    draft_: null,\n    // set below\n    // The base copy with any updated values.\n    copy_: null,\n    // Called by the `produce` function.\n    revoke_: null,\n    isManual_: false\n  };\n  let target = state;\n  let traps = objectTraps;\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  }\n  const { revoke, proxy } = Proxy.revocable(target, traps);\n  state.draft_ = proxy;\n  state.revoke_ = revoke;\n  return proxy;\n}\nvar objectTraps = {\n  get(state, prop) {\n    if (prop === DRAFT_STATE)\n      return state;\n    const source = latest(state);\n    if (!has(source, prop)) {\n      return readPropFromProto(state, source, prop);\n    }\n    const value = source[prop];\n    if (state.finalized_ || !isDraftable(value)) {\n      return value;\n    }\n    if (value === peek(state.base_, prop)) {\n      prepareCopy(state);\n      return state.copy_[prop] = createProxy(value, state);\n    }\n    return value;\n  },\n  has(state, prop) {\n    return prop in latest(state);\n  },\n  ownKeys(state) {\n    return Reflect.ownKeys(latest(state));\n  },\n  set(state, prop, value) {\n    const desc = getDescriptorFromProto(latest(state), prop);\n    if (desc?.set) {\n      desc.set.call(state.draft_, value);\n      return true;\n    }\n    if (!state.modified_) {\n      const current2 = peek(latest(state), prop);\n      const currentState = current2?.[DRAFT_STATE];\n      if (currentState && currentState.base_ === value) {\n        state.copy_[prop] = value;\n        state.assigned_[prop] = false;\n        return true;\n      }\n      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))\n        return true;\n      prepareCopy(state);\n      markChanged(state);\n    }\n    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'\n    (value !== void 0 || prop in state.copy_) || // special case: NaN\n    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))\n      return true;\n    state.copy_[prop] = value;\n    state.assigned_[prop] = true;\n    return true;\n  },\n  deleteProperty(state, prop) {\n    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n      state.assigned_[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else {\n      delete state.assigned_[prop];\n    }\n    if (state.copy_) {\n      delete state.copy_[prop];\n    }\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor(state, prop) {\n    const owner = latest(state);\n    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (!desc)\n      return desc;\n    return {\n      writable: true,\n      configurable: state.type_ !== 1 /* Array */ || prop !== \"length\",\n      enumerable: desc.enumerable,\n      value: owner[prop]\n    };\n  },\n  defineProperty() {\n    die(11);\n  },\n  getPrototypeOf(state) {\n    return getPrototypeOf(state.base_);\n  },\n  setPrototypeOf() {\n    die(12);\n  }\n};\nvar arrayTraps = {};\neach(objectTraps, (key, fn) => {\n  arrayTraps[key] = function() {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\narrayTraps.deleteProperty = function(state, prop) {\n  if (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop)))\n    die(13);\n  return arrayTraps.set.call(this, state, prop, void 0);\n};\narrayTraps.set = function(state, prop, value) {\n  if (process.env.NODE_ENV !== \"production\" && prop !== \"length\" && isNaN(parseInt(prop)))\n    die(14);\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\nfunction peek(draft, prop) {\n  const state = draft[DRAFT_STATE];\n  const source = state ? latest(state) : draft;\n  return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n  const desc = getDescriptorFromProto(source, prop);\n  return desc ? `value` in desc ? desc.value : (\n    // This is a very special case, if the prop is a getter defined by the\n    // prototype, we should invoke it with the draft as context!\n    desc.get?.call(state.draft_)\n  ) : void 0;\n}\nfunction getDescriptorFromProto(source, prop) {\n  if (!(prop in source))\n    return void 0;\n  let proto = getPrototypeOf(source);\n  while (proto) {\n    const desc = Object.getOwnPropertyDescriptor(proto, prop);\n    if (desc)\n      return desc;\n    proto = getPrototypeOf(proto);\n  }\n  return void 0;\n}\nfunction markChanged(state) {\n  if (!state.modified_) {\n    state.modified_ = true;\n    if (state.parent_) {\n      markChanged(state.parent_);\n    }\n  }\n}\nfunction prepareCopy(state) {\n  if (!state.copy_) {\n    state.copy_ = shallowCopy(\n      state.base_,\n      state.scope_.immer_.useStrictShallowCopy_\n    );\n  }\n}\n\n// src/core/immerClass.ts\nvar Immer2 = class {\n  constructor(config) {\n    this.autoFreeze_ = true;\n    this.useStrictShallowCopy_ = false;\n    /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */\n    this.produce = (base, recipe, patchListener) => {\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\n        const defaultBase = recipe;\n        recipe = base;\n        const self = this;\n        return function curriedProduce(base2 = defaultBase, ...args) {\n          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));\n        };\n      }\n      if (typeof recipe !== \"function\")\n        die(6);\n      if (patchListener !== void 0 && typeof patchListener !== \"function\")\n        die(7);\n      let result;\n      if (isDraftable(base)) {\n        const scope = enterScope(this);\n        const proxy = createProxy(base, void 0);\n        let hasError = true;\n        try {\n          result = recipe(proxy);\n          hasError = false;\n        } finally {\n          if (hasError)\n            revokeScope(scope);\n          else\n            leaveScope(scope);\n        }\n        usePatchesInScope(scope, patchListener);\n        return processResult(result, scope);\n      } else if (!base || typeof base !== \"object\") {\n        result = recipe(base);\n        if (result === void 0)\n          result = base;\n        if (result === NOTHING)\n          result = void 0;\n        if (this.autoFreeze_)\n          freeze(result, true);\n        if (patchListener) {\n          const p = [];\n          const ip = [];\n          getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n          patchListener(p, ip);\n        }\n        return result;\n      } else\n        die(1, base);\n    };\n    this.produceWithPatches = (base, recipe) => {\n      if (typeof base === \"function\") {\n        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));\n      }\n      let patches, inversePatches;\n      const result = this.produce(base, recipe, (p, ip) => {\n        patches = p;\n        inversePatches = ip;\n      });\n      return [result, patches, inversePatches];\n    };\n    if (typeof config?.autoFreeze === \"boolean\")\n      this.setAutoFreeze(config.autoFreeze);\n    if (typeof config?.useStrictShallowCopy === \"boolean\")\n      this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n  }\n  createDraft(base) {\n    if (!isDraftable(base))\n      die(8);\n    if (isDraft(base))\n      base = current(base);\n    const scope = enterScope(this);\n    const proxy = createProxy(base, void 0);\n    proxy[DRAFT_STATE].isManual_ = true;\n    leaveScope(scope);\n    return proxy;\n  }\n  finishDraft(draft, patchListener) {\n    const state = draft && draft[DRAFT_STATE];\n    if (!state || !state.isManual_)\n      die(9);\n    const { scope_: scope } = state;\n    usePatchesInScope(scope, patchListener);\n    return processResult(void 0, scope);\n  }\n  /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */\n  setAutoFreeze(value) {\n    this.autoFreeze_ = value;\n  }\n  /**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */\n  setUseStrictShallowCopy(value) {\n    this.useStrictShallowCopy_ = value;\n  }\n  applyPatches(base, patches) {\n    let i;\n    for (i = patches.length - 1; i >= 0; i--) {\n      const patch = patches[i];\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    }\n    if (i > -1) {\n      patches = patches.slice(i + 1);\n    }\n    const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n    if (isDraft(base)) {\n      return applyPatchesImpl(base, patches);\n    }\n    return this.produce(\n      base,\n      (draft) => applyPatchesImpl(draft, patches)\n    );\n  }\n};\nfunction createProxy(value, parent) {\n  const draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : createProxyProxy(value, parent);\n  const scope = parent ? parent.scope_ : getCurrentScope();\n  scope.drafts_.push(draft);\n  return draft;\n}\n\n// src/core/current.ts\nfunction current(value) {\n  if (!isDraft(value))\n    die(10, value);\n  return currentImpl(value);\n}\nfunction currentImpl(value) {\n  if (!isDraftable(value) || isFrozen(value))\n    return value;\n  const state = value[DRAFT_STATE];\n  let copy;\n  if (state) {\n    if (!state.modified_)\n      return state.base_;\n    state.finalized_ = true;\n    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n  } else {\n    copy = shallowCopy(value, true);\n  }\n  each(copy, (key, childValue) => {\n    set(copy, key, currentImpl(childValue));\n  });\n  if (state) {\n    state.finalized_ = false;\n  }\n  return copy;\n}\n\n// src/plugins/patches.ts\nfunction enablePatches() {\n  const errorOffset = 16;\n  if (process.env.NODE_ENV !== \"production\") {\n    errors.push(\n      'Sets cannot have \"replace\" patches.',\n      function(op) {\n        return \"Unsupported patch operation: \" + op;\n      },\n      function(path) {\n        return \"Cannot apply patch, path doesn't resolve: \" + path;\n      },\n      \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n    );\n  }\n  const REPLACE = \"replace\";\n  const ADD = \"add\";\n  const REMOVE = \"remove\";\n  function generatePatches_(state, basePath, patches, inversePatches) {\n    switch (state.type_) {\n      case 0 /* Object */:\n      case 2 /* Map */:\n        return generatePatchesFromAssigned(\n          state,\n          basePath,\n          patches,\n          inversePatches\n        );\n      case 1 /* Array */:\n        return generateArrayPatches(state, basePath, patches, inversePatches);\n      case 3 /* Set */:\n        return generateSetPatches(\n          state,\n          basePath,\n          patches,\n          inversePatches\n        );\n    }\n  }\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\n    let { base_, assigned_ } = state;\n    let copy_ = state.copy_;\n    if (copy_.length < base_.length) {\n      ;\n      [base_, copy_] = [copy_, base_];\n      [patches, inversePatches] = [inversePatches, patches];\n    }\n    for (let i = 0; i < base_.length; i++) {\n      if (assigned_[i] && copy_[i] !== base_[i]) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REPLACE,\n          path,\n          // Need to maybe clone it, as it can in fact be the original value\n          // due to the base/copy inversion at the start of this function\n          value: clonePatchValueIfNeeded(copy_[i])\n        });\n        inversePatches.push({\n          op: REPLACE,\n          path,\n          value: clonePatchValueIfNeeded(base_[i])\n        });\n      }\n    }\n    for (let i = base_.length; i < copy_.length; i++) {\n      const path = basePath.concat([i]);\n      patches.push({\n        op: ADD,\n        path,\n        // Need to maybe clone it, as it can in fact be the original value\n        // due to the base/copy inversion at the start of this function\n        value: clonePatchValueIfNeeded(copy_[i])\n      });\n    }\n    for (let i = copy_.length - 1; base_.length <= i; --i) {\n      const path = basePath.concat([i]);\n      inversePatches.push({\n        op: REMOVE,\n        path\n      });\n    }\n  }\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n    const { base_, copy_ } = state;\n    each(state.assigned_, (key, assignedValue) => {\n      const origValue = get(base_, key);\n      const value = get(copy_, key);\n      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n      if (origValue === value && op === REPLACE)\n        return;\n      const path = basePath.concat(key);\n      patches.push(op === REMOVE ? { op, path } : { op, path, value });\n      inversePatches.push(\n        op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }\n      );\n    });\n  }\n  function generateSetPatches(state, basePath, patches, inversePatches) {\n    let { base_, copy_ } = state;\n    let i = 0;\n    base_.forEach((value) => {\n      if (!copy_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REMOVE,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: ADD,\n          path,\n          value\n        });\n      }\n      i++;\n    });\n    i = 0;\n    copy_.forEach((value) => {\n      if (!base_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: ADD,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: REMOVE,\n          path,\n          value\n        });\n      }\n      i++;\n    });\n  }\n  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n    patches.push({\n      op: REPLACE,\n      path: [],\n      value: replacement === NOTHING ? void 0 : replacement\n    });\n    inversePatches.push({\n      op: REPLACE,\n      path: [],\n      value: baseValue\n    });\n  }\n  function applyPatches_(draft, patches) {\n    patches.forEach((patch) => {\n      const { path, op } = patch;\n      let base = draft;\n      for (let i = 0; i < path.length - 1; i++) {\n        const parentType = getArchtype(base);\n        let p = path[i];\n        if (typeof p !== \"string\" && typeof p !== \"number\") {\n          p = \"\" + p;\n        }\n        if ((parentType === 0 /* Object */ || parentType === 1 /* Array */) && (p === \"__proto__\" || p === \"constructor\"))\n          die(errorOffset + 3);\n        if (typeof base === \"function\" && p === \"prototype\")\n          die(errorOffset + 3);\n        base = get(base, p);\n        if (typeof base !== \"object\")\n          die(errorOffset + 2, path.join(\"/\"));\n      }\n      const type = getArchtype(base);\n      const value = deepClonePatchValue(patch.value);\n      const key = path[path.length - 1];\n      switch (op) {\n        case REPLACE:\n          switch (type) {\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              die(errorOffset);\n            default:\n              return base[key] = value;\n          }\n        case ADD:\n          switch (type) {\n            case 1 /* Array */:\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              return base.add(value);\n            default:\n              return base[key] = value;\n          }\n        case REMOVE:\n          switch (type) {\n            case 1 /* Array */:\n              return base.splice(key, 1);\n            case 2 /* Map */:\n              return base.delete(key);\n            case 3 /* Set */:\n              return base.delete(patch.value);\n            default:\n              return delete base[key];\n          }\n        default:\n          die(errorOffset + 1, op);\n      }\n    });\n    return draft;\n  }\n  function deepClonePatchValue(obj) {\n    if (!isDraftable(obj))\n      return obj;\n    if (Array.isArray(obj))\n      return obj.map(deepClonePatchValue);\n    if (isMap(obj))\n      return new Map(\n        Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n      );\n    if (isSet(obj))\n      return new Set(Array.from(obj).map(deepClonePatchValue));\n    const cloned = Object.create(getPrototypeOf(obj));\n    for (const key in obj)\n      cloned[key] = deepClonePatchValue(obj[key]);\n    if (has(obj, DRAFTABLE))\n      cloned[DRAFTABLE] = obj[DRAFTABLE];\n    return cloned;\n  }\n  function clonePatchValueIfNeeded(obj) {\n    if (isDraft(obj)) {\n      return deepClonePatchValue(obj);\n    } else\n      return obj;\n  }\n  loadPlugin(\"Patches\", {\n    applyPatches_,\n    generatePatches_,\n    generateReplacementPatches_\n  });\n}\n\n// src/plugins/mapset.ts\nfunction enableMapSet() {\n  class DraftMap extends Map {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 2 /* Map */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        assigned_: void 0,\n        base_: target,\n        draft_: this,\n        isManual_: false,\n        revoked_: false\n      };\n    }\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n    has(key) {\n      return latest(this[DRAFT_STATE]).has(key);\n    }\n    set(key, value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!latest(state).has(key) || latest(state).get(key) !== value) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_.set(key, true);\n        state.copy_.set(key, value);\n        state.assigned_.set(key, true);\n      }\n      return this;\n    }\n    delete(key) {\n      if (!this.has(key)) {\n        return false;\n      }\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareMapCopy(state);\n      markChanged(state);\n      if (state.base_.has(key)) {\n        state.assigned_.set(key, false);\n      } else {\n        state.assigned_.delete(key);\n      }\n      state.copy_.delete(key);\n      return true;\n    }\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (latest(state).size) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_ = /* @__PURE__ */ new Map();\n        each(state.base_, (key) => {\n          state.assigned_.set(key, false);\n        });\n        state.copy_.clear();\n      }\n    }\n    forEach(cb, thisArg) {\n      const state = this[DRAFT_STATE];\n      latest(state).forEach((_value, key, _map) => {\n        cb.call(thisArg, this.get(key), key, this);\n      });\n    }\n    get(key) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      const value = latest(state).get(key);\n      if (state.finalized_ || !isDraftable(value)) {\n        return value;\n      }\n      if (value !== state.base_.get(key)) {\n        return value;\n      }\n      const draft = createProxy(value, state);\n      prepareMapCopy(state);\n      state.copy_.set(key, draft);\n      return draft;\n    }\n    keys() {\n      return latest(this[DRAFT_STATE]).keys();\n    }\n    values() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.values(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done)\n            return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value\n          };\n        }\n      };\n    }\n    entries() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.entries(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done)\n            return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value: [r.value, value]\n          };\n        }\n      };\n    }\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.entries();\n    }\n  }\n  function proxyMap_(target, parent) {\n    return new DraftMap(target, parent);\n  }\n  function prepareMapCopy(state) {\n    if (!state.copy_) {\n      state.assigned_ = /* @__PURE__ */ new Map();\n      state.copy_ = new Map(state.base_);\n    }\n  }\n  class DraftSet extends Set {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 3 /* Set */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        base_: target,\n        draft_: this,\n        drafts_: /* @__PURE__ */ new Map(),\n        revoked_: false,\n        isManual_: false\n      };\n    }\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n    has(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!state.copy_) {\n        return state.base_.has(value);\n      }\n      if (state.copy_.has(value))\n        return true;\n      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n        return true;\n      return false;\n    }\n    add(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!this.has(value)) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.add(value);\n      }\n      return this;\n    }\n    delete(value) {\n      if (!this.has(value)) {\n        return false;\n      }\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      markChanged(state);\n      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (\n        /* istanbul ignore next */\n        false\n      ));\n    }\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (latest(state).size) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.clear();\n      }\n    }\n    values() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.values();\n    }\n    entries() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.entries();\n    }\n    keys() {\n      return this.values();\n    }\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.values();\n    }\n    forEach(cb, thisArg) {\n      const iterator = this.values();\n      let result = iterator.next();\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, this);\n        result = iterator.next();\n      }\n    }\n  }\n  function proxySet_(target, parent) {\n    return new DraftSet(target, parent);\n  }\n  function prepareSetCopy(state) {\n    if (!state.copy_) {\n      state.copy_ = /* @__PURE__ */ new Set();\n      state.base_.forEach((value) => {\n        if (isDraftable(value)) {\n          const draft = createProxy(value, state);\n          state.drafts_.set(value, draft);\n          state.copy_.add(draft);\n        } else {\n          state.copy_.add(value);\n        }\n      });\n    }\n  }\n  function assertUnrevoked(state) {\n    if (state.revoked_)\n      die(3, JSON.stringify(latest(state)));\n  }\n  loadPlugin(\"MapSet\", { proxyMap_, proxySet_ });\n}\n\n// src/immer.ts\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = immer.produceWithPatches.bind(\n  immer\n);\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);\nvar applyPatches = immer.applyPatches.bind(immer);\nvar createDraft = immer.createDraft.bind(immer);\nvar finishDraft = immer.finishDraft.bind(immer);\nfunction castDraft(value) {\n  return value;\n}\nfunction castImmutable(value) {\n  return value;\n}\nexport {\n  Immer2 as Immer,\n  applyPatches,\n  castDraft,\n  castImmutable,\n  createDraft,\n  current,\n  enableMapSet,\n  enablePatches,\n  finishDraft,\n  freeze,\n  DRAFTABLE as immerable,\n  isDraft,\n  isDraftable,\n  NOTHING as nothing,\n  original,\n  produce,\n  produceWithPatches,\n  setAutoFreeze,\n  setUseStrictShallowCopy\n};\n//# sourceMappingURL=immer.mjs.map","import { produce } from 'immer';\n\nconst immerImpl = (initializer) => (set, get, store) => {\n  store.setState = (updater, replace, ...a) => {\n    const nextState = typeof updater === \"function\" ? produce(updater) : updater;\n    return set(nextState, replace, ...a);\n  };\n  return initializer(store.setState, get, store);\n};\nconst immer = immerImpl;\n\nexport { immer };\n","export const AREA_BORDER_WIDTH = 5;\nexport const TOOLBAR_HEIGHT = 30;\nexport const AREA_MIN_CONTENT_WIDTH = 32;\nexport const AREA_PLACEMENT_TRESHOLD = 0.25;\nexport const AREA_TAB_HEIGHT = 32;\n","import { AREA_BORDER_WIDTH } from \"./constants\";\n\ninterface Rect {\n    top: number;\n    left: number;\n    width: number;\n    height: number;\n}\n\n// Storage for stable viewport dimensions\nlet stableViewport: Rect | null = null;\nlet lastAppliedWidth = 0;\nlet lastAppliedHeight = 0;\nlet resizeStartTime = 0;\nconst RESIZE_STABILITY_THRESHOLD = 500; // ms\n\nexport const getAreaRootViewport = () => {\n    // Calculate current window dimensions\n    const currentViewport: Rect = {\n        top: 0,  // No offset as it's already handled by the flow\n        left: 0,\n        height: Math.floor(window.document.querySelector('.area-root')?.getBoundingClientRect().height || 0),  // Subtract MenuBar and StatusBar\n        width: Math.floor(window.document.querySelector('.area-root')?.getBoundingClientRect().width || 0),\n    };\n\n    const now = Date.now();\n\n    // If we're in the middle of resizing or dividing\n    if (window.__AREA_RESIZING__) {\n        // Update resize start time\n        if (!resizeStartTime) {\n            resizeStartTime = now;\n\n            // Store current dimensions at first resize\n            if (!stableViewport) {\n                stableViewport = { ...currentViewport };\n                lastAppliedWidth = currentViewport.width;\n                lastAppliedHeight = currentViewport.height;\n            }\n        }\n\n        // Use stable viewport during the operation\n        if (stableViewport) {\n            return stableViewport;\n        }\n    } else {\n        // Reset resize counter if we're no longer in operation\n        // but only after a stability delay\n        if (resizeStartTime && (now - resizeStartTime > RESIZE_STABILITY_THRESHOLD)) {\n            resizeStartTime = 0;\n        }\n    }\n\n    // Detect significant changes in dimensions\n    const widthChange = Math.abs(currentViewport.width - lastAppliedWidth);\n    const heightChange = Math.abs(currentViewport.height - lastAppliedHeight);\n    const significantChange = widthChange > 5 || heightChange > 5;\n\n    // Update stable dimensions if significant change and no ongoing operation\n    if (!window.__AREA_RESIZING__ && significantChange && !resizeStartTime) {\n        stableViewport = { ...currentViewport };\n        lastAppliedWidth = currentViewport.width;\n        lastAppliedHeight = currentViewport.height;\n    }\n\n    // Return stable viewport if available, otherwise current\n    return stableViewport || currentViewport;\n};\n\n// Function to set the resize flag\nexport const setAreaResizing = (isResizing: boolean) => {\n    window.__AREA_RESIZING__ = isResizing;\n\n    // Reset stability counter if we stop resizing\n    if (!isResizing) {\n        resizeStartTime = 0;\n    }\n};\n\nlet viewportMap: { [key: string]: Rect } = {};\n\nexport const _setAreaViewport = (_viewportMap: { [key: string]: Rect }) => {\n    viewportMap = _viewportMap;\n};\n\nexport const getAreaViewport = (areaId: string, _: string): Rect => {\n    const viewport = viewportMap[areaId];\n\n    if (!viewport) {\n        console.warn(`No viewport found for area ${areaId}`);\n        // Return a default viewport in case of error\n        return {\n            left: AREA_BORDER_WIDTH,\n            top: AREA_BORDER_WIDTH,\n            width: 100 - AREA_BORDER_WIDTH * 2,\n            height: 100 - AREA_BORDER_WIDTH * 2\n        };\n    }\n\n    const componentViewport: Rect = {\n        left: viewport.left + AREA_BORDER_WIDTH,\n        top: viewport.top + AREA_BORDER_WIDTH,\n        width: viewport.width - AREA_BORDER_WIDTH * 2,\n        height: viewport.height - AREA_BORDER_WIDTH * 2,\n    };\n\n    return componentViewport;\n};\n\n// TypeScript type augmentation to add property to window\ndeclare global {\n    interface Window {\n        __AREA_RESIZING__?: boolean;\n    }\n}\n","/**\n * Linear interpolation between two values\n */\nexport const interpolate = (a: number, b: number, t: number) => a * (1 - t) + b * t;\n\n/**\n * Limit a value to a given range\n */\nexport const capToRange = (low: number, high: number, value: number) =>\n    Math.min(high, Math.max(low, value));\n","/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-misused-new */\n\nimport { interpolate } from \"./math\";\n// We will need to implement these functions internally to avoid circular dependencies\n// as these functions already use Vec2\n\ntype IVec2 = Vec2 | { x: number; y: number } | { left: number; top: number };\n\nconst resolveVec2 = (data: IVec2): Vec2 => {\n    if (data instanceof Vec2) {\n        return data;\n    }\n\n    if (typeof (data as any).left === \"number\") {\n        return new Vec2((data as any).left, (data as any).top);\n    }\n\n    return new Vec2((data as any).x, (data as any).y);\n};\n\nexport class Vec2 {\n    public static new(vec: IVec2): Vec2;\n    public static new(x: number, y: number): Vec2;\n    public static new(vecOrX: number | IVec2, y?: number) {\n        if (typeof vecOrX === \"number\") {\n            return new Vec2(vecOrX, y!);\n        }\n\n        if (typeof (vecOrX as any).left === \"number\") {\n            return new Vec2((vecOrX as any).left, (vecOrX as any).top);\n        }\n\n        return new Vec2((vecOrX as any).x, (vecOrX as any).y);\n    }\n\n    public static fromEvent(e: MouseEvent): Vec2 {\n        return new Vec2(e.clientX, e.clientY);\n    }\n    public static ORIGIN = Vec2.new(0, 0);\n\n    /**\n     * Calculate the dot product of two vectors\n     */\n    public static dot(v1: IVec2, v2: IVec2): number {\n        const vec1 = resolveVec2(v1);\n        const vec2 = resolveVec2(v2);\n        return vec1.x * vec2.x + vec1.y * vec2.y;\n    }\n\n    private _x: number;\n    private _y: number;\n    private atOrigin: boolean;\n\n    constructor(vec: { x: number; y: number });\n    constructor(x: number, y: number);\n    constructor(vecOrX: number | { x: number; y: number }, y?: number) {\n        if (typeof vecOrX === \"number\") {\n            this._x = vecOrX;\n            this._y = y!;\n        } else {\n            this._x = vecOrX.x;\n            this._y = vecOrX.y;\n        }\n        this.atOrigin = this.x === 0 && this.y === 0;\n        this.apply = this.apply.bind(this);\n    }\n\n    set x(value: number) {\n        this._x = value;\n        this.atOrigin = this.x === 0 && this.y === 0;\n    }\n    get x() {\n        return this._x;\n    }\n    set y(value: number) {\n        this._y = value;\n        this.atOrigin = this.x === 0 && this.y === 0;\n    }\n    get y() {\n        return this._y;\n    }\n\n    public add(vec: IVec2): Vec2 {\n        const v = resolveVec2(vec);\n        if (v.atOrigin) {\n            return this;\n        }\n\n        return new Vec2(this.x + v.x, this.y + v.y);\n    }\n\n    public addX(x: number): Vec2 {\n        return new Vec2(this.x + x, this.y);\n    }\n\n    public addY(y: number): Vec2 {\n        return new Vec2(this.x, this.y + y);\n    }\n\n    public sub(vec: Vec2): Vec2 {\n        const v = resolveVec2(vec);\n        if (v.atOrigin) {\n            return this;\n        }\n\n        return new Vec2(this.x - v.x, this.y - v.y);\n    }\n\n    public subX(x: number): Vec2 {\n        return new Vec2(this.x - x, this.y);\n    }\n\n    public subY(y: number): Vec2 {\n        return new Vec2(this.x, this.y - y);\n    }\n\n    public subXY(x: number, y: number): Vec2 {\n        return new Vec2(this.x - x, this.y - y);\n    }\n\n    public scale(scale: number, anchor: IVec2 = Vec2.new(0, 0)): Vec2 {\n        if (scale === 1) {\n            return this;\n        }\n\n        const a = resolveVec2(anchor);\n        return new Vec2(a.x + (this.x - a.x) * scale, a.y + (this.y - a.y) * scale);\n    }\n\n    public scaleX(scale: number, anchor: IVec2 = Vec2.new(0, 0)): Vec2 {\n        if (scale === 1) {\n            return this;\n        }\n\n        const a = resolveVec2(anchor);\n        return new Vec2(a.x + (this.x - a.x) * scale, this.y);\n    }\n\n    public scaleY(scale: number, anchor: IVec2 = Vec2.new(0, 0)): Vec2 {\n        if (scale === 1) {\n            return this;\n        }\n\n        const a = resolveVec2(anchor);\n        return new Vec2(this.x, a.y + (this.y - a.y) * scale);\n    }\n\n    public scaleXY(scaleX: number, scaleY: number, anchor: IVec2 = Vec2.new(0, 0)): Vec2 {\n        if (scaleX === 1 && scaleY === 1) {\n            return this;\n        }\n\n        const a = resolveVec2(anchor);\n        return new Vec2(a.x + (this.x - a.x) * scaleX, a.y + (this.y - a.y) * scaleY);\n    }\n\n    public rotate(rad: number, anchor: IVec2 = Vec2.new(0, 0)): Vec2 {\n        if (rad === 0) {\n            return this;\n        }\n\n        const a = resolveVec2(anchor);\n        const x = this.x - a.x;\n        const y = this.y - a.y;\n\n        const cos = Math.cos(rad);\n        const sin = Math.sin(rad);\n\n        const newX = x * cos - y * sin;\n        const newY = x * sin + y * cos;\n\n        return new Vec2(newX + a.x, newY + a.y);\n    }\n\n    public multiplyMat2(mat2: any, anchor: IVec2 = Vec2.new(0, 0)): Vec2 {\n        const a = resolveVec2(anchor);\n        const result = mat2.multiplyVec2(this.sub(a));\n        return result.add(a);\n    }\n\n    public copy(): Vec2 {\n        return new Vec2(this.x, this.y);\n    }\n\n    /**\n     * Linear interpolation\n     *\n     * A `t` value of `0` is this vector, 1 is `vec`\n     */\n    public lerp(vec: IVec2, t: number): Vec2 {\n        const v = resolveVec2(vec);\n        return new Vec2(interpolate(this.x, v.x, t), interpolate(this.y, v.y, t));\n    }\n\n    public round(): Vec2 {\n        return Vec2.new(Math.round(this.x), Math.round(this.y));\n    }\n\n    public apply(fn: (vec: Vec2) => IVec2): Vec2 {\n        return resolveVec2(fn(this));\n    }\n\n    public length(): number {\n        return Math.hypot(this.x, this.y);\n    }\n\n    public eq(vec: IVec2): boolean {\n        const v = resolveVec2(vec);\n        return v.x === this.x && v.y === this.y;\n    }\n\n    // @ts-ignore\n    private toJSON() {\n        return {\n            x: this.x,\n            y: this.y,\n            __objectType: \"vec2\",\n        };\n    }\n}\n\ndeclare global {\n    class Vec2 {\n        public static new(vec: { x: number; y: number } | { left: number; top: number }): Vec2;\n        public static new(x: number, y: number): Vec2;\n        public static fromEvent(e: { clientX: number; clientY: number }): Vec2;\n        public static ORIGIN: Vec2;\n        public static dot(v1: IVec2, v2: IVec2): number;\n\n        public x: number;\n        public y: number;\n\n        constructor(vec: { x: number; y: number });\n        constructor(x: number, y: number);\n\n        public add(vec: IVec2): Vec2;\n        public addX(x: number): Vec2;\n        public addY(y: number): Vec2;\n        public lerp(vec: IVec2, t: number): Vec2;\n        public sub(vec: IVec2): Vec2;\n        public subX(x: number): Vec2;\n        public subY(y: number): Vec2;\n        public subXY(x: number, y: number): Vec2;\n        public scale(scale: number, anchor?: IVec2): Vec2;\n        public scaleX(scale: number, anchor?: IVec2): Vec2;\n        public scaleY(scale: number, anchor?: IVec2): Vec2;\n        public scaleXY(scaleX: number, scaleY: number, anchor?: IVec2): Vec2;\n        public rotate(rad: number, anchor?: IVec2): Vec2;\n        public multiplyMat2(mat2: any, anchor?: IVec2): Vec2;\n        public copy(): Vec2;\n        public round(): Vec2;\n        public apply(fn: (vec2: Vec2) => IVec2): Vec2;\n        public length(): number;\n        public eq(vec: IVec2): boolean;\n    }\n}\n","import React from \"react\";\n\nexport const AreaIdContext = React.createContext<string>(\"\"); \n","import { AreaLayout, AreaRowLayout } from \"../types/areaTypes\";\n\ntype Layout = AreaLayout | AreaRowLayout;\n\nexport const computeAreaRowToMinSize = (rootId: string, areaLayout: Record<string, Layout>) => {\n    const rowToMinSize: { [areaId: string]: { width: number; height: number } } = {};\n\n    const root = areaLayout[rootId];\n\n    if (root.type === \"area\") {\n        return {};\n    }\n\n    function compute(id: string): { height: number; width: number } {\n        const layout = areaLayout[id];\n\n        if (layout.type === \"area\") {\n            return { width: 1, height: 1 };\n        }\n\n        const result = { height: 0, width: 0 };\n\n        const items = layout.areas.map((item: { id: string }) => {\n            return compute(item.id);\n        });\n\n        if (layout.orientation === \"horizontal\") {\n            result.width = items.reduce((acc: number, item: { width: number; height: number }) => acc + item.width, 0);\n            result.height = Math.max(...items.map((item: { width: number; height: number }) => item.height));\n        } else {\n            result.height = items.reduce((acc: number, item: { width: number; height: number }) => acc + item.height, 0);\n            result.width = Math.max(...items.map((item: { width: number; height: number }) => item.width));\n        }\n\n        rowToMinSize[id] = result;\n        return result;\n    }\n\n    rowToMinSize[rootId] = compute(rootId);\n\n    return rowToMinSize;\n};\n","import { AreaLayout, AreaRowLayout } from \"../types/areaTypes\";\n\n// Updated function signature to accept layout and rootId directly\nexport function computeAreaToParentRow(\n    layout: { [key: string]: AreaRowLayout | AreaLayout },\n): { [key: string]: string } {\n    const areaToParentRow: { [key: string]: string } = {};\n\n    // Add a guard clause to handle null or undefined layout\n    if (!layout) {\n        console.error(\"computeAreaToParentRow received null or undefined layout.\");\n        return {}; // Return an empty map if layout is invalid\n    }\n\n    // Use Object.keys directly on the layout object\n    const keys = Object.keys(layout);\n    for (let i = 0; i < keys.length; i += 1) {\n        const layoutItem = layout[keys[i]];\n\n        // Check if the layout item itself is valid before accessing type\n        if (!layoutItem || layoutItem.type !== \"area_row\") {\n            continue;\n        }\n\n        // Cast to AreaRowLayout after checking type\n        const rowLayout = layoutItem as AreaRowLayout;\n\n        // Check if areas array exists and is an array\n        if (rowLayout.areas && Array.isArray(rowLayout.areas)) {\n            for (let j = 0; j < rowLayout.areas.length; j += 1) {\n                // Check if area info and id exist\n                if (rowLayout.areas[j] && rowLayout.areas[j].id) {\n                    areaToParentRow[rowLayout.areas[j].id] = rowLayout.id;\n                }\n            }\n        }\n    }\n\n    return areaToParentRow;\n} \n","import { Rect, AreaLayout, AreaRowLayout } from \"../types\";\n\n// Record viewport calculation history to help with debugging\nconst viewportCalculationHistory = {\n    lastCalculation: 0,\n    totalCalculations: 0,\n    failedIds: new Set<string>(),\n    reportedProblems: new Set<string>(),\n    reset() {\n        this.failedIds.clear();\n        this.reportedProblems.clear();\n    }\n};\n\n// Reset history every 60 seconds\nsetInterval(() => {\n    const now = Date.now();\n    if (now - viewportCalculationHistory.lastCalculation > 60000) {\n        viewportCalculationHistory.reset();\n    }\n}, 60000);\n\n// Static variable to keep the last valid viewport dimensions\nlet lastValidViewportSize = { width: 0, height: 0 };\n\nexport const computeAreaToViewport = (\n    layout: { [key: string]: AreaLayout | AreaRowLayout },\n    rootId: string | null,\n    viewport: { left: number; top: number; width: number; height: number }\n) => {\n    // If rootId is null, return an empty object\n    if (!rootId) {\n        return {};\n    }\n    // Create a deep mutable copy of the layout with type assertion\n    const mutableLayout = JSON.parse(JSON.stringify(layout)) as { [key: string]: AreaLayout | AreaRowLayout };\n\n    // Mark the beginning of the calculation\n    viewportCalculationHistory.lastCalculation = Date.now();\n    viewportCalculationHistory.totalCalculations++;\n\n    // Initial validation of the viewport\n    if (!viewport || viewport.width <= 0 || viewport.height <= 0) {\n        console.error(\"Invalid viewport dimensions\", viewport);\n\n        // Use the last valid dimensions if available\n        if (lastValidViewportSize.width > 0 && lastValidViewportSize.height > 0) {\n            console.warn(\"Using last valid viewport dimensions\");\n            viewport = {\n                ...viewport,\n                width: lastValidViewportSize.width,\n                height: lastValidViewportSize.height\n            };\n        } else {\n            return {};\n        }\n    } else {\n        // Store valid dimensions\n        lastValidViewportSize = { width: viewport.width, height: viewport.height };\n    }\n\n    // Layout validation\n    if (!layout || Object.keys(layout).length === 0) {\n        console.error(\"Empty layout provided to computeAreaToViewport\");\n        return {};\n    }\n\n    // RootId validation\n    if (!rootId || !mutableLayout[rootId]) {\n        console.error(`Invalid rootId: ${rootId} - not found in layout`, layout);\n        return {};\n    }\n\n    const areaToViewport: { [key: string]: { left: number; top: number; width: number; height: number } } = {};\n\n    // List to track visited IDs to avoid infinite loops\n    const visitedIds = new Set<string>();\n    // List of already reported problematic layouts to avoid duplicate logs\n    const reportedProblems = viewportCalculationHistory.reportedProblems;\n\n\n    // Check the structure of areas\n    Object.entries(mutableLayout).forEach(([id, area]) => {\n        if (!area) {\n            console.error(`Invalid area definition for id ${id}`, area);\n        } else if (area.type === \"area_row\" && (!area.areas || !Array.isArray(area.areas))) {\n            console.error(`Area row ${id} has invalid areas property`, area);\n        }\n    });\n\n    function computeArea(area: AreaLayout, contentArea: { left: number; top: number; width: number; height: number }) {\n        if (!area || !contentArea) {\n            console.error(\"Invalid area or contentArea in computeArea\", { area, contentArea });\n            return;\n        }\n\n        // Avoid recalculating a viewport already visited\n        if (visitedIds.has(area.id)) {\n            return;\n        }\n\n        // Check if the area has a valid type\n        if (!area.type) {\n            console.warn(`Area ${area.id} has no type, defaulting to 'area'`);\n            area.type = 'area';\n        }\n\n        // Check if the area has a valid size\n        if (contentArea.width <= 0 || contentArea.height <= 0) {\n            console.warn(`Area ${area.id} has invalid content area size: ${contentArea.width}x${contentArea.height}`);\n            // Do not assign a viewport if the received size is invalid\n            return;\n        }\n\n        visitedIds.add(area.id);\n        areaToViewport[area.id] = { ...contentArea };\n    }\n\n    function computeRow(row: AreaRowLayout, contentArea: { left: number; top: number; width: number; height: number }) {\n\n        if (!row || !contentArea || visitedIds.has(row.id)) {\n            // Simplified initial checks\n            if (row && visitedIds.has(row.id)) return; // Already processed\n            if (!row) { console.error(\"computeRow: Invalid row\"); return; }\n            if (!contentArea) { console.error(\"computeRow: Invalid contentArea for row\", row.id); return; }\n            // Continue validation...\n        }\n        visitedIds.add(row.id);\n\n        // Additional check for areas array\n        if (!row.areas || !Array.isArray(row.areas)) {\n            console.error(\"Row without proper areas array in computeRow\", { rowId: row.id, areas: row.areas });\n            row.areas = [];\n        }\n\n        // Check contentArea size validity\n        if (contentArea.width <= 0 || contentArea.height <= 0) {\n            console.error(\"ContentArea with invalid dimensions in computeRow\", { rowId: row.id, contentArea });\n            // Attempt recovery or return\n            contentArea = {\n                ...contentArea,\n                width: Math.max(contentArea.width, 10), // Min width 10\n                height: Math.max(contentArea.height, 10) // Min height 10\n            };\n            console.warn(\"Corrected contentArea to minimum size for row\", row.id, contentArea);\n        }\n\n        if (row.areas.length === 0) {\n            console.warn(\"Row with empty areas array in computeRow, skipping children but assigning viewport\", { rowId: row.id });\n            areaToViewport[row.id] = { ...contentArea };\n            return;\n        }\n\n        // Assign the full viewport to the parent row itself *before* calculating children\n        areaToViewport[row.id] = { ...contentArea };\n\n        // Check in advance for missing IDs in the layout to avoid problems\n        const missingAreaIds = row.areas\n            .map(area => area.id)\n            .filter(id => !mutableLayout[id]);\n\n        if (missingAreaIds.length > 0) {\n            // Auto-create entries for these missing areas\n            missingAreaIds.forEach(id => {\n                if (!reportedProblems.has(`auto_creating_${id}`)) {\n                    console.warn(`Auto-creating area ${id} referenced in row ${row.id}`);\n                    reportedProblems.add(`auto_creating_${id}`);\n                }\n\n                mutableLayout[id] = {\n                    type: \"area\",\n                    id: id\n                };\n            });\n        }\n\n        // Check and fix invalid sizes\n        const MIN_AREA_SIZE = 0.05; // Minimum size of 5% for an area\n        // @ts-expect-error - hasInvalidSizes is used in the next line\n        let hasInvalidSizes = false;\n        let zeroSizeCount = 0;\n\n        // First pass: detect areas with zero or invalid size\n        row.areas.forEach((area, i) => {\n            // Convert percentage sizes to normalized sizes if needed\n            if (area.size > 1) {\n                area.size = area.size / 100;\n            }\n\n            if (typeof area.size !== 'number' || isNaN(area.size) || area.size <= 0) {\n                hasInvalidSizes = true;\n                if (area.size === 0) {\n                    zeroSizeCount++;\n                }\n                if (!reportedProblems.has(`${row.id}_${i}_size`)) {\n                    console.warn(`Invalid size for area ${area.id}: ${area.size}, defaulting to 1/${row.areas.length}`);\n                    reportedProblems.add(`${row.id}_${i}_size`);\n                }\n                area.size = 1 / row.areas.length;\n            } else if (area.size < MIN_AREA_SIZE) {\n                // Ensure each area has a minimum size\n                if (!reportedProblems.has(`${row.id}_${i}_min_size`)) {\n                    console.warn(`Area ${area.id} has very small size: ${area.size}, setting to minimum ${MIN_AREA_SIZE}`);\n                    reportedProblems.add(`${row.id}_${i}_min_size`);\n                }\n                area.size = MIN_AREA_SIZE;\n                hasInvalidSizes = true;\n            }\n        });\n\n        // Ensure the sum of sizes equals exactly 1.0\n        const totalArea = row.areas.reduce((acc, area) => acc + (area.size || 0), 0);\n\n        // If all areas have zero size, set equal sizes\n        if (totalArea === 0 || zeroSizeCount === row.areas.length) {\n            console.warn(`All areas in row ${row.id} have zero size, setting equal distribution`);\n            const equalSize = 1.0 / row.areas.length;\n            row.areas.forEach(area => {\n                area.size = equalSize;\n            });\n        }\n        // If the total is too far from 1.0, normalize the values\n        else if (Math.abs(totalArea - 1.0) > 0.001) {\n            const normalizationFactor = 1.0 / totalArea;\n            row.areas.forEach(area => {\n                area.size = area.size * normalizationFactor;\n            });\n        }\n\n        // Final size check\n        const finalTotal = row.areas.reduce((acc, area) => acc + (area.size || 0), 0);\n        if (Math.abs(finalTotal - 1.0) > 0.001) {\n            console.error(`Failed to normalize sizes in row ${row.id}: final total=${finalTotal}`);\n            // In case of failure, use equal distribution\n            const equalSize = 1.0 / row.areas.length;\n            row.areas.forEach(area => {\n                area.size = equalSize;\n            });\n        }\n\n        let currentLeft = contentArea.left;\n        let currentTop = contentArea.top;\n        let totalAllocatedWidth = 0;\n        let totalAllocatedHeight = 0;\n\n\n        for (let i = 0; i < row.areas.length; i++) {\n            const areaInfo = row.areas[i];\n            // Check if areaInfo and its id are valid\n            if (!areaInfo || !areaInfo.id) {\n                continue; // Skip this iteration\n            }\n            const areaId = areaInfo.id;\n            const layoutItem = mutableLayout[areaId];\n            const isLastArea = i === row.areas.length - 1;\n\n            if (!layoutItem) {\n                continue;\n            }\n\n            let areaWidth: number;\n            let areaHeight: number;\n\n            if (row.orientation === \"horizontal\") {\n                areaHeight = contentArea.height;\n                if (isLastArea) {\n                    areaWidth = Math.max(0, contentArea.width - totalAllocatedWidth);\n                } else {\n                    areaWidth = Math.max(0, Math.floor(areaInfo.size * contentArea.width));\n                    totalAllocatedWidth += areaWidth;\n                }\n            } else { // Vertical\n                areaWidth = contentArea.width;\n                if (isLastArea) {\n                    areaHeight = Math.max(0, contentArea.height - totalAllocatedHeight);\n                } else {\n                    areaHeight = Math.max(0, Math.floor(areaInfo.size * contentArea.height));\n                    totalAllocatedHeight += areaHeight;\n                }\n            }\n\n            const nextAreaViewport: Rect = {\n                left: currentLeft,\n                top: currentTop,\n                width: areaWidth,\n                height: areaHeight\n            };\n\n            // Recursive call\n            try {\n                if (layoutItem.type === \"area\") {\n                    computeArea(layoutItem, nextAreaViewport);\n                } else if (layoutItem.type === \"area_row\") {\n                    computeRow(layoutItem, nextAreaViewport);\n                }\n            } catch (error) {\n                console.error(`[computeRow RECURSE_ERROR ${i}] Error computing viewport for area ${areaId}:`, error);\n            }\n\n            // Update position for the next iteration\n            if (row.orientation === \"horizontal\") {\n                currentLeft += areaWidth;\n            } else { // Vertical\n                currentTop += areaHeight;\n            }\n        }\n    }\n\n    // Calculate the initial viewport for the root\n    const rootLayoutItem = mutableLayout[rootId];\n    if (rootLayoutItem.type === \"area\") {\n        computeArea(rootLayoutItem, viewport);\n    } else if (rootLayoutItem.type === \"area_row\") {\n        computeRow(rootLayoutItem, viewport);\n    }\n\n    // Get all missing IDs\n    const idsWithoutViewport = Object.keys(mutableLayout).filter(id => !areaToViewport[id]);\n\n    // If IDs are missing in viewports, we can try one last calculation pass\n    if (idsWithoutViewport.length > 0) {\n        // Try to calculate again using alternative parent-child relationships\n        idsWithoutViewport.forEach(id => {\n            // If no viewport was calculated, use a default viewport\n            if (!areaToViewport[id]) {\n                viewportCalculationHistory.failedIds.add(id);\n                areaToViewport[id] = {\n                    left: 0,\n                    top: 0,\n                    width: 100,\n                    height: 100\n                };\n            }\n        });\n    }\n\n    return areaToViewport;\n}; \n","import { Vec2 } from \"./vec2\";\nimport { AreaReducerState, Rect } from \"../types\";\n\nexport type PlaceArea = \"top\" | \"left\" | \"right\" | \"bottom\" | \"stack\";\n\nexport const getHoveredAreaId = (\n    position: Vec2,\n    areaState: AreaReducerState,\n    areaToViewport: {\n        [areaId: string]: Rect;\n    },\n    draggedElementDimensions?: Vec2,\n): string | undefined => {\n    // If we have the dimensions of the dragged element, calculate the center\n    const centerPosition = draggedElementDimensions\n        ? Vec2.new(\n            position.x + draggedElementDimensions.x / 15,\n            position.y + draggedElementDimensions.y / 15\n        )\n        : position;\n\n    let hoveredStackId: string | undefined;\n    let hoveredAreaId: string | undefined;\n    let minDistance = Infinity;\n    let closestAreaId: string | undefined;\n\n    // Go through all areas and find the closest one\n    Object.entries(areaToViewport).forEach(([id, viewport]) => {\n        const layout = areaState.layout[id];\n        if (!layout || (layout.type !== 'area' && !(layout.type === 'area_row' && (layout as any).orientation === 'stack'))) return;\n\n        const isInside = centerPosition.x >= viewport.left &&\n            centerPosition.x <= viewport.left + viewport.width &&\n            centerPosition.y >= viewport.top &&\n            centerPosition.y <= viewport.top + viewport.height;\n\n        if (isInside) {\n            if (layout.type === 'area_row' && (layout as any).orientation === 'stack') {\n                hoveredStackId = id;\n            } else if (layout.type === 'area') {\n                hoveredAreaId = id;\n            }\n            return;\n        }\n\n        // Calculate distance to the nearest edge\n        const distanceToLeft = Math.abs(centerPosition.x - viewport.left);\n        const distanceToRight = Math.abs(centerPosition.x - (viewport.left + viewport.width));\n        const distanceToTop = Math.abs(centerPosition.y - viewport.top);\n        const distanceToBottom = Math.abs(centerPosition.y - (viewport.top + viewport.height));\n\n        // Calculate minimum distance to edges\n        const distance = Math.min(distanceToLeft, distanceToRight, distanceToTop, distanceToBottom);\n\n        // If this area is closer than the previous one, select it\n        if (distance < minDistance) {\n            minDistance = distance;\n            closestAreaId = id;\n        }\n    });\n\n    // Priorité : 1. Stack hovered, 2. Area hovered, 3. Closest area\n    return hoveredStackId || hoveredAreaId || closestAreaId;\n};\n\nexport function getAreaToOpenPlacementInViewport(\n    viewport: { left: number; top: number; width: number; height: number },\n    position: Vec2\n): PlaceArea {\n\n    // Calculate relative position in the viewport\n    const relativeX = position.x - viewport.left;\n    const relativeY = position.y - viewport.top;\n\n    // Calculate distances to edges\n    const distanceToLeft = relativeX;\n    const distanceToRight = viewport.width - relativeX;\n    const distanceToTop = relativeY;\n    const distanceToBottom = viewport.height - relativeY;\n\n    // Calculate distance to center\n    const centerX = viewport.width / 2;\n    const centerY = viewport.height / 2;\n\n    // Calculate independent distances to center\n    const distanceToCenterX = Math.abs(relativeX - centerX);\n    const distanceToCenterY = Math.abs(relativeY - centerY);\n\n    // Define independent thresholds for X and Y\n    const centerThresholdX = viewport.width * 0.3; // 25% of the width\n    const centerThresholdY = viewport.height * 0.3; // 25% of the height\n\n    // Check if the position is within the rectangular central area\n    if (distanceToCenterX < centerThresholdX && distanceToCenterY < centerThresholdY) {\n        return \"stack\";\n    }\n\n    // Find minimum distance to edges\n    const minDistance = Math.min(\n        distanceToLeft,\n        distanceToRight,\n        distanceToTop,\n        distanceToBottom\n    );\n\n    // Determine placement based on minimum distance\n    let placement: PlaceArea;\n    if (minDistance === distanceToLeft) {\n        placement = \"left\";\n    } else if (minDistance === distanceToRight) {\n        placement = \"right\";\n    } else if (minDistance === distanceToTop) {\n        placement = \"top\";\n    } else {\n        placement = \"bottom\";\n    }\n\n    return placement;\n}\n","import { AreaLayout, AreaRowLayout } from \"../types/areaTypes\";\n\nexport const joinAreas = (\n    row: AreaRowLayout,\n    mergeArea: number,  // This is the source area (the one being moved)\n    mergeInto: -1 | 1  // Merge direction (-1 for west, 1 for east)\n) => {\n    // mergeArea is the source index\n    const sourceIndex = mergeArea;\n    // The target is to the left (mergeInto = -1) or to the right (mergeInto = 1) of the source\n    const targetIndex = sourceIndex + mergeInto;\n\n    // Check that indices are valid\n    if (sourceIndex < 0 || sourceIndex >= row.areas.length ||\n        targetIndex < 0 || targetIndex >= row.areas.length) {\n        throw new Error(`Invalid indices: source=${sourceIndex}, target=${targetIndex}, length=${row.areas.length}, direction=${mergeInto === -1 ? 'west' : 'east'}`);\n    }\n\n    const sourceArea = row.areas[sourceIndex];\n    const targetArea = row.areas[targetIndex];\n\n    if (!sourceArea || !targetArea) {\n        throw new Error(`Missing areas: source=${sourceArea}, target=${targetArea}`);\n    }\n\n    // Calculate new size (sum of both areas)\n    const sourceSize = sourceArea.size || 1;\n    const targetSize = targetArea.size || 1;\n    const newSize = sourceSize + targetSize;\n\n    // If we have only 2 areas\n    if (row.areas.length === 2) {\n        const newArea: AreaLayout = {\n            type: \"area\",\n            id: sourceArea.id\n        };\n        return { area: newArea, removedAreaId: targetArea.id };\n    }\n\n    // For more than 2 areas\n    const resultAreas = [...row.areas];\n\n    // The source area takes the target's position with the combined size\n    resultAreas[targetIndex] = {\n        id: sourceArea.id,\n        size: newSize\n    };\n\n    // Remove the original source position\n    resultAreas.splice(sourceIndex, 1);\n\n    // Create the new resulting area\n    const newArea: AreaRowLayout = {\n        ...row,\n        areas: resultAreas\n    };\n\n    // Return the result\n    return {\n        area: newArea,\n        removedAreaId: targetArea.id\n    };\n}; \n","import { HSLColor, RGBAColor, RGBColor } from \"../../types/colorTypes\";\n\nexport const hexRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\n\nexport const hexToRGB = (hex: string): RGBColor => {\n    const [, r, g, b] = hexRegex.exec(hex)!;\n    return [r, g, b].map((c) => parseInt(c, 16)) as RGBColor;\n};\nexport const hexToBinary = (hex: string): number => {\n    if (hex.substr(0, 1) === \"#\") {\n        hex = hex.substr(1);\n    }\n    return parseInt(hex, 16);\n};\n\nexport const rgbToBinary = (rgb: RGBColor): number => {\n    const [r, g, b] = rgb;\n    let n = r * 256;\n    n += g;\n    n *= 256;\n    n += b;\n    return n;\n};\n\nexport const hexToRGBA = (hex: string): RGBAColor => {\n    const [r, g, b] = hexToRGB(hex);\n    return [r, g, b, 1];\n};\n\nexport const hexToRGBAString = (hex: string, alpha = 1): string =>\n    `rgba(${hexToRGB(hex).join(\",\")},${alpha})`;\n\nexport const rgbToString = (rgb: RGBColor, alpha = 1): string => `rgba(${rgb.join(\",\")},${alpha})`;\nexport const rgbaToString = (rgba: RGBAColor): string => `rgba(${rgba.join(\",\")})`;\n\nexport const rgbToHSL = (rgbColor: RGBColor): HSLColor => {\n    let [r, g, b] = rgbColor;\n\n    // 0-1\n    r /= 255;\n    g /= 255;\n    b /= 255;\n\n    const cmin = Math.min(r, g, b);\n    const cmax = Math.max(r, g, b);\n\n    const delta = cmax - cmin;\n\n    let h = 0;\n    let l = (cmax + cmin) / 2;\n    let s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));\n\n    // Calculate hue\n    if (delta === 0) {\n        h = 0;\n    } else if (cmax === r) {\n        h = ((g - b) / delta) % 6;\n    } else if (cmax === g) {\n        h = (b - r) / delta + 2;\n    } else {\n        h = (r - g) / delta + 4;\n    }\n\n    h = Math.round(h * 60);\n\n    if (h < 0) {\n        h += 360;\n    }\n\n    s = Number((s * 100).toFixed(1));\n    l = Number((l * 100).toFixed(1));\n\n    return [h, s, l];\n};\n\nexport const hslToRGB = ([h, s, l]: HSLColor): RGBColor => {\n    // 0-1\n    s /= 100;\n    l /= 100;\n\n    const c = (1 - Math.abs(2 * l - 1)) * s;\n    const x = c * (1 - Math.abs(((h / 60) % 2) - 1));\n    const m = l - c / 2;\n\n    let r = 0;\n    let g = 0;\n    let b = 0;\n\n    if (h >= 0 && h < 60) {\n        r = c;\n        g = x;\n        b = 0;\n    } else if (h >= 60 && h < 120) {\n        r = x;\n        g = c;\n        b = 0;\n    } else if (h >= 120 && h < 180) {\n        r = 0;\n        g = c;\n        b = x;\n    } else if (h >= 180 && h < 240) {\n        r = 0;\n        g = x;\n        b = c;\n    } else if (h >= 240 && h < 300) {\n        r = x;\n        g = 0;\n        b = c;\n    } else if (h >= 300 && h < 360) {\n        r = c;\n        g = 0;\n        b = x;\n    }\n\n    r = Math.round((r + m) * 255);\n    g = Math.round((g + m) * 255);\n    b = Math.round((b + m) * 255);\n\n    return [r, g, b];\n};\n","import { RGBAColor } from \"../../types/colorTypes\";\nimport { hexToRGBA } from \"./convertColor\";\n\n// Regex for standard 6-digit hex colors (e.g., #FF00AA)\nexport const hexColorRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\n\n// Regex for shorthand 3-digit hex colors (e.g., #F0A)\nexport const shortHexColorRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i; \n\nconst cssColorNameToHex: Record<string, string> = {\n    aliceblue: \"#f0f8ff\",\n    antiquewhite: \"#faebd7\",\n    aqua: \"#00ffff\",\n    aquamarine: \"#7fffd4\",\n    azure: \"#f0ffff\",\n    beige: \"#f5f5dc\",\n    bisque: \"#ffe4c4\",\n    black: \"#000000\",\n    blanchedalmond: \"#ffebcd\",\n    blue: \"#0000ff\",\n    blueviolet: \"#8a2be2\",\n    brown: \"#a52a2a\",\n    burlywood: \"#deb887\",\n    cadetblue: \"#5f9ea0\",\n    chartreuse: \"#7fff00\",\n    chocolate: \"#d2691e\",\n    coral: \"#ff7f50\",\n    cornflowerblue: \"#6495ed\",\n    cornsilk: \"#fff8dc\",\n    crimson: \"#dc143c\",\n    cyan: \"#00ffff\",\n    darkblue: \"#00008b\",\n    darkcyan: \"#008b8b\",\n    darkgoldenrod: \"#b8860b\",\n    darkgray: \"#a9a9a9\",\n    darkgreen: \"#006400\",\n    darkgrey: \"#a9a9a9\",\n    darkkhaki: \"#bdb76b\",\n    darkmagenta: \"#8b008b\",\n    darkolivegreen: \"#556b2f\",\n    darkorange: \"#ff8c00\",\n    darkorchid: \"#9932cc\",\n    darkred: \"#8b0000\",\n    darksalmon: \"#e9967a\",\n    darkseagreen: \"#8fbc8f\",\n    darkslateblue: \"#483d8b\",\n    darkslategray: \"#2f4f4f\",\n    darkslategrey: \"#2f4f4f\",\n    darkturquoise: \"#00ced1\",\n    darkviolet: \"#9400d3\",\n    deeppink: \"#ff1493\",\n    deepskyblue: \"#00bfff\",\n    dimgray: \"#696969\",\n    dimgrey: \"#696969\",\n    dodgerblue: \"#1e90ff\",\n    firebrick: \"#b22222\",\n    floralwhite: \"#fffaf0\",\n    forestgreen: \"#228b22\",\n    fuchsia: \"#ff00ff\",\n    gainsboro: \"#dcdcdc\",\n    ghostwhite: \"#f8f8ff\",\n    goldenrod: \"#daa520\",\n    gold: \"#ffd700\",\n    gray: \"#808080\",\n    green: \"#008000\",\n    greenyellow: \"#adff2f\",\n    grey: \"#808080\",\n    honeydew: \"#f0fff0\",\n    hotpink: \"#ff69b4\",\n    indianred: \"#cd5c5c\",\n    indigo: \"#4b0082\",\n    ivory: \"#fffff0\",\n    khaki: \"#f0e68c\",\n    lavenderblush: \"#fff0f5\",\n    lavender: \"#e6e6fa\",\n    lawngreen: \"#7cfc00\",\n    lemonchiffon: \"#fffacd\",\n    lightblue: \"#add8e6\",\n    lightcoral: \"#f08080\",\n    lightcyan: \"#e0ffff\",\n    lightgoldenrodyellow: \"#fafad2\",\n    lightgray: \"#d3d3d3\",\n    lightgreen: \"#90ee90\",\n    lightgrey: \"#d3d3d3\",\n    lightpink: \"#ffb6c1\",\n    lightsalmon: \"#ffa07a\",\n    lightseagreen: \"#20b2aa\",\n    lightskyblue: \"#87cefa\",\n    lightslategray: \"#778899\",\n    lightslategrey: \"#778899\",\n    lightsteelblue: \"#b0c4de\",\n    lightyellow: \"#ffffe0\",\n    lime: \"#00ff00\",\n    limegreen: \"#32cd32\",\n    linen: \"#faf0e6\",\n    magenta: \"#ff00ff\",\n    maroon: \"#800000\",\n    mediumaquamarine: \"#66cdaa\",\n    mediumblue: \"#0000cd\",\n    mediumorchid: \"#ba55d3\",\n    mediumpurple: \"#9370db\",\n    mediumseagreen: \"#3cb371\",\n    mediumslateblue: \"#7b68ee\",\n    mediumspringgreen: \"#00fa9a\",\n    mediumturquoise: \"#48d1cc\",\n    mediumvioletred: \"#c71585\",\n    midnightblue: \"#191970\",\n    mintcream: \"#f5fffa\",\n    mistyrose: \"#ffe4e1\",\n    moccasin: \"#ffe4b5\",\n    navajowhite: \"#ffdead\",\n    navy: \"#000080\",\n    oldlace: \"#fdf5e6\",\n    olive: \"#808000\",\n    olivedrab: \"#6b8e23\",\n    orange: \"#ffa500\",\n    orangered: \"#ff4500\",\n    orchid: \"#da70d6\",\n    palegoldenrod: \"#eee8aa\",\n    palegreen: \"#98fb98\",\n    paleturquoise: \"#afeeee\",\n    palevioletred: \"#db7093\",\n    papayawhip: \"#ffefd5\",\n    peachpuff: \"#ffdab9\",\n    peru: \"#cd853f\",\n    pink: \"#ffc0cb\",\n    plum: \"#dda0dd\",\n    powderblue: \"#b0e0e6\",\n    purple: \"#800080\",\n    rebeccapurple: \"#663399\",\n    red: \"#ff0000\",\n    rosybrown: \"#bc8f8f\",\n    royalblue: \"#4169e1\",\n    saddlebrown: \"#8b4513\",\n    salmon: \"#fa8072\",\n    sandybrown: \"#f4a460\",\n    seagreen: \"#2e8b57\",\n    seashell: \"#fff5ee\",\n    sienna: \"#a0522d\",\n    silver: \"#c0c0c0\",\n    skyblue: \"#87ceeb\",\n    slateblue: \"#6a5acd\",\n    slategray: \"#708090\",\n    slategrey: \"#708090\",\n    snow: \"#fffafa\",\n    springgreen: \"#00ff7f\",\n    steelblue: \"#4682b4\",\n    tan: \"#d2b48c\",\n    teal: \"#008080\",\n    thistle: \"#d8bfd8\",\n    tomato: \"#ff6347\",\n    turquoise: \"#40e0d0\",\n    violet: \"#ee82ee\",\n    wheat: \"#f5deb3\",\n    white: \"#ffffff\",\n    whitesmoke: \"#f5f5f5\",\n    yellow: \"#ffff00\",\n    yellowgreen: \"#9acd32\",\n};\n\nexport const getRgbaFromCssColor = (color: string | undefined): RGBAColor | undefined => {\n    if (!color) {\n        return undefined;\n    }\n\n    if (cssColorNameToHex[color]) {\n        const hex = cssColorNameToHex[color];\n        return hexToRGBA(hex);\n    }\n\n    if (hexColorRegex.test(color)) {\n        return hexToRGBA(color);\n    }\n\n    if (shortHexColorRegex.test(color)) {\n        if (color.substr(0, 1) === \"#\") {\n            color = color.substr(1);\n        }\n        let out = \"\";\n        for (const c of color.split(\"\")) {\n            out += c + c;\n        }\n        return hexToRGBA(\"#\" + out);\n    }\n\n    if (color.toLowerCase() === \"none\") {\n        return undefined;\n    }\n\n    throw new Error(\"Only hex and CSS name colors are supported yet.\");\n};\n","/**\n * Type d'action générique pour le système de plugins\n */\nexport interface Action<T = any> {\n    type: string;\n    payload?: T;\n    [key: string]: any;\n}\n\n/**\n * Action validation result\n */\nexport interface IActionValidationResult {\n    valid: boolean;\n    message?: string;\n}\n\n/**\n * Action validator function type\n */\nexport type TActionValidator = (action: Action) => IActionValidationResult;\n\n/**\n * Action plugin interface\n */\nexport interface IActionPlugin {\n    id: string;\n    priority: number;\n    actionTypes: string[] | null;\n    handler: (action: Action) => void;\n    onRegister?: () => void;\n    onUnregister?: () => void;\n}\n\n/**\n * Action registry interface\n */\nexport interface IActionRegistry {\n    registerPlugin(plugin: IActionPlugin): void;\n    unregisterPlugin(id: string): void;\n    registerValidator(actionType: string, validator: TActionValidator): void;\n    unregisterValidators(actionType: string): void;\n    validateAction(action: Action): IActionValidationResult;\n    handleAction(action: Action): void;\n}\n\n/**\n * Action registry options\n */\nexport interface IActionRegistryOptions {\n    defaultValidators?: Record<string, TActionValidator[]>;\n}\n\n/**\n * Type for an action handler\n */\nexport type TActionHandler<T extends Action = Action> = (action: T) => void;\n\n/**\n * Interface for an action\n */\nexport interface IAction<T extends Action = Action> {\n    id: string;\n    type: string;\n    priority?: number;\n    actionTypes: string[] | null; // null means all action types\n    handler: TActionHandler<T>;\n}\n\n/**\n * Action priorities\n */\nexport enum ActionPriority {\n    CRITICAL = 1000,  // Critical actions (security, validation)\n    HIGH = 800,       // Important actions (history, logging)\n    NORMAL = 500,     // Standard actions\n    LOW = 200,        // Low priority actions (analytics, etc.)\n    BACKGROUND = 100  // Background actions\n} \n\nexport const AREA_ROLE = {\n    LEAD: \"LEAD\",\n    FOLLOW: \"FOLLOW\",\n    SELF: \"SELF\"\n} as const;\n\nexport type AreaTypeValue = string;\n","import { ComponentType } from \"react\";\n\n/**\n * Area registry interface\n */\ninterface IAreaRegistry {\n    // Registration methods\n    registerComponent: (areaType: string, component: ComponentType<any>) => void;\n    registerInitialState: (areaType: string, initialState: any) => void;\n    registerDisplayName: (areaType: string, name: string) => void;\n    registerIcon: (areaType: string, icon: any) => void;\n    registerDefaultSize: (areaType: string, size: { width: number, height: number }) => void;\n    registerSupportedActions: (areaType: string, actions: string[]) => void;\n\n    // Retrieval methods\n    getComponent: (areaType: string) => ComponentType<any> | undefined;\n    getInitialState: (areaType: string) => any;\n    getDisplayName: (areaType: string) => string;\n    getIcon: (areaType: string) => any;\n    getDefaultSize: (areaType: string) => { width: number, height: number } | undefined;\n    getSupportedActions: (areaType: string) => string[] | undefined;\n    getRegisteredTypes: () => Set<string>;\n\n    // Unregistration method\n    unregisterAreaType: (areaType: string) => void;\n}\n\n// In-memory storage for registered areas\nconst areaStorage = new Map<string, {\n    component?: ComponentType<any>;\n    initialState?: any;\n    displayName?: string;\n    icon?: any;\n    defaultSize?: { width: number, height: number };\n    supportedActions?: string[];\n}>();\n\n/**\n * Area Registry\n * Allows registering and retrieving components and initial states of areas\n */\nexport const areaRegistry: IAreaRegistry = {\n    // Registration methods\n    registerComponent: (areaType: string, component: ComponentType<any>) => {\n        const existing = areaStorage.get(areaType) || {};\n        areaStorage.set(areaType, { ...existing, component });\n    },\n\n    registerInitialState: (areaType: string, initialState: any) => {\n        const existing = areaStorage.get(areaType) || {};\n        areaStorage.set(areaType, { ...existing, initialState });\n    },\n\n    registerDisplayName: (areaType: string, name: string) => {\n        const existing = areaStorage.get(areaType) || {};\n        areaStorage.set(areaType, { ...existing, displayName: name });\n    },\n\n    registerIcon: (areaType: string, icon: any) => {\n        const existing = areaStorage.get(areaType) || {};\n        areaStorage.set(areaType, { ...existing, icon });\n    },\n\n    registerDefaultSize: (areaType: string, size: { width: number, height: number }) => {\n        const existing = areaStorage.get(areaType) || {};\n        areaStorage.set(areaType, { ...existing, defaultSize: size });\n    },\n\n    registerSupportedActions: (areaType: string, actions: string[]) => {\n        const existing = areaStorage.get(areaType) || {};\n        areaStorage.set(areaType, { ...existing, supportedActions: actions });\n    },\n\n    // Retrieval methods\n    getComponent: (areaType: string) => {\n        return areaStorage.get(areaType)?.component;\n    },\n\n    getInitialState: (areaType: string) => {\n        return areaStorage.get(areaType)?.initialState || {};\n    },\n\n    getDisplayName: (areaType: string) => {\n        return areaStorage.get(areaType)?.displayName || areaType;\n    },\n\n    getIcon: (areaType: string) => {\n        return areaStorage.get(areaType)?.icon;\n    },\n\n    getDefaultSize: (areaType: string) => {\n        return areaStorage.get(areaType)?.defaultSize;\n    },\n\n    getSupportedActions: (areaType: string) => {\n        return areaStorage.get(areaType)?.supportedActions;\n    },\n\n    // New method to get all registered types\n    getRegisteredTypes: () => {\n        return new Set(Array.from(areaStorage.keys()));\n    },\n\n    // Unregistration method\n    unregisterAreaType: (areaType: string) => {\n        areaStorage.delete(areaType);\n    }\n};\n","import { IArea } from '../types/areaTypes';\nimport { ContextMenuItem } from '../types/contextMenu';\nimport { IDiff } from '../types/diff';\nimport { IState } from '../types/state';\nimport { IToolbarItem } from '../types/toolbarType';\nimport { areaRegistry } from '../store/registries/areaRegistry';\n\n// All validation functions commented out as they are unused according to ts-prune\n// and the re-export in utils/index.ts has been commented out.\n/*\n// Area validation\nexport const validateArea = (area: Area<string>): { isValid: boolean; errors: string[] } => {\n    const errors: string[] = [];\n\n    if (!area.type) errors.push('Missing type');\n    if (!area.state) errors.push('Missing state');\n\n    return {\n        isValid: errors.length === 0,\n        errors,\n    };\n};\n\n// State validation\nexport const validateState = (state: IState): { isValid: boolean; errors: string[] } => {\n    const errors: string[] = [];\n\n    if (!state.id) errors.push('Missing ID');\n    if (!state.type) errors.push('Missing type');\n    if (!state.name) errors.push('Missing name');\n    if (!state.transitions) errors.push('Missing transitions');\n\n    return {\n        isValid: errors.length === 0,\n        errors,\n    };\n};\n\n// Diff validation\nexport const validateDiff = (diff: IDiff): { isValid: boolean; errors: string[] } => {\n    const errors: string[] = [];\n\n    if (!diff.id) errors.push('Missing ID');\n    if (!diff.type) errors.push('Missing type');\n    if (!diff.changes) errors.push('Missing changes');\n    if (!diff.timestamp) errors.push('Missing timestamp');\n\n    return {\n        isValid: errors.length === 0,\n        errors,\n    };\n};\n\n// Toolbar item validation\nexport const validateToolbarItem = (item: IToolbarItem): { isValid: boolean; errors: string[] } => {\n    const errors: string[] = [];\n\n    if (!item.id) errors.push('Missing ID');\n    if (!item.type) errors.push('Missing type');\n    if (!item.label) errors.push('Missing label');\n\n    return {\n        isValid: errors.length === 0,\n        errors,\n    };\n};\n\n// Dimensions validation\nexport const validateDimensions = (dimensions: { width: number; height: number }): { isValid: boolean; errors: string[] } => {\n    const errors: string[] = [];\n\n    if (dimensions.width <= 0) errors.push('Invalid width');\n    if (dimensions.height <= 0) errors.push('Invalid height');\n\n    return {\n        isValid: errors.length === 0,\n        errors,\n    };\n};\n*/\n\n// Restoring validation functions as they seem to be used directly\n\n// Area validation\nexport const validateArea = (area: IArea<string>): { isValid: boolean; errors: string[] } => {\n    const errors: string[] = [];\n\n    if (!area.id) errors.push('Missing ID');\n    if (!area.type) errors.push('Missing type');\n    if (!area.state) errors.push('Missing state');\n\n    // Vérifier si le type de zone est valide\n    if (area.type && !areaRegistry.getRegisteredTypes().has(area.type)) {\n        errors.push(`Invalid area type: ${area.type}`);\n    }\n\n    return {\n        isValid: errors.length === 0,\n        errors,\n    };\n};\n\n// State validation\nexport const validateState = (state: IState): { isValid: boolean; errors: string[] } => {\n    const errors: string[] = [];\n\n    if (!state.id) errors.push('Missing ID');\n    if (!state.type) errors.push('Missing type');\n    if (!state.name) errors.push('Missing name');\n    if (!state.transitions) errors.push('Missing transitions');\n\n    return {\n        isValid: errors.length === 0,\n        errors,\n    };\n};\n\n// Diff validation\nexport const validateDiff = (diff: IDiff): { isValid: boolean; errors: string[] } => {\n    const errors: string[] = [];\n\n    if (!diff.id) errors.push('Missing ID');\n    if (!diff.type) errors.push('Missing type');\n    if (!diff.changes) errors.push('Missing changes');\n    if (!diff.timestamp) errors.push('Missing timestamp');\n\n    return {\n        isValid: errors.length === 0,\n        errors,\n    };\n};\n\n// Toolbar item validation\nexport const validateToolbarItem = (item: IToolbarItem): { isValid: boolean; errors: string[] } => {\n    const errors: string[] = [];\n\n    if (!item.id) errors.push('Missing ID');\n    if (!item.type) errors.push('Missing type');\n    if (!item.label) errors.push('Missing label');\n\n    return {\n        isValid: errors.length === 0,\n        errors,\n    };\n};\n\nexport const validatePosition = (position: { x: number; y: number }): { isValid: boolean; errors: string[] } => {\n    const errors: string[] = [];\n\n    if (typeof position.x !== 'number') errors.push('Position X must be a number');\n    if (typeof position.y !== 'number') errors.push('Position Y must be a number');\n    if (isNaN(position.x)) errors.push('Position X is NaN');\n    if (isNaN(position.y)) errors.push('Position Y is NaN');\n\n    return {\n        isValid: errors.length === 0,\n        errors,\n    };\n};\n\n\n// Dimensions validation - MOVED TO @karmyc/shared\n/*\nexport const validateDimensions = (dimensions: { width: number; height: number }): { isValid: boolean; errors: string[] } => {\n    const errors: string[] = [];\n\n    if (dimensions.width <= 0) errors.push('Invalid width');\n    if (dimensions.height <= 0) errors.push('Invalid height');\n\n    return {\n        isValid: errors.length === 0,\n        errors,\n    };\n};\n*/\n\n\nexport const validateContextMenuItem = (item: ContextMenuItem): { isValid: boolean; errors: string[] } => {\n    const errors: string[] = [];\n\n    if (!item.id) errors.push('Missing ID');\n    if (!item.label) errors.push('Missing label');\n    if (!item.actionId) errors.push('Missing actionId');\n\n    return {\n        isValid: errors.length === 0,\n        errors,\n    };\n};\n","const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (_e) {\n  }\n  if (!extensionConnector) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && enabled) {\n      console.warn(\n        \"[zustand devtools middleware] Please install/enable Redux devtools extension\"\n      );\n    }\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState) return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0) f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (_e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst oldImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    getStorage: () => localStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage;\n  try {\n    storage = options.getStorage();\n  } catch (_e) {\n  }\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const thenableSerialize = toThenable(options.serialize);\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    let errorInSync;\n    const thenable = thenableSerialize({ state, version: options.version }).then(\n      (serializedValue) => storage.setItem(options.name, serializedValue)\n    ).catch((e) => {\n      errorInSync = e;\n    });\n    if (errorInSync) {\n      throw errorInSync;\n    }\n    return thenable;\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {\n      if (storageValue) {\n        return options.deserialize(storageValue);\n      }\n    }).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.getStorage) {\n        storage = newOptions.getStorage();\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nconst newImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return [\n              true,\n              options.migrate(\n                deserializedStorageValue.state,\n                deserializedStorageValue.version\n              )\n            ];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, void 0];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persistImpl = (config, baseOptions) => {\n  if (\"getStorage\" in baseOptions || \"serialize\" in baseOptions || \"deserialize\" in baseOptions) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.\"\n      );\n    }\n    return oldImpl(config, baseOptions);\n  }\n  return newImpl(config, baseOptions);\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n","import { THistoryDiff } from '../types/historyTypes';\n\nexport interface IStateDiff {\n    path: string[];\n    oldValue: unknown;\n    newValue: unknown;\n}\n\nexport function generateDiff(prevState: any, nextState: any): IStateDiff[] {\n    const diffs: IStateDiff[] = [];\n\n    function compareValues(path: string[], prev: unknown, next: unknown) {\n        if (prev === next) return;\n\n        if (typeof prev !== typeof next) {\n            diffs.push({ path, oldValue: prev, newValue: next });\n            return;\n        }\n\n        if (typeof prev === 'object' && prev !== null && next !== null) {\n            // Ensure prev and next are non-null objects before using Object.keys\n            const prevObj = prev as Record<string, unknown>;\n            const nextObj = next as Record<string, unknown>;\n\n            const prevKeys = Object.keys(prevObj);\n            const nextKeys = Object.keys(nextObj);\n\n            // Check removed keys\n            prevKeys.forEach(key => {\n                if (!nextKeys.includes(key)) {\n                    diffs.push({\n                        path: [...path, key],\n                        oldValue: prevObj[key],\n                        newValue: undefined,\n                    });\n                }\n            });\n\n            // Check added or modified keys\n            nextKeys.forEach(key => {\n                if (!prevKeys.includes(key)) {\n                    diffs.push({\n                        path: [...path, key],\n                        oldValue: undefined,\n                        newValue: nextObj[key],\n                    });\n                } else {\n                    compareValues(\n                        [...path, key],\n                        prevObj[key],\n                        nextObj[key]\n                    );\n                }\n            });\n        } else {\n            diffs.push({ path, oldValue: prev, newValue: next });\n        }\n    }\n\n    compareValues([], prevState, nextState);\n    return diffs;\n}\n\nexport function getValueAtPath(state: any, path: string[]): unknown {\n    return path.reduce((obj, key) => (obj as Record<string, unknown>)[key], state);\n}\n\n// Apply a diff to a state (simplified version)\nexport function applyDiff<T>(state: T, diff: THistoryDiff): T {\n    let newState = { ...state } as any;\n    diff.changes.forEach(change => {\n        let obj = newState;\n        for (let i = 0; i < change.path.length - 1; i++) {\n            obj = obj[change.path[i]];\n        }\n        obj[change.path[change.path.length - 1]] = change.oldValue;\n    });\n    return newState;\n}\n\n// Reverse a diff (simplified version)\nexport function invertDiff(diff: THistoryDiff): THistoryDiff {\n    return {\n        ...diff,\n        changes: diff.changes.map(change => ({\n            ...change,\n            oldValue: change.newValue,\n            newValue: change.oldValue,\n        })),\n    };\n} \n","import { create } from 'zustand';\nimport { devtools, persist } from 'zustand/middleware';\nimport { immer } from 'zustand/middleware/immer';\nimport { generateDiff, applyDiff, invertDiff } from '../utils/history';\nimport { THistoryDiff } from '../types/historyTypes';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface SpaceSharedState extends Record<string, any> {\n    color: string;\n    pastDiffs: THistoryDiff[];\n    futureDiffs: THistoryDiff[];\n}\n\nexport interface Space {\n    id: string;\n    name: string;\n    /**\n     * Optional description for the space (user-defined, can be empty).\n     */\n    description?: string;\n    sharedState: SpaceSharedState;\n}\n\nexport interface SpaceState {\n    spaces: Record<string, Space>;\n    activeSpaceId: string | null;\n    openSpaceIds: string[]; // Liste des IDs des espaces ouverts\n    errors: string[];\n    pilotMode: 'MANUAL' | 'AUTO'; // Nouveau champ pour le mode de pilotage\n\n    // Actions\n    addSpace: (spaceData: { name: string; description?: string; sharedState?: Partial<Omit<SpaceSharedState, 'pastDiffs' | 'futureDiffs'>> }) => string | undefined;\n    removeSpace: (id: string) => void;\n    setActiveSpace: (id: string | null) => void;\n    setPilotMode: (mode: 'MANUAL' | 'AUTO') => void; // Nouvelle action\n    openSpace: (id: string) => void; // Nouvelle action pour ouvrir un space\n    closeSpace: (id: string) => void; // Nouvelle action pour fermer un space\n    updateSpace: (spaceData: Partial<Space> & { id: string }) => void;\n    updateSpaceGenericSharedState: (payload: { spaceId: string; changes: Partial<Omit<SpaceSharedState, 'pastDiffs' | 'futureDiffs'>> }) => void;\n    clearErrors: () => void;\n    // New history actions for spaces\n    undoSharedState: (spaceId: string) => void;\n    redoSharedState: (spaceId: string) => void;\n\n    // Selectors\n    getSpaceById: (id: string) => Space | undefined;\n    getAllSpaces: () => Record<string, Space>;\n    getActiveSpace: () => Space | null;\n    getActiveSpaceId: () => string | null;\n    getOpenSpaces: () => Space[]; // Nouveau sélecteur pour obtenir la liste des espaces ouverts\n    getSpaceErrors: () => string[];\n    getPilotMode: () => 'MANUAL' | 'AUTO'; // Nouveau sélecteur\n}\n\n// Helper function for validation (optional, implement if needed)\n// function validateSpace(space: Partial<Space>): { isValid: boolean; errors: string[] } {\n//     const errors: string[] = [];\n//     if (!space.name) errors.push(\"Space name is required.\");\n//     // Add more validation rules as needed\n//     return { isValid: errors.length === 0, errors };\n// }\n\n// Define the core state logic with immer first\nconst immerConfig = immer<SpaceState>((set, get) => {\n    return {\n        spaces: {},\n        activeSpaceId: null,\n        openSpaceIds: [], // Initialiser la liste des espaces ouverts\n        errors: [],\n        pilotMode: 'AUTO', // Mode par défaut\n\n        // Actions with logs\n        addSpace: (spaceData) => {\n            if (!spaceData.name) {\n                set(state => {\n                    state.errors = [\"Space name cannot be empty.\"];\n                });\n                console.error(\"Validation failed for space:\", get().errors);\n                return undefined;\n            }\n            const newId = uuidv4();\n            const newSpace: Space = {\n                id: newId,\n                name: spaceData.name,\n                description: spaceData.description ?? '',\n                sharedState: {\n                    color: spaceData.sharedState?.color ?? '#ff0000',\n                    pastDiffs: [],\n                    futureDiffs: [],\n                    ...(spaceData.sharedState || {}),\n                },\n            };\n            set(state => {\n                state.spaces[newId] = newSpace;\n                state.openSpaceIds.push(newId); // Ajouter le nouvel espace à la liste des espaces ouverts\n                state.errors = [];\n            });\n            return newId;\n        },\n        removeSpace: (id) => {\n            set(state => {\n                delete state.spaces[id];\n                if (state.activeSpaceId === id) {\n                    state.activeSpaceId = null;\n                }\n                // Retirer l'espace de la liste des espaces ouverts\n                state.openSpaceIds = state.openSpaceIds.filter(spaceId => spaceId !== id);\n                state.errors = [];\n            });\n        },\n        setActiveSpace: (id) => {\n            set(state => {\n                if (id === null || state.spaces[id]) {\n                    state.activeSpaceId = id;\n                } else {\n                    console.warn(`Attempted to set active space to non-existent ID: ${id}`);\n                }\n                state.errors = [];\n            });\n        },\n        setPilotMode: (mode) => {\n            set(state => {\n                state.pilotMode = mode;\n            });\n        },\n        openSpace: (id) => {\n            set(state => {\n                if (state.spaces[id] && !state.openSpaceIds.includes(id)) {\n                    state.openSpaceIds.push(id);\n                }\n            });\n        },\n        closeSpace: (id) => {\n            set(state => {\n                state.openSpaceIds = state.openSpaceIds.filter(spaceId => spaceId !== id);\n                if (state.activeSpaceId === id) {\n                    // Si on ferme l'espace actif, on active le dernier espace ouvert\n                    state.activeSpaceId = state.openSpaceIds[state.openSpaceIds.length - 1] || null;\n                }\n            });\n        },\n        updateSpace: (spaceData) => {\n            set(state => {\n                const space = state.spaces[spaceData.id];\n                if (space) {\n                    if (spaceData.name === '') {\n                        state.errors = [\"Space name cannot be empty.\"];\n                        console.error(\"Validation failed for space update:\", state.errors);\n                        return;\n                    }\n                    const { id, ...changes } = spaceData;\n                    state.spaces[id] = { ...space, ...changes };\n                    state.errors = [];\n                } else {\n                    state.errors = [`Space with ID ${spaceData.id} not found for update.`];\n                    console.error(\"Update failed:\", state.errors);\n                }\n            });\n        },\n        updateSpaceGenericSharedState: (payload) => {\n            const { spaceId, changes } = payload;\n            const space = get().spaces[spaceId];\n\n            if (!space) {\n                set(state => {\n                    state.errors = [`Space with ID ${payload.spaceId} not found for shared state update.`];\n                });\n                console.error(\"Shared state update failed: Space not found\");\n                return;\n            }\n\n            const prevState = space.sharedState;\n            const actionType = changes.actionType || 'UPDATE_SHARED_STATE';\n            const actionPayload = changes.payload || {};\n\n            set(state => {\n                const currentSpace = state.spaces[spaceId];\n                if (currentSpace) {\n                    // Supprimer actionType et payload des changements avant de les appliquer\n                    const { actionType, payload, ...actualChanges } = changes;\n                    currentSpace.sharedState = { ...currentSpace.sharedState, ...actualChanges };\n                    state.errors = [];\n                }\n            });\n            const nextState = get().spaces[spaceId]?.sharedState;\n\n            if (!nextState) {\n                console.error(\"Shared state update failed: Space disappeared after update?\");\n                return;\n            }\n            const diff = generateDiff(prevState, nextState);\n            if (Array.isArray(diff) && diff.length > 0) {\n                set(state => {\n                    const currentSpace = state.spaces[spaceId];\n                    if (currentSpace) {\n                        if (!currentSpace.sharedState.pastDiffs) currentSpace.sharedState.pastDiffs = [];\n                        currentSpace.sharedState.pastDiffs.push({\n                            timestamp: Date.now(),\n                            actionType,\n                            // @ts-expect-error - payload is used in the next line\n                            payload: actionPayload,\n                            changes: diff,\n                        });\n                        currentSpace.sharedState.futureDiffs = [];\n                    }\n                });\n            }\n        },\n        clearErrors: () => {\n            set(state => {\n                state.errors = [];\n            });\n        },\n        undoSharedState: (spaceId: string) => {\n            set(state => {\n                const space = state.spaces[spaceId];\n                if (!space?.sharedState?.pastDiffs?.length) {\n                    return;\n                }\n                const diffToUndo = space.sharedState.pastDiffs.pop()!;\n\n                // *** Apply the ORIGINAL diff directly to restore oldValue ***\n                const stateBeforeUndo = space.sharedState;\n                const stateAfterUndo = applyDiff(stateBeforeUndo, diffToUndo);\n\n                space.sharedState = stateAfterUndo as SpaceSharedState; // Cast result\n                if (!space.sharedState.futureDiffs) space.sharedState.futureDiffs = [];\n                space.sharedState.futureDiffs.push(diffToUndo);\n            });\n        },\n        redoSharedState: (spaceId: string) => {\n            set(state => {\n                const space = state.spaces[spaceId];\n                if (!space?.sharedState?.futureDiffs?.length) {\n                    return;\n                }\n                const diffToRedo = space.sharedState.futureDiffs.pop()!;\n\n                // *** Invert the diff to get the future state into oldValue for applyDiff ***\n                const invertedDiffToRedo = invertDiff(diffToRedo);\n\n                const stateBeforeRedo = space.sharedState;\n                const stateAfterRedo = applyDiff(stateBeforeRedo, invertedDiffToRedo);\n\n                space.sharedState = stateAfterRedo as SpaceSharedState; // Cast result\n                if (!space.sharedState.pastDiffs) space.sharedState.pastDiffs = [];\n                space.sharedState.pastDiffs.push(diffToRedo);\n            });\n        },\n        getSpaceById: (id) => get().spaces[id],\n        getAllSpaces: () => get().spaces,\n        getActiveSpace: () => {\n            const state = get();\n            return state.activeSpaceId ? state.spaces[state.activeSpaceId] : null;\n        },\n        getActiveSpaceId: () => get().activeSpaceId,\n        getOpenSpaces: () => {\n            const state = get();\n            return state.openSpaceIds\n                .map(id => state.spaces[id])\n                .filter((space): space is Space => space !== undefined);\n        },\n        getSpaceErrors: () => get().errors,\n        getPilotMode: () => get().pilotMode,\n    };\n});\n\n// Wrap with persist\nconst persistConfig = persist(immerConfig, {\n    name: 'space-storage',\n    partialize: (state: SpaceState) => {\n        const spacesToPersist: Record<string, Partial<Omit<Space, 'sharedState'>> & { sharedState: Partial<Omit<SpaceSharedState, 'pastDiffs' | 'futureDiffs'>> }> = {};\n        for (const spaceId in state.spaces) {\n            const { sharedState, ...restOfSpace } = state.spaces[spaceId];\n            const { pastDiffs, futureDiffs, ...restOfSharedState } = sharedState ?? {};\n            spacesToPersist[spaceId] = {\n                ...restOfSpace,\n                sharedState: restOfSharedState\n            };\n        }\n        const { activeSpaceId } = state;\n        const result = { spaces: spacesToPersist, activeSpaceId };\n        return result;\n    },\n    merge: (persistedState: unknown, currentState: SpaceState): SpaceState => {\n        const loadedState = persistedState as Partial<SpaceState>; // Cast persisted state\n        // Validate loaded spaces and merge with defaults\n        const validatedSpaces: Record<string, Space> = {};\n        const spacesFromStorage = loadedState?.spaces ?? {};\n\n        // Use current state spaces as a base\n        const baseSpaces = currentState.spaces;\n\n        // Combine keys from storage and initial state\n        const allSpaceIds = new Set([...Object.keys(spacesFromStorage), ...Object.keys(baseSpaces)]);\n\n        for (const spaceId of allSpaceIds) {\n            const spaceFromStorage = spacesFromStorage[spaceId];\n            const spaceFromCode = baseSpaces[spaceId];\n\n            if (!spaceFromStorage && !spaceFromCode) continue;\n\n            const baseShared = spaceFromCode?.sharedState ?? {};\n            const loadedShared = spaceFromStorage?.sharedState ?? {};\n\n            validatedSpaces[spaceId] = {\n                id: spaceFromStorage?.id ?? spaceFromCode?.id ?? spaceId,\n                name: spaceFromStorage?.name ?? spaceFromCode?.name ?? `Space ${spaceId}`,\n                description: spaceFromStorage?.description ?? spaceFromCode?.description ?? '',\n                sharedState: {\n                    ...baseShared,\n                    ...loadedShared,\n                    pastDiffs: [],\n                    futureDiffs: [],\n                },\n            };\n            if (!validatedSpaces[spaceId].sharedState.color) validatedSpaces[spaceId].sharedState.color = '#000000';\n        }\n\n        // Return the fully merged state, prioritizing loaded simple values\n        const finalState = {\n            ...currentState, // Start with current state (functions, initial structure)\n            activeSpaceId: loadedState?.activeSpaceId ?? currentState.activeSpaceId,\n            spaces: validatedSpaces, // Use the carefully merged spaces\n            errors: [], // Always reset errors on load\n        };\n        return finalState;\n    }\n});\n\n// Finally, wrap with devtools and create the store\nexport const useSpaceStore = create<SpaceState>()(\n    devtools(persistConfig, { name: 'SpaceStore' })\n);\n\n// Example of how to use selectors outside components (e.g., in utility functions)\n// export const selectAllSpacesFromStore = () => useSpaceStore.getState().getAllSpaces();\n// export const selectActiveSpaceFromStore = () => useSpaceStore.getState().getActiveSpace(); \n","type ToolsEventType = 'cleanup' | 'register' | 'unregister';\r\n\r\ninterface ToolsEvent {\r\n    type: ToolsEventType;\r\n    areaId: string;\r\n}\r\n\r\ntype ToolsEventListener = (event: ToolsEvent) => void;\r\n\r\nclass ToolsEventBus {\r\n    private listeners: Set<ToolsEventListener> = new Set();\r\n\r\n    subscribe(listener: ToolsEventListener) {\r\n        this.listeners.add(listener);\r\n        return () => {\r\n            this.listeners.delete(listener);\r\n        };\r\n    }\r\n\r\n    publish(event: ToolsEvent) {\r\n        this.listeners.forEach(listener => listener(event));\r\n    }\r\n}\r\n\r\nexport const toolsEventBus = new ToolsEventBus(); \r\n","import type { WritableDraft } from 'immer';\nimport { create, StateCreator } from 'zustand';\nimport { immer } from 'zustand/middleware/immer';\nimport { Vec2 } from '../utils';\nimport { IArea, AreaLayout, AreaRowLayout } from '../types/areaTypes';\nimport { CardinalDirection, IntercardinalDirection } from '../types/directions';\nimport { Point, Rect } from '../types/math';\nimport { AreaTypeValue, AREA_ROLE } from '../types/actions';\nimport { computeAreaToParentRow } from '../utils/areaToParentRow';\nimport { computeAreaToViewport } from '../utils/areaToViewport';\nimport { getAreaToOpenPlacementInViewport, getHoveredAreaId, PlaceArea } from '../utils/areaUtils';\nimport { getAreaRootViewport } from '../utils/getAreaViewport';\nimport { joinAreas as joinAreasUtil } from '../utils/joinArea';\nimport { validateArea } from '../utils/validation';\nimport { devtools, persist } from 'zustand/middleware';\nimport { areaRegistry } from './registries/areaRegistry';\nimport { IKarmycOptions, LayoutPreset } from '../types/karmyc';\nimport { v4 as uuidv4 } from 'uuid';\nimport { createJSONStorage } from 'zustand/middleware';\nimport { useSpaceStore } from './spaceStore';\nimport { toolsEventBus } from '../utils/toolsEventBus';\n\n// --- Define Join Preview State Type (kept for AreaSliceStateData) ---\nexport interface JoinPreviewState {\n    areaId: string | null;\n    movingInDirection: CardinalDirection | null;\n    eligibleAreaIds: string[];\n}\n\n// --- Define Split Result Type (kept for AreaSliceStateData) ---\ninterface SplitResult {\n    newRowId: string;\n    separatorIndex: number;\n}\n\n// --- Define the state structure for the Areas SLICE (Data only for now) ---\n// This will hold the data previously managed by AreaState, per screen\nexport interface AreaSliceStateData {\n    _id: number; // Unique ID counter *within* this slice for this screen\n    rootId: string | null;\n    errors: string[];\n    activeAreaId: string | null; // Area focused *within* this screen\n    joinPreview: JoinPreviewState | null;\n    layout: {\n        [key: string]: AreaRowLayout | AreaLayout;\n    };\n    areas: {\n        [key: string]: IArea<AreaTypeValue>;\n    };\n    viewports: { // Viewports are likely screen-specific\n        [key: string]: Rect;\n    };\n    areaToOpen: null | {\n        position: Point;\n        area: {\n            type: string;\n            state: any & { sourceId?: string };\n        };\n    };\n    lastSplitResultData: SplitResult | null;\n    lastLeadAreaId?: string | null;\n    isDetached?: boolean; // Flag to disable manipulations in detached windows\n    isLocked?: boolean; // Flag for locking manipulations\n}\n\n// --- Define the FULL state structure for the Areas SLICE ---\n// Includes data and actions/selectors signatures\nexport interface AreaSliceState extends AreaSliceStateData {\n    // Actions (signatures only, implementation in createAreaSlice)\n    addArea: (area: IArea<AreaTypeValue>) => string;\n    removeArea: (id: string) => void;\n    setActiveArea: (id: string | null) => void;\n    updateArea: (areaData: Partial<IArea<AreaTypeValue>> & { id: string }) => void;\n    updateLayout: (layoutData: Partial<AreaRowLayout> & { id: string }) => void;\n    setAreaToOpen: (payload: AreaSliceStateData['areaToOpen']) => void;\n    updateAreaToOpenPosition: (position: Point) => void;\n    finalizeAreaPlacement: (payload?: { targetId?: string; placement?: PlaceArea }) => void;\n    cleanupTemporaryStates: () => void;\n    setViewports: (viewports: Record<string, Rect>) => void;\n    setRowSizes: (payload: { rowId: string; sizes: number[] }) => void;\n    splitArea: (payload: {\n        areaIdToSplit: string;\n        parentRowId: string | null;\n        horizontal: boolean;\n        corner: IntercardinalDirection;\n    }) => SplitResult | null;\n    setJoinPreview: (payload: JoinPreviewState | null) => void;\n    joinOrMoveArea: (payload: {\n        sourceAreaId: string;\n        targetAreaId: string;\n        direction: CardinalDirection;\n    }) => void;\n    getLastSplitResult: () => SplitResult | null;\n\n    // Selectors (signatures only, implementation in createAreaSlice)\n    getActiveArea: () => IArea<AreaTypeValue> | null;\n    getAreaById: (id: string) => IArea<AreaTypeValue> | undefined;\n    getAllAreas: () => Record<string, IArea<AreaTypeValue>>;\n    getAreaErrors: () => string[];\n    getLastLeadAreaId: () => string | null;\n}\n\n// --- Initial state for AreaSlice (Data + Dummy Actions/Selectors) ---\n// Used for createInitialScreenState - actions/selectors replaced by createAreaSlice\nexport const initialAreaSliceState: AreaSliceState = {\n    // Data part\n    _id: 0,\n    rootId: null,\n    updateLayout: () => { },\n    errors: [],\n    activeAreaId: null,\n    joinPreview: null,\n    layout: {},\n    areas: {},\n    viewports: {},\n    areaToOpen: null,\n    lastSplitResultData: null,\n    lastLeadAreaId: null,\n    // Dummy implementations for type completeness (will be replaced by real slice)\n    addArea: () => '',\n    removeArea: () => { },\n    setActiveArea: () => { },\n    updateArea: () => { },\n    setAreaToOpen: () => { },\n    updateAreaToOpenPosition: () => { },\n    finalizeAreaPlacement: () => { },\n    cleanupTemporaryStates: () => { },\n    setViewports: () => { },\n    setRowSizes: () => { },\n    splitArea: () => null,\n    setJoinPreview: () => { },\n    joinOrMoveArea: () => { },\n    getLastSplitResult: () => null,\n    getActiveArea: () => null,\n    getAreaById: () => undefined,\n    getAllAreas: () => ({}),\n    getAreaErrors: () => [],\n    getLastLeadAreaId: () => null,\n};\n\n// --- Define the state of a single Screen ---\ninterface ScreenState {\n    // Use the full AreaSliceState (containing data part)\n    areas: AreaSliceStateData;\n    isDetached?: boolean;\n    detachedFromAreaId?: string;\n    isLocked?: boolean;\n    // settings: SettingsSliceStateData; // Placeholder\n    // history: HistorySliceStateData; // Placeholder\n}\n\n// --- Helper function to generate the initial state for a new screen ---\nexport const createInitialScreenState = (): ScreenState => {\n    // Deep copy only the DATA part for initialization\n    return JSON.parse(JSON.stringify({\n        areas: initialAreaSliceState, // Use the data part of the initial state\n        // settings: initialSettingsStateData,\n        // history: initialHistoryStateData,\n    }));\n};\n\n// Export the RootState type\nexport type RootState = {\n    screens: Record<string, ScreenState>;\n    activeScreenId: string;\n    nextScreenId: number;\n    windowId?: string;\n    options: IKarmycOptions;\n    lastUpdated: number; // Added for version management\n    layout_preset: LayoutPreset[];\n\n    // --- Screen Management Actions ---\n    addScreen: () => void;\n    switchScreen: (screenId: string) => void;\n    removeScreen: (screenId: string) => void;\n    duplicateScreen: (screenId: string) => void;\n    detachArea: (areaId: string) => void;\n\n    // --- Expose Area Slice Actions/Selectors directly ---\n    addArea: (area: IArea<AreaTypeValue>) => string;\n    removeArea: (id: string) => void;\n    setActiveArea: (id: string | null) => void;\n    updateArea: (areaData: Partial<IArea<AreaTypeValue>> & { id: string }) => void;\n    updateLayout: (layoutData: Partial<AreaRowLayout> & { id: string }) => void;\n    setAreaToOpen: (payload: AreaSliceStateData['areaToOpen']) => void;\n    updateAreaToOpenPosition: (position: Point) => void;\n    finalizeAreaPlacement: (payload?: { targetId?: string; placement?: PlaceArea }) => void;\n    cleanupTemporaryStates: () => void;\n    setViewports: (viewports: Record<string, Rect>) => void;\n    setRowSizes: (payload: { rowId: string; sizes: number[] }) => void;\n    splitArea: (payload: {\n        areaIdToSplit: string;\n        parentRowId: string | null;\n        horizontal: boolean;\n        corner: IntercardinalDirection;\n    }) => SplitResult | null;\n    setJoinPreview: (payload: JoinPreviewState | null) => void;\n    joinOrMoveArea: (payload: {\n        sourceAreaId: string;\n        targetAreaId: string;\n        direction: CardinalDirection;\n    }) => void;\n    getLastSplitResult: () => SplitResult | null;\n    getActiveArea: () => IArea<AreaTypeValue> | null;\n    getAreaById: (id: string) => IArea<AreaTypeValue> | undefined;\n    getAllAreas: () => Record<string, IArea<AreaTypeValue>>;\n    getAreaErrors: () => string[];\n    findParentRowAndIndices: (layout: AreaSliceStateData['layout'], sourceAreaId: string, targetAreaId: string) => { parentRow: AreaRowLayout | null; sourceIndex: number; targetIndex: number };\n};\n\n// --- ADD BACK HELPER FUNCTIONS (adapted for Immer drafts if needed) ---\n// Note: These operate on ScreenState['areas'] data structures\n\nexport function findParentRowAndIndices(layout: AreaSliceStateData['layout'], sourceAreaId: string, targetAreaId: string): { parentRow: AreaRowLayout | null; sourceIndex: number; targetIndex: number } {\n    for (const layoutId in layout) {\n        const item = layout[layoutId];\n        if (item.type === 'area_row') {\n            const row = item as AreaRowLayout;\n            const sourceIndex = row.areas.findIndex(a => a.id === sourceAreaId);\n            const targetIndex = row.areas.findIndex(a => a.id === targetAreaId);\n            if (sourceIndex !== -1 && targetIndex !== -1 && Math.abs(sourceIndex - targetIndex) === 1) {\n                return { parentRow: row, sourceIndex, targetIndex };\n            }\n        }\n    }\n    return { parentRow: null, sourceIndex: -1, targetIndex: -1 };\n}\n\nfunction findAllDescendantAreaIds(layout: AreaSliceStateData['layout'], itemId: string): Set<string> {\n    const descendantIds = new Set<string>();\n    const queue: string[] = [itemId];\n    const visited = new Set<string>();\n    while (queue.length > 0) {\n        const currentId = queue.shift()!;\n        if (visited.has(currentId)) continue;\n        visited.add(currentId);\n        const item = layout[currentId];\n        if (!item) continue;\n        if (item.type === 'area') {\n            // It might be a layout item *referencing* an area, or the area data itself.\n            // If layout stores area details: descendantIds.add(currentId);\n            // If layout only stores refs: Need 'areas' map too.\n            // Assuming layout keys *can* be area IDs directly for simplicity here.\n            descendantIds.add(currentId);\n        } else if (item.type === 'area_row') {\n            const row = item as AreaRowLayout;\n            if (row.areas && Array.isArray(row.areas)) {\n                row.areas.forEach(areaRef => {\n                    if (areaRef && areaRef.id) { // areaRef.id is the key to potentially another layout item or an area\n                        queue.push(areaRef.id);\n                        // Check if areaRef.id corresponds to an actual area or just a layout node\n                        // For now, assume all referenced IDs could eventually lead to areas.\n                    }\n                });\n            }\n        }\n    }\n    // Add the initial item ID itself if it's potentially an area ID\n    if (layout[itemId]?.type === 'area') {\n        descendantIds.add(itemId);\n    }\n    // This function needs careful review based on exact layout structure (refs vs inline)\n    return descendantIds;\n}\n\n\n/* function findAllDisconnectedAreas(layout: AreaSliceStateData['layout'], rootId: string | null): Set<string> {\n    const allLayoutIds = new Set<string>(Object.keys(layout));\n    const connectedLayoutIds = new Set<string>();\n\n    if (rootId && layout[rootId]) {\n        const queue: string[] = [rootId];\n        const visited = new Set<string>();\n\n        while (queue.length > 0) {\n            const currentId = queue.shift()!;\n            if (visited.has(currentId) || !layout[currentId]) continue;\n            visited.add(currentId);\n            connectedLayoutIds.add(currentId); // Add the layout ID itself\n\n            const item = layout[currentId];\n            if (item.type === 'area_row') {\n                const row = item as AreaRowLayout;\n                row.areas?.forEach(ref => {\n                    if (ref?.id && !visited.has(ref.id)) {\n                        queue.push(ref.id);\n                    }\n                });\n            }\n        }\n    }\n\n    const disconnectedLayoutIds = new Set<string>();\n    allLayoutIds.forEach(id => {\n        if (!connectedLayoutIds.has(id)) {\n            disconnectedLayoutIds.add(id);\n        }\n    });\n\n    // Return only IDs that correspond to actual areas (needs areas map access?)\n    // For now, returning all disconnected layout IDs. Refinement needed.\n    return disconnectedLayoutIds;\n} */\n\n\nfunction simplifyLayoutNodeIfNeeded(state: WritableDraft<AreaSliceStateData>, rowId: string | null | undefined) {\n    if (!rowId) return;\n    const layoutNode = state.layout[rowId];\n    if (!layoutNode || layoutNode.type !== 'area_row') return;\n\n    const rowLayout = layoutNode as AreaRowLayout;\n    if (rowLayout.areas.length !== 1) return;\n\n    const survivingChildRef = rowLayout.areas[0];\n    const survivingChildId = survivingChildRef.id;\n    const areaToParentRowMap = computeAreaToParentRow(state.layout); // Compute within helper\n    const grandParentRowId = areaToParentRowMap[rowId];\n\n    // On permet la simplification même pour les stacks quand il ne reste qu'un élément\n    // if (rowLayout.orientation === 'stack') {\n    //     return;\n    // }\n\n    if (grandParentRowId && state.layout[grandParentRowId]?.type === 'area_row') {\n        const grandParentRow = state.layout[grandParentRowId] as AreaRowLayout;\n        const rowIndexInGrandparent = grandParentRow.areas.findIndex(a => a.id === rowId);\n        if (rowIndexInGrandparent !== -1) {\n            const sizeToPreserve = grandParentRow.areas[rowIndexInGrandparent].size ?? survivingChildRef.size ?? 0.5;\n            grandParentRow.areas[rowIndexInGrandparent] = { id: survivingChildId, size: sizeToPreserve };\n        } else {\n            console.error(`[simplifyLayoutNodeIfNeeded] Cleanup Error: Row ${rowId} not found in parent ${grandParentRowId}.`);\n            return; // Stop simplification if parent relationship is broken\n        }\n    } else if (state.rootId === rowId) {\n        state.rootId = survivingChildId;\n    } else {\n        // Orphaned row with single child - this indicates a potential issue elsewhere\n        console.warn(`[simplifyLayoutNodeIfNeeded] Row ${rowId} has single child ${survivingChildId} but no parent and is not root. Removing row.`);\n        // Proceed to delete the row, but the child is now potentially disconnected\n        // This case might need more robust handling depending on desired behavior\n    }\n\n    // Delete the layout entry for the now-simplified (empty or handled) row\n    delete state.layout[rowId];\n}\n\n// Fonction utilitaire pour trouver la première area enfant d'un row (descente récursive)\nfunction findFirstAreaId(layout: any, id: string): string | null {\n    const item = layout[id];\n    if (!item) return null;\n    if (item.type === 'area') return id;\n    if (item.type === 'area_row') {\n        if (item.areas.length === 0) return null;\n        return findFirstAreaId(layout, item.areas[0].id);\n    }\n    return null;\n}\n\n// --- Define the Area Slice logic using StateCreator pattern ---\nconst createAreaSlice: StateCreator<\n    RootState,\n    [[\"zustand/immer\", never]], // Define middleware used at the root\n    [],\n    AreaSliceState // The state slice this creator manages\n> = (set, get) => {\n    // Return the slice state and actions\n    return {\n        // --- Initial Data State (already defined in initialAreaSliceState) ---\n        ...initialAreaSliceState,\n\n        // --- ACTIONS (adapted to operate on active screen) ---\n        addArea: (area) => {\n            let generatedAreaId = '';\n            set((state: WritableDraft<RootState>) => {\n                console.log('state', state);\n                const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n                console.log('activeScreenAreas', activeScreenAreas);\n                if (!activeScreenAreas) return;\n                const areaId = area.id || uuidv4();\n                let role = undefined;\n                if (area.type) {\n                    const _roleMap = (areaRegistry as any)._roleMap || {};\n                    role = _roleMap[area.type];\n                }\n                const areaWithId = {\n                    ...area,\n                    id: areaId,\n                    role,\n                };\n\n                // Si c'est une area LEAD sans espace, on lui en assigne un\n                if (role === AREA_ROLE.LEAD && !areaWithId.spaceId) {\n                    const spaces = useSpaceStore.getState().spaces;\n                    const existingSpaces = Object.keys(spaces);\n                    if (existingSpaces.length > 0) {\n                        // Utiliser le dernier espace actif ou le premier disponible\n                        const activeSpaceId = useSpaceStore.getState().activeSpaceId;\n                        areaWithId.spaceId = activeSpaceId || existingSpaces[0];\n                    } else {\n                        // Créer un nouvel espace seulement s'il n'y en a aucun\n                        const newSpaceId = useSpaceStore.getState().addSpace({\n                            name: `Space for ${area.type}`,\n                            sharedState: {}\n                        });\n                        if (newSpaceId) {\n                            areaWithId.spaceId = newSpaceId;\n                        }\n                    }\n                }\n                console.log('areaWithId', areaWithId);\n                const validation = validateArea(areaWithId);\n                if (!validation.isValid) {\n                    activeScreenAreas.errors = validation.errors;\n                    console.error(\"Validation failed for area:\", validation.errors);\n                } else {\n                    activeScreenAreas.areas[areaId] = areaWithId;\n                    activeScreenAreas._id += 1;\n                    activeScreenAreas.errors = [];\n                    generatedAreaId = areaId;\n                    state.lastUpdated = Date.now();\n                }\n            });\n\n            console.log('generatedAreaId', generatedAreaId);\n            return generatedAreaId;\n        },\n\n        removeArea: (id) => set((state: WritableDraft<RootState>) => {\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            if (!activeScreenAreas) return;\n\n            // Vérifier si c'est la dernière area du screen\n            const areaCount = Object.keys(activeScreenAreas.areas).length;\n            if (areaCount <= 1) {\n                console.warn('Cannot remove the last area of a screen');\n                return;\n            }\n\n            // Supprimer l'area des données\n            delete activeScreenAreas.areas[id];\n\n            // Supprimer l'area du layout\n            delete activeScreenAreas.layout[id];\n\n            // Nettoyer les références à cette area dans les rows\n            for (const layoutId in activeScreenAreas.layout) {\n                const item = activeScreenAreas.layout[layoutId];\n                if (item.type === 'area_row') {\n                    const row = item as AreaRowLayout;\n                    const areaIndex = row.areas.findIndex(a => a.id === id);\n                    if (areaIndex !== -1) {\n                        row.areas.splice(areaIndex, 1);\n                        // --- Correction spécifique pour les stacks ---\n                        if (row.orientation === 'stack') {\n                            // Si l'area supprimée était l'activeTabId, choisir un nouvel onglet actif\n                            if (row.activeTabId === id) {\n                                row.activeTabId = row.areas[0]?.id || undefined;\n                            }\n                            // Si le stack est vide, le supprimer\n                            if (row.areas.length === 0) {\n                                delete activeScreenAreas.layout[layoutId];\n                            }\n                            // Si le stack n'a plus qu'une seule area, le \"déstacker\"\n                            else if (row.areas.length === 1) {\n                                const parentRowId = Object.keys(activeScreenAreas.layout).find(parentId => {\n                                    const parent = activeScreenAreas.layout[parentId];\n                                    return parent.type === 'area_row' && (parent as AreaRowLayout).areas.some(a => a.id === layoutId);\n                                });\n                                if (parentRowId) {\n                                    const parent = activeScreenAreas.layout[parentRowId] as AreaRowLayout;\n                                    const idx = parent.areas.findIndex(a => a.id === layoutId);\n                                    if (idx !== -1) {\n                                        // Remplacer le stack par l'unique area restante\n                                        parent.areas[idx] = { ...row.areas[0] };\n                                    }\n                                    delete activeScreenAreas.layout[layoutId];\n                                } else if (activeScreenAreas.rootId === layoutId) {\n                                    // Si le stack est root, remplacer rootId par l'unique area\n                                    activeScreenAreas.rootId = row.areas[0].id;\n                                    delete activeScreenAreas.layout[layoutId];\n                                }\n                            }\n                        }\n                        // Si le row est vide (non stack), le supprimer\n                        else if (row.areas.length === 0) {\n                            delete activeScreenAreas.layout[layoutId];\n                        }\n                    }\n                }\n            }\n\n            // Mettre à jour rootId si nécessaire\n            if (activeScreenAreas.rootId === id) {\n                activeScreenAreas.rootId = null;\n            }\n            if (activeScreenAreas.activeAreaId === id) {\n                activeScreenAreas.activeAreaId = null;\n            }\n            activeScreenAreas.errors = [];\n            state.lastUpdated = Date.now();\n            toolsEventBus.publish({ type: 'cleanup', areaId: id });\n        }),\n\n        setActiveArea: (id) => set((state: WritableDraft<RootState>) => {\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            if (!activeScreenAreas) return;\n            if (id === null || activeScreenAreas.areas[id]) {\n                if (activeScreenAreas.activeAreaId !== id) {\n                    activeScreenAreas.activeAreaId = id;\n                    if (id && activeScreenAreas.areas[id]?.role === AREA_ROLE.LEAD) {\n                        activeScreenAreas.lastLeadAreaId = id;\n                    }\n                    activeScreenAreas.errors = [];\n                    state.lastUpdated = Date.now();\n                }\n            }\n        }),\n\n        updateArea: (areaData) => set((state: WritableDraft<RootState>) => {\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            if (!activeScreenAreas) return;\n            const area = activeScreenAreas.areas[areaData.id];\n            if (area) {\n                const newRole = areaData.role;\n                if (newRole && newRole !== area.role) {\n                    // On nettoie d'abord les outils pour cette zone\n                    toolsEventBus.publish({ type: 'cleanup', areaId: area.id });\n                }\n                \n                // On applique les autres mises à jour\n                Object.assign(area, areaData, { role: newRole });\n            }\n        }),\n\n        updateLayout: (layoutData) => set((state: WritableDraft<RootState>) => {\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            if (!activeScreenAreas) return;\n            const layout = activeScreenAreas.layout[layoutData.id];\n            if (layout && layout.type === 'area_row') {\n                const before = JSON.stringify(layout);\n                // Update only the provided properties\n                if (layoutData.activeTabId !== undefined) {\n                    layout.activeTabId = layoutData.activeTabId;\n                }\n                if (layoutData.areas !== undefined) {\n                    layout.areas = layoutData.areas;\n                }\n                const after = JSON.stringify(layout);\n                if (before !== after) {\n                    activeScreenAreas.errors = [];\n                    state.lastUpdated = Date.now();\n                }\n            } else {\n                activeScreenAreas.errors = [`Layout with ID ${layoutData.id} not found or not a row.`];\n            }\n        }),\n\n        setAreaToOpen: (payload) => set((state: WritableDraft<RootState>) => {\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            if (activeScreenAreas && activeScreenAreas.areaToOpen !== payload) {\n                activeScreenAreas.areaToOpen = payload;\n                state.lastUpdated = Date.now();\n            }\n        }),\n\n        updateAreaToOpenPosition: (position) => set((state: WritableDraft<RootState>) => {\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            if (activeScreenAreas?.areaToOpen && (activeScreenAreas.areaToOpen.position.x !== position.x || activeScreenAreas.areaToOpen.position.y !== position.y)) {\n                activeScreenAreas.areaToOpen.position = position;\n                // Don't update lastUpdated during drag\n            }\n        }),\n\n        finalizeAreaPlacement: (payload) => set((state: WritableDraft<RootState>) => {\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            if (!activeScreenAreas) return;\n\n            const areaToOpen = activeScreenAreas.areaToOpen;\n            if (!areaToOpen) {\n                activeScreenAreas.errors = [\"No area to open\"];\n                return;\n            }\n\n            try {\n                const { position, area } = areaToOpen;\n                const sourceAreaId = area.state?.sourceId; // ID of the area being moved (if any)\n                const newAreaId = sourceAreaId || uuidv4(); // Use screen's counter for new areas\n\n                const adjustedPosition = new Vec2(position.x, position.y);\n\n                // 1. Add new area data if it's not a move\n                if (!sourceAreaId) {\n                    // Ensure ID is unique before adding\n                    if (activeScreenAreas.areas[newAreaId]) {\n                        console.error(`finalizeAreaPlacement: ID conflict for new area ${newAreaId}`);\n                        activeScreenAreas.areaToOpen = null; // Clear temp state on error\n                        return;\n                    }\n                    activeScreenAreas.areas[newAreaId] = { id: newAreaId, type: area.type, state: area.state };\n                    // Layout entry added later based on placement\n                    activeScreenAreas._id += 1; // Increment counter *only* for new area data creation\n                }\n\n                // 2. Compute viewports and find target\n                // getAreaRootViewport might need context if root isn't window\n                const rootViewport = getAreaRootViewport();\n                const areaToViewport = computeAreaToViewport(\n                    activeScreenAreas.layout,\n                    activeScreenAreas.rootId || '', // Handle null rootId\n                    rootViewport,\n                );\n\n                let determinedTargetAreaId = payload?.targetId;\n                let determinedPlacement = payload?.placement;\n\n                if (!determinedTargetAreaId) {\n                    const detectionDimensions = new Vec2(300, 200);\n                    determinedTargetAreaId = getHoveredAreaId(\n                        adjustedPosition,\n                        activeScreenAreas, // Pass the area state part\n                        areaToViewport,\n                        detectionDimensions\n                    );\n                }\n\n                // 3. Handle no target / invalid drop\n                if (!determinedTargetAreaId) {\n                    // If a new area was created, clean it up\n                    if (!sourceAreaId) {\n                        delete activeScreenAreas.areas[newAreaId];\n                        // Don't decrement _id, accept potential gaps\n                    }\n                    activeScreenAreas.areaToOpen = null; // Clear temp state\n                    return;\n                }\n\n                // 4. Calculate placement and clear temporary state\n                const viewport = areaToViewport[determinedTargetAreaId];\n                if (!viewport) {\n                    console.error(`[areaStore] finalizeAreaPlacement: Viewport not found for target ${determinedTargetAreaId}. Bailing out.`);\n                    // Clean up new area if created\n                    if (!sourceAreaId) delete activeScreenAreas.areas[newAreaId];\n                    activeScreenAreas.areaToOpen = null;\n                    return;\n                }\n                if (!determinedPlacement) {\n                    determinedPlacement = getAreaToOpenPlacementInViewport(viewport, adjustedPosition);\n                }\n                activeScreenAreas.areaToOpen = null; // Clear state *before* complex logic\n\n                // 5. Handle source area removal (if it was a move)\n                let sourceParentRowIdForCleanup: string | null = null;\n                let survivingChildIdFromSourceSimplification: string | null = null;\n\n                if (sourceAreaId) {\n                    const areaToParentRow = computeAreaToParentRow(activeScreenAreas.layout);\n                    const sourceParentRowId = areaToParentRow[sourceAreaId];\n                    sourceParentRowIdForCleanup = sourceParentRowId; // Store for potential simplification later\n\n                    if (sourceParentRowId && activeScreenAreas.layout[sourceParentRowId]?.type === 'area_row') {\n                        const sourceParentRow = activeScreenAreas.layout[sourceParentRowId] as AreaRowLayout;\n                        const areaIndex = sourceParentRow.areas.findIndex(a => a.id === sourceAreaId);\n\n                        if (areaIndex !== -1) {\n                            sourceParentRow.areas.splice(areaIndex, 1); // Remove source area ref\n\n                            if (sourceParentRow.areas.length === 0) {\n                                // Row is empty, remove it and potentially simplify its parent\n                                delete activeScreenAreas.layout[sourceParentRowId];\n                                const grandParentId = areaToParentRow[sourceParentRowId]; // Parent of the row being deleted\n                                simplifyLayoutNodeIfNeeded(activeScreenAreas, grandParentId);\n                            } else {\n                                // Row not empty, normalize sizes and simplify if needed\n                                const totalSize = sourceParentRow.areas.reduce((acc, a) => acc + (a.size || 0), 0);\n                                if (totalSize > 0) {\n                                    const factor = 1.0 / totalSize;\n                                    sourceParentRow.areas.forEach(area => { area.size = (area.size || 0) * factor; });\n                                }\n                                // Check if the row itself needs simplification (e.g., went from 2 to 1 child)\n                                if (sourceParentRow.areas.length === 1) {\n                                    survivingChildIdFromSourceSimplification = sourceParentRow.areas[0].id;\n                                }\n                                simplifyLayoutNodeIfNeeded(activeScreenAreas, sourceParentRowId);\n                            }\n                        }\n                    }\n                    // If source area wasn't in a row (e.g., it was root or orphan), remove its direct layout entry if exists\n                    else if (activeScreenAreas.layout[sourceAreaId]) {\n                        delete activeScreenAreas.layout[sourceAreaId];\n                    }\n                    // Delete source area *data* only if it's truly a move (source != new ID potentially created)\n                    if (sourceAreaId !== newAreaId) { // Should always be true if sourceAreaId exists\n                        delete activeScreenAreas.areas[sourceAreaId];\n                    }\n                    // Check if root needs update\n                    if (activeScreenAreas.rootId === sourceAreaId) {\n                        activeScreenAreas.rootId = null; // Layout is likely broken, needs rebuild or clear\n                    }\n                }\n\n                // Update determinedTargetAreaId if it was the source parent and got simplified away\n                if (determinedTargetAreaId &&\n                    determinedTargetAreaId === sourceParentRowIdForCleanup &&\n                    survivingChildIdFromSourceSimplification &&\n                    !activeScreenAreas.layout[determinedTargetAreaId] // Check if it was indeed removed by simplify\n                ) {\n                    determinedTargetAreaId = survivingChildIdFromSourceSimplification;\n                }\n\n                // 6. Handle placement logic\n                let orientation: \"horizontal\" | \"vertical\" = determinedPlacement === \"stack\" ? \"horizontal\" : (determinedPlacement === \"top\" || determinedPlacement === \"bottom\" ? \"vertical\" : \"horizontal\");\n\n                if (determinedPlacement === \"stack\") {\n                    // On veut stacker deux areas, pas des rows\n                    // Si la cible est un row, on descend jusqu'à la première area enfant\n                    let targetAreaId = determinedTargetAreaId;\n                    let targetArea = activeScreenAreas.areas[targetAreaId];\n\n                    // Si la cible est un area_row avec orientation stack, on le traite comme un area simple\n                    if (activeScreenAreas.layout[targetAreaId]?.type === 'area_row' &&\n                        (activeScreenAreas.layout[targetAreaId] as AreaRowLayout).orientation === 'stack') {\n                        targetArea = activeScreenAreas.areas[targetAreaId];\n                    } else if (!targetArea && activeScreenAreas.layout[targetAreaId]?.type === 'area_row') {\n                        const found = findFirstAreaId(activeScreenAreas.layout, targetAreaId);\n                        if (found) {\n                            targetAreaId = found;\n                            targetArea = activeScreenAreas.areas[targetAreaId];\n                        }\n                    }\n\n                    const sourceData = activeScreenAreas.areas[newAreaId];\n                    if (!sourceData || !targetArea) {\n                        console.error(`[finalizeAreaPlacement] Stack creation failed: Source or target area not found.`);\n                        return;\n                    }\n\n                    // --- CONTRÔLE DES RÔLES ---\n                    const allowMixed = get().options?.allowStackMixedRoles !== false;\n                    if (!allowMixed) {\n                        const sourceRole = sourceData.role || (sourceData.type && (areaRegistry as any)._roleMap?.[sourceData.type]);\n                        const targetRole = targetArea.role || (targetArea.type && (areaRegistry as any)._roleMap?.[targetArea.type]);\n                        if (sourceRole && targetRole && sourceRole !== targetRole) {\n                            activeScreenAreas.errors = [\"Impossible de stacker des areas de rôles différents (option de configuration)\"];\n                            return;\n                        }\n                    }\n                    // --- FIN CONTRÔLE DES RÔLES ---\n\n                    // Créer le nouveau stack\n                    const newStackId = `row-${activeScreenAreas._id + 1}`;\n                    activeScreenAreas._id += 1;\n\n                    // Créer le nouveau stack dans le layout\n                    const newStack: AreaRowLayout = {\n                        type: 'area_row',\n                        id: newStackId,\n                        orientation: 'stack',\n                        areas: [\n                            { id: targetAreaId, size: 0.5 },\n                            { id: newAreaId, size: 0.5 }\n                        ],\n                        activeTabId: targetAreaId // L'area cible est active par défaut\n                    };\n\n                    // Trouver le parent row de l'area cible\n                    const areaToParentRow = computeAreaToParentRow(activeScreenAreas.layout);\n                    const parentRowId = areaToParentRow[targetAreaId];\n\n                    if (parentRowId && activeScreenAreas.layout[parentRowId]?.type === 'area_row') {\n                        // Si l'area cible a un parent row, on remplace sa référence dans ce parent\n                        const parentRow = activeScreenAreas.layout[parentRowId] as AreaRowLayout;\n                        const targetIndex = parentRow.areas.findIndex(a => a.id === targetAreaId);\n                        if (targetIndex !== -1) {\n                            const originalSize = parentRow.areas[targetIndex].size;\n                            parentRow.areas[targetIndex] = { id: newStackId, size: originalSize };\n                        }\n                    } else if (activeScreenAreas.rootId === targetAreaId) {\n                        // Si l'area cible est la racine, on met le stack comme nouvelle racine\n                        activeScreenAreas.rootId = newStackId;\n                    }\n\n                    // Ajouter le stack au layout\n                    activeScreenAreas.layout[newStackId] = newStack;\n\n                    // Mettre à jour l'area active\n                    activeScreenAreas.activeAreaId = targetAreaId;\n\n                } else {\n                    // --- Logic for Top/Bottom/Left/Right placement ---\n                    const areaToParentRow = computeAreaToParentRow(activeScreenAreas.layout);\n                    const parentRowId = areaToParentRow[determinedTargetAreaId];\n                    const parentRow = parentRowId ? activeScreenAreas.layout[parentRowId] as AreaRowLayout : null;\n\n                    const newRowId = uuidv4(); // ID for a potential new row\n\n                    // Ensure layout entry exists for the area being placed\n                    if (!activeScreenAreas.layout[newAreaId]) {\n                        activeScreenAreas.layout[newAreaId] = { type: 'area', id: newAreaId };\n                    }\n\n                    if (parentRow && parentRow.type === 'area_row') { // Target is in a row\n                        const targetIndex = parentRow.areas.findIndex(a => a.id === determinedTargetAreaId);\n                        if (targetIndex === -1) {\n                            console.error(`[finalizeAreaPlacement] Target ${determinedTargetAreaId} not found in parent ${parentRowId}`);\n                            return; // Stop if layout inconsistent\n                        }\n\n                        if (parentRow.orientation === orientation) { // Same orientation: Add as sibling\n                            const insertIndex = targetIndex + (determinedPlacement === \"bottom\" || determinedPlacement === \"right\" ? 1 : 0);\n\n                            // Déterminer les éléments concernés par l'insertion\n                            let affectedAreas = [];\n                            if (insertIndex === 0) {\n                                // Insertion au début : affecte le premier élément\n                                affectedAreas = [parentRow.areas[0]];\n                            } else if (insertIndex === parentRow.areas.length) {\n                                // Insertion à la fin : affecte le dernier élément\n                                affectedAreas = [parentRow.areas[parentRow.areas.length - 1]];\n                            } else {\n                                // Insertion entre deux éléments : affecte les deux éléments adjacents\n                                affectedAreas = [parentRow.areas[insertIndex - 1], parentRow.areas[insertIndex]];\n                            }\n\n                            // Calculer la taille totale des éléments affectés\n                            const totalAffectedSize = affectedAreas.reduce((sum, area) => sum + (area.size || 0), 0);\n\n                            // Répartir l'espace entre les éléments affectés et la nouvelle area\n                            const newSize = totalAffectedSize / (affectedAreas.length + 1);\n                            affectedAreas.forEach(area => area.size = newSize);\n\n                            // Insérer la nouvelle area avec la taille calculée\n                            parentRow.areas.splice(insertIndex, 0, { id: newAreaId, size: newSize });\n                        } else { // Different orientation: Create new nested row\n                            activeScreenAreas._id += 1; // Increment for newRowId\n                            const newNestedRow: AreaRowLayout = {\n                                type: 'area_row',\n                                id: newRowId,\n                                orientation: orientation,\n                                areas: determinedPlacement === \"bottom\" || determinedPlacement === \"right\"\n                                    ? [{ id: determinedTargetAreaId, size: 0.5 }, { id: newAreaId, size: 0.5 }]\n                                    : [{ id: newAreaId, size: 0.5 }, { id: determinedTargetAreaId, size: 0.5 }],\n                            };\n                            activeScreenAreas.layout[newRowId] = newNestedRow;\n                            parentRow.areas[targetIndex] = { id: newRowId, size: parentRow.areas[targetIndex].size }; // Replace target with new row ref\n                        }\n                    } else { // Target is root or an orphan (no parentRow)\n                        activeScreenAreas._id += 1; // Increment for newRowId\n                        const newRootRow: AreaRowLayout = {\n                            type: 'area_row',\n                            id: newRowId,\n                            orientation: orientation,\n                            areas: determinedPlacement === \"bottom\" || determinedPlacement === \"right\"\n                                ? [{ id: determinedTargetAreaId, size: 0.5 }, { id: newAreaId, size: 0.5 }]\n                                : [{ id: newAreaId, size: 0.5 }, { id: determinedTargetAreaId, size: 0.5 }]\n                        };\n                        activeScreenAreas.layout[newRowId] = newRootRow;\n                        activeScreenAreas.rootId = newRowId;\n                        // Ensure the old root (now a child) and newAreaId are in the layout map if they weren't already rows\n                        if (!activeScreenAreas.layout[determinedTargetAreaId]) {\n                            activeScreenAreas.layout[determinedTargetAreaId] = { type: 'area', id: determinedTargetAreaId };\n                        }\n                    }\n\n                }\n\n                // Update active area to the new/moved area\n                if (activeScreenAreas.areas[newAreaId]) { // Ensure area data exists\n                    state.screens[state.activeScreenId].areas.activeAreaId = newAreaId;\n                    if (activeScreenAreas.areas[newAreaId].role === AREA_ROLE.LEAD) {\n                        state.screens[state.activeScreenId].areas.lastLeadAreaId = newAreaId;\n                    }\n                }\n\n                // RECALCULATE VIEWPORTS HERE, USING THE EXISTING rootViewport from earlier in the function\n                // This 'rootViewport' const is typically defined around line 575 of the original file.\n                if (activeScreenAreas.rootId && rootViewport && rootViewport.width > 0 && rootViewport.height > 0) {\n                    const recalculatedViewports = computeAreaToViewport(\n                        activeScreenAreas.layout,\n                        activeScreenAreas.rootId,\n                        rootViewport // Use the existing rootViewport\n                    );\n                    activeScreenAreas.viewports = recalculatedViewports;\n                } else {\n                    activeScreenAreas.viewports = {}; // Clear to avoid stale data\n                }\n\n                // À la toute fin du try (si pas d'erreur et mutation réelle)\n                state.lastUpdated = Date.now();\n            } catch (error) {\n                // Attempt to clean up temporary state on error\n                if (activeScreenAreas) {\n                    activeScreenAreas.areaToOpen = null;\n                }\n                activeScreenAreas.errors = [`Error finalizing area placement: ${error}`];\n            }\n        }),\n\n        cleanupTemporaryStates: () => set((state: WritableDraft<RootState>) => {\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            if (activeScreenAreas && (activeScreenAreas.joinPreview || activeScreenAreas.areaToOpen || activeScreenAreas.lastSplitResultData)) {\n                activeScreenAreas.joinPreview = null;\n                activeScreenAreas.areaToOpen = null;\n                activeScreenAreas.lastSplitResultData = null;\n                state.lastUpdated = Date.now();\n            }\n        }),\n\n        setViewports: (viewports: Record<string, Rect>) => set((state: WritableDraft<RootState>) => {\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            if (!activeScreenAreas) return;\n\n            // Mettre à jour les viewports sans déclencher la synchronisation\n            activeScreenAreas.viewports = viewports;\n            // Ne pas mettre à jour lastUpdated pour éviter la synchronisation\n        }),\n\n        setRowSizes: (payload: { rowId: string; sizes: number[] }) => set((state: WritableDraft<RootState>) => {\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            if (!activeScreenAreas) return;\n            const rowLayout = activeScreenAreas.layout[payload.rowId];\n            if (rowLayout && rowLayout.type === 'area_row') {\n                const typedRowLayout = rowLayout as AreaRowLayout;\n                if (typedRowLayout.areas.length === payload.sizes.length) {\n                    let totalSize = payload.sizes.reduce((sum, size) => sum + size, 0);\n                    if (Math.abs(totalSize - 1.0) > 0.001 && totalSize > 0) {\n                        const scale = 1.0 / totalSize;\n                        typedRowLayout.areas.forEach((areaInfo, index) => {\n                            if (areaInfo) areaInfo.size = payload.sizes[index] * scale;\n                        });\n                    } else {\n                        typedRowLayout.areas.forEach((areaInfo, index) => {\n                            if (areaInfo) areaInfo.size = payload.sizes[index];\n                        });\n                    }\n                    state.lastUpdated = Date.now();\n                }\n            }\n        }),\n\n        splitArea: (payload) => {\n            let result: SplitResult | null = null;\n            set((state: WritableDraft<RootState>) => {\n                const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n                if (!activeScreenAreas) return;\n\n                const { areaIdToSplit, parentRowId, horizontal } = payload;\n                const areaToSplit = activeScreenAreas.layout[areaIdToSplit];\n\n                // Si c'est un area_row avec orientation stack, on le traite comme un stack à dupliquer\n                if (areaToSplit.type === 'area_row' && areaToSplit.orientation === 'stack') {\n                    // Dupliquer tous les enfants (areas) de la stack d'origine\n                    const originalAreas = areaToSplit.areas;\n                    const duplicatedAreas = [];\n                    for (const child of originalAreas) {\n                        const originalArea = activeScreenAreas.areas[child.id];\n                        if (!originalArea) continue;\n                        const newAreaId = `area-${activeScreenAreas._id + 1}`;\n                        activeScreenAreas._id += 1;\n                        // Copier type et state\n                        activeScreenAreas.areas[newAreaId] = {\n                            id: newAreaId,\n                            type: originalArea.type,\n                            state: { ...originalArea.state }\n                        };\n                        activeScreenAreas.layout[newAreaId] = { type: 'area', id: newAreaId };\n                        duplicatedAreas.push({ id: newAreaId, size: child.size });\n                    }\n                    // Créer une nouvelle stack avec les duplicatas\n                    const newStackId = `row-${activeScreenAreas._id + 1}`;\n                    activeScreenAreas._id += 1;\n                    const newStack: AreaRowLayout = {\n                        id: newStackId,\n                        type: 'area_row',\n                        orientation: 'stack',\n                        areas: duplicatedAreas,\n                        activeTabId: duplicatedAreas[0]?.id\n                    };\n                    activeScreenAreas.layout[newStackId] = newStack;\n                    // Créer un nouveau row horizontal/vertical pour contenir les deux stacks\n                    const newRowId = `row-${activeScreenAreas._id + 1}`;\n                    activeScreenAreas._id += 1;\n                    const newRow: AreaRowLayout = {\n                        id: newRowId,\n                        type: 'area_row',\n                        orientation: horizontal ? 'horizontal' : 'vertical',\n                        areas: [\n                            { id: areaIdToSplit, size: 0.5 },\n                            { id: newStackId, size: 0.5 }\n                        ]\n                    };\n                    activeScreenAreas.layout[newRowId] = newRow;\n                    // Si le stack d'origine a un parent, remplacer la référence dans le parent par le nouveau row\n                    if (parentRowId) {\n                        const parentRow = activeScreenAreas.layout[parentRowId] as AreaRowLayout;\n                        if (parentRow?.type === 'area_row') {\n                            const index = parentRow.areas.findIndex(a => a.id === areaIdToSplit);\n                            if (index !== -1) {\n                                const originalSize = parentRow.areas[index].size ?? 0.5;\n                                parentRow.areas[index] = { id: newRowId, size: originalSize };\n                            }\n                        }\n                    } else {\n                        // Sinon, le nouveau row devient root\n                        activeScreenAreas.rootId = newRowId;\n                    }\n                    result = { newRowId: newRowId, separatorIndex: 1 };\n                    return;\n                }\n\n                // Comportement existant pour les autres types d'area\n                // Incrémenter le compteur avant de générer les IDs\n                activeScreenAreas._id += 1;\n                const baseId = activeScreenAreas._id;\n                const newAreaId = `area-${baseId}`;\n                const newRowId = `row-${baseId + 1}`;\n\n                // 1. Create New Area Data & Layout Entry\n                if (activeScreenAreas.areas[newAreaId] || activeScreenAreas.layout[newAreaId]) {\n                    console.error(`splitArea: ID conflict for new area ${newAreaId}`); return;\n                }\n                // Correction ici : on prend le type depuis l'objet métier\n                const originalArea = activeScreenAreas.areas[areaIdToSplit];\n                activeScreenAreas.areas[newAreaId] = {\n                    id: newAreaId,\n                    type: originalArea?.type || areaToSplit.type, // Priorité à l'objet métier\n                    state: { ...originalArea?.state }, // Copier l'état de l'area source\n                    spaceId: originalArea?.spaceId // Hériter de l'espace de l'area source\n                };\n                activeScreenAreas.layout[newAreaId] = { type: 'area', id: newAreaId };\n\n                // 2. Create New Row Layout Entry\n                if (activeScreenAreas.layout[newRowId]) {\n                    console.error(`splitArea: ID conflict for new row ${newRowId}`); return;\n                }\n                const newRow: AreaRowLayout = {\n                    id: newRowId, type: 'area_row',\n                    orientation: horizontal ? 'horizontal' : 'vertical',\n                    areas: [ // Split 50/50 initially\n                        { id: areaIdToSplit, size: 0.5 },\n                        { id: newAreaId, size: 0.5 }\n                    ]\n                };\n                activeScreenAreas.layout[newRowId] = newRow;\n\n                // 3. Update Parent Row or Root ID\n                let originalSize = 0.5; // Default size if parent lookup fails\n                if (parentRowId) {\n                    const parentRow = activeScreenAreas.layout[parentRowId] as AreaRowLayout;\n                    if (parentRow?.type === 'area_row') {\n                        const index = parentRow.areas.findIndex(a => a.id === areaIdToSplit);\n                        if (index !== -1) {\n                            originalSize = parentRow.areas[index].size ?? 0.5; // Store original size\n\n                            // Si l'orientation du parent est la même que celle du nouveau row, on simplifie la structure\n                            if (parentRow.orientation === newRow.orientation) {\n                                // Au lieu de remplacer par le nouveau row, on ajoute directement les areas\n                                const areasToAdd = newRow.areas.map(area => ({\n                                    id: area.id,\n                                    size: (area.size ?? 0.5) * originalSize // Ajuster la taille en fonction de la taille originale\n                                }));\n                                parentRow.areas.splice(index, 1, ...areasToAdd);\n\n                                // Mettre à jour le résultat pour refléter la nouvelle structure\n                                result = {\n                                    newRowId: parentRowId,\n                                    separatorIndex: index + 1 // L'index du séparateur est après la première area\n                                };\n                            } else {\n                                // Si les orientations sont différentes, on garde la structure actuelle\n                                parentRow.areas[index] = { id: newRowId, size: originalSize };\n                                result = { newRowId: newRowId, separatorIndex: 1 };\n                            }\n                        } else {\n                            console.error(`splitArea Error: Area ${areaIdToSplit} not in parent ${parentRowId}.`);\n                        }\n                    } else {\n                        console.error(`splitArea Error: Parent ${parentRowId} not found or not row.`);\n                    }\n                } else if (activeScreenAreas.rootId === areaIdToSplit) {\n                    activeScreenAreas.rootId = newRowId; // New row becomes root\n                    result = { newRowId: newRowId, separatorIndex: 1 };\n                } else {\n                    // Area has no parent and isn't root - orphan?\n                    console.error(`splitArea Error: Area ${areaIdToSplit} has no parent and is not root.`);\n                }\n\n                // 4. Increment ID counter AFTER using baseId+1 and baseId+2\n                activeScreenAreas._id = baseId + 2;\n\n                // 5. Set result\n                activeScreenAreas.lastSplitResultData = result;\n\n                // 6. Simplification récursive de la structure après split\n                function simplifyRecursively(rowId: string | null | undefined) {\n                    if (!rowId) return;\n                    let currentId = rowId;\n                    while (currentId) {\n                        const before = activeScreenAreas.layout[currentId];\n                        simplifyLayoutNodeIfNeeded(activeScreenAreas, currentId);\n                        // Si le node a été supprimé, on remonte au parent\n                        const areaToParentRowMap = computeAreaToParentRow(activeScreenAreas.layout);\n                        currentId = areaToParentRowMap[currentId];\n                        if (before && !activeScreenAreas.layout[before.id]) {\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                // Fonction pour fusionner les rows de même orientation\n                function mergeRowsOfSameOrientation(rowId: string | null | undefined, parentId: string | null = null) {\n                    if (!rowId) return;\n                    const row = activeScreenAreas.layout[rowId];\n                    if (!row || row.type !== 'area_row') return;\n                    let changed = false;\n                    for (let i = 0; i < row.areas.length;) {\n                        const childId = row.areas[i].id;\n                        const child = activeScreenAreas.layout[childId];\n                        if (child && child.type === 'area_row' && child.orientation === row.orientation) {\n                            // Fusionner les enfants du row enfant dans le row parent\n                            const childRow = child;\n                            const parentSize = row.areas[i].size ?? 1 / row.areas.length;\n                            const totalChildSize = childRow.areas.reduce((acc, a) => acc + (a.size ?? 0), 0) || 1;\n                            const newAreas = childRow.areas.map(a => ({\n                                id: a.id,\n                                size: (a.size ?? 1 / childRow.areas.length) * parentSize / totalChildSize\n                            }));\n                            // On remplace le row enfant par ses propres enfants (en évitant les doublons)\n                            row.areas.splice(i, 1, ...newAreas.filter(na => !row.areas.some(a => a.id === na.id)));\n                            // On supprime le row enfant de la layout\n                            delete activeScreenAreas.layout[childId];\n                            changed = true;\n                            // On ne fait pas i++ car on a remplacé l'élément courant par plusieurs\n                        } else {\n                            i++;\n                        }\n                    }\n                    // Appel récursif sur les enfants restants\n                    for (const area of row.areas) {\n                        mergeRowsOfSameOrientation(area.id, rowId);\n                    }\n                    // Si on a changé la structure, on peut relancer la fusion sur ce row\n                    if (changed) {\n                        mergeRowsOfSameOrientation(rowId, parentId);\n                    }\n                }\n                // Fonction pour nettoyer les rows orphelins (non référencés par un parent ni root)\n                function cleanOrphanRows() {\n                    const referenced = new Set<string>();\n                    // On marque tous les rows référencés par le root\n                    function mark(id: string | null | undefined) {\n                        if (!id || referenced.has(id)) return;\n                        referenced.add(id);\n                        const node = activeScreenAreas.layout[id];\n                        if (node && node.type === 'area_row') {\n                            for (const area of node.areas) {\n                                mark(area.id);\n                            }\n                        }\n                    }\n                    mark(activeScreenAreas.rootId);\n                    // On supprime tous les rows non référencés\n                    for (const id in activeScreenAreas.layout) {\n                        const node = activeScreenAreas.layout[id];\n                        if (node && node.type === 'area_row' && !referenced.has(id)) {\n                            delete activeScreenAreas.layout[id];\n                        }\n                    }\n                }\n                // On simplifie à partir du parent direct\n                simplifyRecursively(parentRowId);\n                // On fusionne les rows de même orientation à partir du root\n                mergeRowsOfSameOrientation(activeScreenAreas.rootId);\n                // On nettoie les rows orphelins\n                cleanOrphanRows();\n\n                // À la toute fin, si mutation réelle\n                state.lastUpdated = Date.now();\n            });\n            return result; // Return result captured outside 'set'\n        },\n\n        setJoinPreview: (payload) => set((state: WritableDraft<RootState>) => {\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            if (activeScreenAreas && activeScreenAreas.joinPreview !== payload) {\n                activeScreenAreas.joinPreview = payload;\n                state.lastUpdated = Date.now();\n            }\n        }),\n\n        joinOrMoveArea: (payload) => set((state: WritableDraft<RootState>) => {\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            if (!activeScreenAreas) return;\n\n            const { sourceAreaId, targetAreaId } = payload;\n            const { parentRow, sourceIndex, targetIndex } = findParentRowAndIndices(\n                activeScreenAreas.layout, sourceAreaId, targetAreaId\n            );\n\n            if (!parentRow || parentRow.type !== 'area_row') {\n                activeScreenAreas.errors = [`Could not find adjacent areas ${sourceAreaId}/${targetAreaId} in the same row.`];\n                activeScreenAreas.joinPreview = null;\n                return;\n            }\n\n            // Store original parent row ID and get grandparent ID *before* mutation\n            const originalParentRowId = parentRow.id;\n            const areaToParentMapBefore = computeAreaToParentRow(activeScreenAreas.layout);\n            const grandParentId = areaToParentMapBefore[originalParentRowId];\n\n            // Create a deep copy for the utility function\n            const parentRowCopy = JSON.parse(JSON.stringify(parentRow));\n\n            const mergeIntoDirection = targetIndex > sourceIndex ? 1 : -1;\n            const areaIndexToRemove = sourceIndex;\n\n            try {\n                const joinResult = joinAreasUtil(parentRowCopy, areaIndexToRemove, mergeIntoDirection);\n                const { area: resultingLayoutItem, removedAreaId } = joinResult;\n\n                // 1. Cleanup removed area and its descendants\n                const allRemovedIds = findAllDescendantAreaIds(activeScreenAreas.layout, removedAreaId);\n                allRemovedIds.add(removedAreaId);\n                allRemovedIds.forEach(id => {\n                    delete activeScreenAreas.areas[id];\n                    delete activeScreenAreas.layout[id];\n                });\n\n                // 2. Update the layout based on the result\n                if (resultingLayoutItem.id === originalParentRowId && resultingLayoutItem.type === 'area_row') {\n                    // Row still exists (same ID), update its layout entry\n                    const updatedRow = resultingLayoutItem as AreaRowLayout;\n                    activeScreenAreas.layout[originalParentRowId] = updatedRow;\n                    // Normalize sizes (important after potential merges)\n                    if (updatedRow.areas) {\n                        const totalSize = updatedRow.areas.reduce((acc, a) => acc + (a.size || 0), 0);\n                        if (totalSize > 0) {\n                            const factor = 1.0 / totalSize;\n                            updatedRow.areas.forEach(area => { area.size = (area.size || 0) * factor; });\n                        }\n                    }\n                    // Check if simplification is needed *now*\n                    if (updatedRow.areas?.length === 1) {\n                        simplifyLayoutNodeIfNeeded(activeScreenAreas, originalParentRowId);\n                    }\n                } else {\n                    // Row collapsed into a single area or the resulting item has a different ID.\n                    // The original parentRow layout entry should be removed.\n                    delete activeScreenAreas.layout[originalParentRowId];\n\n                    // Ensure the resulting item has a layout entry if it doesn't exist\n                    if (!activeScreenAreas.layout[resultingLayoutItem.id]) {\n                        // Assuming it's now an area if type isn't area_row\n                        if (resultingLayoutItem.type !== 'area_row') {\n                            activeScreenAreas.layout[resultingLayoutItem.id] = { type: 'area', id: resultingLayoutItem.id };\n                        }\n                    }\n\n                    // Update Grandparent or Root\n                    if (grandParentId && activeScreenAreas.layout[grandParentId]?.type === 'area_row') {\n                        const grandParentRow = activeScreenAreas.layout[grandParentId] as AreaRowLayout;\n                        const rowIndexInGrandparent = grandParentRow.areas.findIndex(a => a.id === originalParentRowId);\n                        if (rowIndexInGrandparent !== -1) {\n                            // Replace the ref to the old row with the ref to the new item (area or new row)\n                            const sizeToPreserve = grandParentRow.areas[rowIndexInGrandparent].size ?? 0.5;\n                            grandParentRow.areas[rowIndexInGrandparent] = { id: resultingLayoutItem.id, size: sizeToPreserve };\n                            // No need to call simplify on grandparent here, handled by subsequent joins/removals\n                        } else {\n                            console.error(`[joinOrMoveArea] Cleanup Error: Row ${originalParentRowId} not found in grandparent ${grandParentId}.`);\n                        }\n                    } else if (activeScreenAreas.rootId === originalParentRowId) {\n                        // The collapsed row was the root, promote the result to be the new root\n                        activeScreenAreas.rootId = resultingLayoutItem.id;\n                    }\n                }\n\n                // 3. Update active area if it was removed\n                if (activeScreenAreas.activeAreaId && allRemovedIds.has(activeScreenAreas.activeAreaId)) {\n                    // Set active to the surviving area? Or null?\n                    // If resultingLayoutItem is the surviving area ID:\n                    if (resultingLayoutItem.type === 'area') {\n                        activeScreenAreas.activeAreaId = resultingLayoutItem.id;\n                    } else {\n                        activeScreenAreas.activeAreaId = null; // Or find first child of resulting row?\n                    }\n                }\n\n                activeScreenAreas.errors = [];\n                activeScreenAreas.joinPreview = null;\n\n            } catch (error) {\n                console.error('Error during joinOrMoveArea:', error);\n                activeScreenAreas.errors = [(error instanceof Error ? error.message : String(error))];\n                activeScreenAreas.joinPreview = null;\n            }\n            // À la toute fin du try (si mutation réelle)\n            state.lastUpdated = Date.now();\n        }),\n\n        getLastSplitResult: () => {\n            // Selector needs access to active screen state via get()\n            const activeScreenAreas = get().screens[get().activeScreenId]?.areas;\n            return activeScreenAreas ? activeScreenAreas.lastSplitResultData : null;\n        },\n\n\n        // --- SELECTORS (adapted to operate on active screen) ---\n        getActiveArea: () => {\n            const state = get(); // Get root state\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            return activeScreenAreas && activeScreenAreas.activeAreaId\n                ? activeScreenAreas.areas[activeScreenAreas.activeAreaId]\n                : null;\n        },\n        getAreaById: (id) => {\n            const state = get();\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            return activeScreenAreas ? activeScreenAreas.areas[id] : undefined;\n        },\n        getAllAreas: () => {\n            const state = get();\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            return activeScreenAreas ? activeScreenAreas.areas : {};\n        },\n        getAreaErrors: () => {\n            const state = get();\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            return activeScreenAreas ? activeScreenAreas.errors : [];\n        },\n        getLastLeadAreaId: () => {\n            const state = get();\n            const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\n            return activeScreenAreas?.lastLeadAreaId || null;\n        },\n        findParentRowAndIndices: findParentRowAndIndices,\n    };\n};\n\n\n// --- Define the core state logic with immer (structure + area slice) ---\nconst rootStoreCreator: StateCreator<\n    RootState,\n    [\n        [\"zustand/immer\", never],\n        [\"zustand/persist\", unknown],\n        [\"zustand/devtools\", never]\n    ]\n> = (set, get) => {\n    // --- Create the Area Slice instance ---\n    const areaSlice = createAreaSlice(set, get, {} as any);\n\n    return {\n        // --- Initial Root State ---\n        screens: {\n            '1': createInitialScreenState() // Laisser l'initialisation de base ici\n            // Le KarmycInitializer s'occupera de remplir l'écran '1' si nécessaire\n        },\n        activeScreenId: '1',\n        nextScreenId: 2,\n        options: { allowStackMixedRoles: true },\n        lastUpdated: Date.now(), // Initialisation\n        layout_preset: [],\n\n        // --- Root Level Screen Management Actions ---\n        addScreen: () => set((state: WritableDraft<RootState>) => {\n            const newScreenId = state.nextScreenId.toString();\n\n            // 1. Créer l'écran avec un état initial vide (ou basé sur createInitialScreenState)\n            state.screens[newScreenId] = createInitialScreenState();\n\n            // 2. Ajouter une zone par défaut et configurer le layout pour ce nouvel écran\n            const defaultAreaId = `area-default-${newScreenId}-0`; // ID unique pour la zone par défaut\n            const newScreenAreasState = state.screens[newScreenId].areas;\n\n            // Ajouter la zone par défaut\n            newScreenAreasState.areas[defaultAreaId] = {\n                id: defaultAreaId,\n                type: 'text-note', // Ou un autre type par défaut\n                state: { content: 'New Screen' } // Contenu initial\n            };\n\n            // Configurer le layout et rootId pour cette seule zone\n            newScreenAreasState.layout = {\n                [defaultAreaId]: { type: 'area', id: defaultAreaId } // Layout simple pour la zone\n            };\n            newScreenAreasState.rootId = defaultAreaId; // La zone est la racine\n            newScreenAreasState._id = 1; // Le compteur interne de cet écran est à 1\n            newScreenAreasState.activeAreaId = defaultAreaId; // Rendre la zone active par défaut\n\n            // 3. Mettre à jour le compteur d'ID d'écran et l'écran actif\n            state.nextScreenId += 1;\n            state.activeScreenId = newScreenId;\n            state.lastUpdated = Date.now();\n        }),\n\n        switchScreen: (screenId) => set((state: WritableDraft<RootState>) => {\n            if (state.screens[screenId] && state.activeScreenId !== screenId) {\n                state.activeScreenId = screenId;\n                state.lastUpdated = Date.now();\n            } else if (!state.screens[screenId]) {\n                console.warn(`Attempted to switch to non-existent screen ID: ${screenId}`);\n            }\n        }),\n\n        removeScreen: (screenId) => set((state: WritableDraft<RootState>) => {\n            // Vérifier s'il reste plus d'un écran classique\n            const classicIds = Object.keys(state.screens).filter(id => !state.screens[id]?.isDetached);\n            if (classicIds.length <= 1 && !state.screens[screenId]?.isDetached) {\n                console.warn('Cannot remove the last classic screen');\n                return;\n            }\n\n            if (!state.screens[screenId]) {\n                console.warn(`Attempted to remove non-existent screen ID: ${screenId}`);\n                return;\n            }\n\n            // Supprimer l'écran\n            delete state.screens[screenId];\n\n            // Mettre à jour le compteur d'ID d'écran (max des classiques + 1)\n            const maxClassicId = Object.keys(state.screens)\n                .filter(id => !state.screens[id]?.isDetached)\n                .reduce((max, id) => Math.max(max, parseInt(id)), 0);\n            state.nextScreenId = maxClassicId + 1;\n\n            // Si l'écran supprimé était actif, basculer vers le plus petit ID classique restant\n            if (state.activeScreenId === screenId) {\n                const classicIdsLeft = Object.keys(state.screens)\n                    .filter(id => !state.screens[id]?.isDetached)\n                    .sort((a, b) => parseInt(a) - parseInt(b));\n                state.activeScreenId = classicIdsLeft[0] || Object.keys(state.screens)[0] || '1';\n            }\n\n            // Mettre à jour l'URL si nécessaire\n            const url = new URL(window.location.href);\n            if (url.searchParams.get('screen') === screenId) {\n                url.searchParams.delete('screen');\n                window.history.replaceState({}, '', url.toString());\n            }\n\n            state.lastUpdated = Date.now();\n        }),\n\n        duplicateScreen: (screenId) => set((state: WritableDraft<RootState>) => {\n            if (!state.screens[screenId]) {\n                console.warn(`Attempted to duplicate non-existent screen ID: ${screenId}`);\n                return;\n            }\n\n            const newScreenId = state.nextScreenId.toString();\n            const sourceScreen = state.screens[screenId];\n\n            // Créer une copie profonde de l'écran source\n            state.screens[newScreenId] = JSON.parse(JSON.stringify(sourceScreen));\n\n            // Mettre à jour le compteur d'ID d'écran et l'écran actif\n            state.nextScreenId += 1;\n            state.activeScreenId = newScreenId;\n            state.lastUpdated = Date.now();\n        }),\n\n        detachArea: (areaId) => set((state: WritableDraft<RootState>) => {\n            const area = state.getAreaById(areaId);\n            if (!area) {\n                console.warn(`Area ${areaId} not found`);\n                return;\n            }\n\n            const newScreenId = `detached-${state.nextScreenId}`;\n            state.nextScreenId += 1;\n\n            // Créer un nouveau screen détaché\n            state.screens[newScreenId] = {\n                ...createInitialScreenState(),\n                areas: {\n                    ...createInitialScreenState().areas\n                },\n                isDetached: true,\n                detachedFromAreaId: areaId\n            };\n\n            // Copier l'area dans le nouveau screen\n            const newScreenAreasState = state.screens[newScreenId].areas;\n            newScreenAreasState.areas[areaId] = { ...area };\n            newScreenAreasState.layout = {\n                [areaId]: { type: 'area', id: areaId }\n            };\n            newScreenAreasState.rootId = areaId;\n            newScreenAreasState.activeAreaId = areaId;\n\n            // Supprimer l'area du screen d'origine (areas et layout)\n            const originScreen = state.screens[state.activeScreenId];\n            if (originScreen) {\n                // Supprimer l'area de la map\n                delete originScreen.areas.areas[areaId];\n                // Supprimer la référence dans le layout\n                for (const key in originScreen.areas.layout) {\n                    const item = originScreen.areas.layout[key];\n                    if (item.type === 'area_row') {\n                        item.areas = item.areas.filter(a => a.id !== areaId);\n                    }\n                }\n                // Supprimer l'entrée de layout si c'est un node direct\n                delete originScreen.areas.layout[areaId];\n                // Nettoyer le rootId si besoin\n                if (originScreen.areas.rootId === areaId) {\n                    originScreen.areas.rootId = null;\n                }\n                // Automatic simplification of rows after detachment\n                for (const key in originScreen.areas.layout) {\n                    const item = originScreen.areas.layout[key];\n                    if (item.type === 'area_row' && item.areas.length === 1) {\n                        simplifyLayoutNodeIfNeeded(originScreen.areas, key);\n                    }\n                }\n            }\n\n            // Ouvrir dans une nouvelle fenêtre sans navigation\n            const features = [\n                'width=800',\n                'height=600',\n                'menubar=no',\n                'toolbar=no',\n                'location=no',\n                'status=no',\n                'scrollbars=yes',\n                'resizable=yes'\n            ].join(',');\n            window.open(`?screen=${newScreenId}`, newScreenId, features);\n            state.lastUpdated = Date.now();\n        }),\n\n        // --- Expose Area Slice Actions/Selectors directly ---\n        addArea: areaSlice.addArea,\n        removeArea: areaSlice.removeArea,\n        setActiveArea: areaSlice.setActiveArea,\n        updateArea: areaSlice.updateArea,\n        updateLayout: areaSlice.updateLayout,\n        setAreaToOpen: areaSlice.setAreaToOpen,\n        updateAreaToOpenPosition: areaSlice.updateAreaToOpenPosition,\n        finalizeAreaPlacement: areaSlice.finalizeAreaPlacement,\n        cleanupTemporaryStates: areaSlice.cleanupTemporaryStates,\n        setViewports: areaSlice.setViewports,\n        setRowSizes: areaSlice.setRowSizes,\n        splitArea: areaSlice.splitArea,\n        setJoinPreview: areaSlice.setJoinPreview,\n        joinOrMoveArea: areaSlice.joinOrMoveArea,\n        getLastSplitResult: areaSlice.getLastSplitResult,\n        getActiveArea: areaSlice.getActiveArea,\n        getAreaById: areaSlice.getAreaById,\n        getAllAreas: areaSlice.getAllAreas,\n        getAreaErrors: areaSlice.getAreaErrors,\n        findParentRowAndIndices: findParentRowAndIndices,\n    };\n};\n\n\n// --- Store Creation (applying middlewares) ---\n// Générer un ID unique pour chaque fenêtre\nconst windowId = Math.random().toString(36).slice(2);\nexport const useKarmycStore = create<RootState>()(\n    immer(\n        persist(\n            devtools(rootStoreCreator, { name: 'KarmycRootStore' }),\n            {\n                name: 'karmycRootState',\n                partialize: (state) => ({\n                    screens: state.screens,\n                    activeScreenId: state.activeScreenId,\n                    nextScreenId: state.nextScreenId,\n                    lastUpdated: state.lastUpdated,\n                    options: state.options,\n                    layout_preset: state.layout_preset\n                }),\n                storage: createJSONStorage(() => localStorage),\n                skipHydration: false,\n                onRehydrateStorage: () => (state) => {\n                    if (!state) {\n                        console.warn('[KarmycStore] État invalide après hydratation, réinitialisation...');\n                        useKarmycStore.setState({\n                            screens: {\n                                '1': createInitialScreenState()\n                            },\n                            activeScreenId: '1',\n                            nextScreenId: 2,\n                            lastUpdated: Date.now(),\n                            options: { allowStackMixedRoles: true }\n                        });\n                    }\n                }\n            }\n        )\n    )\n);\n\n// Ajouter une fonction d'initialisation explicite\nexport const initializeKarmycStore = (optionsParam: Partial<IKarmycOptions> = {}) => {\n    const state = useKarmycStore.getState();\n    const mergedOptions = {\n        ...state.options,\n        ...optionsParam\n    };\n    if (!state.screens || Object.keys(state.screens).length === 0) {\n        useKarmycStore.setState({\n            screens: {\n                '1': createInitialScreenState()\n            },\n            activeScreenId: '1',\n            nextScreenId: 2,\n            lastUpdated: Date.now(),\n            options: mergedOptions\n        });\n    } else {\n        // Toujours mettre à jour les options avec priorité à la config\n        useKarmycStore.setState({\n            options: mergedOptions\n        });\n    }\n};\n\n// Synchronisation inter-fenêtres : ignorer l'event storage si c'est la même fenêtre\nif (typeof window !== 'undefined') {\n    let syncTimeout: NodeJS.Timeout | null = null;\n    const SYNC_DEBOUNCE_MS = 50; // 50ms debounce\n\n    window.addEventListener('storage', (event) => {\n        if (event.key === 'karmycRootState') {\n            const local = localStorage.getItem('karmycRootState');\n            if (!local) return;\n            const parsed = JSON.parse(local);\n            if (parsed?.state?.windowId === windowId) return;\n\n            // Récupérer l'état actuel du store\n            const currentState = useKarmycStore.getState();\n            const localScreens = parsed?.state?.screens || {};\n            const incomingLastUpdated = parsed?.state?.lastUpdated || 0;\n            const localLastUpdated = currentState.lastUpdated || 0;\n            const hasChanges = Object.keys(localScreens).some(screenId => {\n                const localScreen = localScreens[screenId];\n                const currentScreen = currentState.screens[screenId];\n                return !currentScreen || JSON.stringify(localScreen) !== JSON.stringify(currentScreen);\n            });\n\n            // Annuler le timeout précédent s'il existe\n            if (syncTimeout) {\n                clearTimeout(syncTimeout);\n            }\n\n            // Créer un nouveau timeout\n            syncTimeout = setTimeout(() => {\n                // Ne mettre à jour que si des changements sont détectés ET si la version reçue est plus récente\n                if (hasChanges && incomingLastUpdated > localLastUpdated) {\n                    useKarmycStore.setState((state) => ({\n                        ...state,\n                        screens: localScreens,\n                        lastUpdated: incomingLastUpdated\n                    }));\n                }\n                syncTimeout = null;\n            }, SYNC_DEBOUNCE_MS);\n        }\n    });\n}\n","import { validatePosition } from '../utils/validation';\nimport { create } from 'zustand';\nimport { immer } from 'zustand/middleware/immer';\nimport {\n    ContextMenuItem,\n    IContextMenuPosition,\n} from '../types/contextMenu'; // Assuming types are correctly located\nimport { validateContextMenuItem } from '../utils/validation'; // Assuming validation utils are correctly located\nimport React from 'react';\n\ninterface ContextMenuState {\n    isVisible: boolean;\n    position: IContextMenuPosition;\n    items: ContextMenuItem[];\n    errors: string[];\n    targetId?: string;\n    metadata?: Record<string, any>;\n    menuClassName?: string;\n    customContextMenuContent?: React.ReactNode;\n    menuType?: 'default' | 'switchType' | 'custom';\n    // Actions\n    openContextMenu: (payload: {\n        position: IContextMenuPosition;\n        items: ContextMenuItem[];\n        targetId?: string;\n        metadata?: Record<string, any>;\n    }) => void;\n    openCustomContextMenu: (payload: {\n        position: IContextMenuPosition;\n        targetId?: string;\n        metadata?: Record<string, any>;\n        component: React.ReactNode;\n    }) => void;\n    closeContextMenu: () => void;\n    updateContextMenuPosition: (position: IContextMenuPosition) => void;\n    updateContextMenuItems: (items: ContextMenuItem[]) => void;\n    clearErrors: () => void;\n    openSwitchTypeContextMenu?: (payload: {\n        position: IContextMenuPosition;\n        targetId?: string;\n        metadata?: Record<string, any>;\n        menuClassName?: string;\n    }) => void;\n}\n\nconst initialState = {\n    isVisible: false,\n    position: { x: 0, y: 0 },\n    items: [],\n    errors: [],\n    targetId: undefined,\n    metadata: undefined,\n    menuClassName: 'menu',\n    customContextMenuContent: null,\n    menuType: undefined\n};\n\nexport const useContextMenuStore = create<ContextMenuState>()(\n    immer((set) => ({\n        ...initialState,\n\n        openContextMenu: (payload) =>\n            set((state) => {\n                const { position, items, targetId, metadata } = payload;\n                const menuClassName = (payload as any).menuClassName;\n\n                // Validation\n                const positionValidation = validatePosition(position);\n                if (!positionValidation.isValid) {\n                    console.warn('Position validation failed:', positionValidation.errors);\n                    state.errors = positionValidation.errors;\n                    return;\n                }\n\n                const itemsValidation = items.map((item) => validateContextMenuItem(item));\n                const invalidItems = itemsValidation.filter((validation) => !validation.isValid);\n                if (invalidItems.length > 0) {\n                    console.warn('Items validation failed:', invalidItems);\n                    state.errors = invalidItems.flatMap(\n                        (validation: any) => validation.errors || ['Unknown item validation error']\n                    );\n                    return;\n                }\n\n                // Update state\n                state.isVisible = true;\n                state.position = position;\n                state.items = items;\n                state.targetId = targetId;\n                state.metadata = metadata;\n                state.menuClassName = menuClassName || state.menuClassName || 'menu';\n                state.errors = [];\n                state.menuType = 'default';\n            }),\n\n        openCustomContextMenu: (payload) =>\n            set((state) => {\n                const { position, targetId, metadata, component } = payload;\n                const menuClassName = (payload as any).menuClassName;\n\n                // Vérification de la présence de position\n                if (!position) {\n                    console.warn('Aucune position fournie à openCustomContextMenu');\n                    state.errors = ['Aucune position fournie au menu contextuel'];\n                    return;\n                }\n\n                // Validation\n                const positionValidation = validatePosition(position);\n                if (!positionValidation.isValid) {\n                    console.warn('Position validation failed:', positionValidation.errors);\n                    state.errors = positionValidation.errors;\n                    return;\n                }\n                state.isVisible = true;\n                state.position = position;\n                state.targetId = targetId;\n                state.metadata = metadata;\n                state.errors = [];\n                state.menuClassName = menuClassName + ' menu';\n                state.customContextMenuContent = component;\n                state.menuType = 'custom';\n            }),\n\n        closeContextMenu: () =>\n            set((state) => {\n                Object.assign(state, initialState); // Reset to initial state\n                state.menuType = undefined;\n            }),\n\n        updateContextMenuPosition: (position) =>\n            set((state) => {\n                const validation = validatePosition(position);\n                if (!validation.isValid) {\n                    state.errors = validation.errors;\n                    return;\n                }\n                state.position = position;\n                state.errors = []; // Clear errors on successful update\n            }),\n\n        updateContextMenuItems: (items) =>\n            set((state) => {\n                const itemsValidation = items.map((item) => validateContextMenuItem(item));\n                const invalidItems = itemsValidation.filter((validation) => !validation.isValid);\n                if (invalidItems.length > 0) {\n                    // Type assertion needed if validation result doesn't explicitly have errors property\n                    state.errors = invalidItems.flatMap(\n                        (validation: any) => validation.errors || ['Unknown item validation error']\n                    );\n                    return;\n                }\n                state.items = items;\n                state.errors = []; // Clear errors on successful update\n            }),\n\n        clearErrors: () =>\n            set((state) => {\n                state.errors = [];\n            }),\n    }))\n);\n\n// Selectors can be used directly from the hook, e.g.:\n// const isVisible = useContextMenuStore(state => state.isVisible);\n// const position = useContextMenuStore(state => state.position); \n","import {\n    Action,\n    IActionPlugin,\n    IActionRegistry,\n    IActionRegistryOptions,\n    IActionValidationResult,\n    TActionValidator\n} from '../../types/actions';\n\n// Definition of action handler type\ntype ActionHandler = (params: any) => void;\n\n// Interface for context menu metadata\ninterface ActionMetadata {\n    menuType?: string;\n    label?: string;\n    icon?: string;\n    isEnabled?: () => boolean;\n    isVisible?: () => boolean;\n    order?: number;\n}\n\n/**\n * Action Registry\n * Gère l'enregistrement et l'exécution des actions et plugins\n */\nclass ActionRegistry implements IActionRegistry {\n    private plugins: Map<string, IActionPlugin> = new Map();\n    private validators: Map<string, TActionValidator[]> = new Map();\n    private actionHandlers: Map<string, { handler: ActionHandler; metadata?: ActionMetadata }> = new Map();\n    private menuActionsByType: Map<string, Set<string>> = new Map();\n    // @ts-expect-error - options is used in the next line\n    private options: IActionRegistryOptions;\n\n    constructor(options: IActionRegistryOptions = {}) {\n        this.options = {\n            ...options\n        };\n\n        if (options.defaultValidators) {\n            this.validators = new Map(Object.entries(options.defaultValidators));\n        }\n    }\n\n    /**\n     * Enregistre un plugin d'action\n     */\n    registerPlugin(plugin: IActionPlugin): void {\n        this.plugins.set(plugin.id, plugin);\n        \n        // Call onRegister if it exists\n        if (plugin.onRegister) {\n            plugin.onRegister();\n        }\n    }\n\n    /**\n     * Désenregistre un plugin d'action\n     */\n    unregisterPlugin(id: string): void {\n        const plugin = this.plugins.get(id);\n\n        if (plugin?.onUnregister) {\n            plugin.onUnregister();\n        }\n\n        this.plugins.delete(id);\n    }\n\n    /**\n     * Enregistre un validateur pour un type d'action\n     */\n    registerValidator(actionType: string, validator: TActionValidator): void {\n        const existing = this.validators.get(actionType) || [];\n        this.validators.set(actionType, [...existing, validator]);\n    }\n\n    /**\n     * Désenregistre tous les validateurs pour un type d'action\n     */\n    unregisterValidators(actionType: string): void {\n        this.validators.delete(actionType);\n    }\n\n    /**\n     * Enregistre un gestionnaire d'action avec métadonnées optionnelles\n     */\n    registerActionHandler(actionId: string, handler: ActionHandler, metadata?: ActionMetadata): void {\n        this.actionHandlers.set(actionId, { handler, metadata });\n        \n        if (metadata?.menuType) {\n            const menuActions = this.menuActionsByType.get(metadata.menuType) || new Set();\n            menuActions.add(actionId);\n            this.menuActionsByType.set(metadata.menuType, menuActions);\n        }\n    }\n\n    /**\n     * Désenregistre un gestionnaire d'action\n     */\n    unregisterActionHandler(actionId: string): void {\n        const action = this.actionHandlers.get(actionId);\n        if (action?.metadata?.menuType) {\n            const menuActions = this.menuActionsByType.get(action.metadata.menuType);\n            if (menuActions) {\n                menuActions.delete(actionId);\n                if (menuActions.size === 0) {\n                    this.menuActionsByType.delete(action.metadata.menuType);\n                }\n            }\n        }\n        this.actionHandlers.delete(actionId);\n    }\n\n    /**\n     * Valide une action\n     */\n    validateAction(action: Action): IActionValidationResult {\n        const validators = this.validators.get(action.type) || [];\n\n        for (const validator of validators) {\n            const result = validator(action);\n            if (!result.valid) {\n                return result;\n            }\n        }\n\n        return { valid: true };\n    }\n\n    /**\n     * Gère une action en l'envoyant aux plugins pertinents\n     */\n    handleAction(action: Action): void {\n        const validationResult = this.validateAction(action);\n        if (!validationResult.valid) {\n            console.warn(`Invalid action: ${validationResult.message}`);\n            return;\n        }\n\n        const sortedPlugins = Array.from(this.plugins.values())\n            .sort((a, b) => b.priority - a.priority);\n\n        for (const plugin of sortedPlugins) {\n            if (plugin.actionTypes === null || plugin.actionTypes.includes(action.type)) {\n                try {\n                    plugin.handler(action);\n                } catch (error) {\n                    console.error(`Error in plugin ${plugin.id}:`, error);\n                }\n            }\n        }\n    }\n\n    /**\n     * Exécute une action spécifique\n     */\n    executeAction(actionId: string, params: any): boolean {\n        const action = this.actionHandlers.get(actionId);\n        if (action?.handler) {\n            action.handler(params);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Récupère les actions disponibles pour un type de menu\n     */\n    getMenuActions(menuType: string): Array<{ id: string; handler: ActionHandler } & ActionMetadata> {\n        const actionIds = this.menuActionsByType.get(menuType) || new Set();\n        return Array.from(actionIds)\n            .map(id => {\n                const action = this.actionHandlers.get(id);\n                return action ? { id, ...action } : null;\n            })\n            .filter((action): action is { id: string; handler: ActionHandler } & ActionMetadata => \n                action !== null && action.metadata !== undefined\n            )\n            .sort((a, b) => (a.order || 0) - (b.order || 0));\n    }\n}\n\n// Export une instance singleton\nexport const actionRegistry = new ActionRegistry();\n\n// Export the class to allow custom instances\nexport { ActionRegistry };\n","import { IKarmycConfig } from '../../types/karmyc';\nimport { actionRegistry } from '../../actions/handlers/actionRegistry';\n\ninterface ICoreRegistry {\n    initialize: (config: IKarmycConfig) => void;\n}\n\nexport const coreRegistry: ICoreRegistry = {\n    initialize: (config: IKarmycConfig) => {\n        // Initialize actions\n        config.actions.plugins.forEach(plugin => {\n            actionRegistry.registerPlugin(plugin);\n        });\n\n        config.actions.validators.forEach(({ actionType, validator }) => {\n            actionRegistry.registerValidator(actionType, validator);\n        });\n    }\n}; \n","import React, { useCallback, useRef, useEffect, useMemo } from 'react';\n\nimport { useKarmycStore } from '../store';\nimport { Vec2 } from '../utils/vec2';\nimport { AreaRowLayout } from '../types/areaTypes'\nimport { AreaTypeValue } from '../types/actions'\nimport { getAreaToOpenPlacementInViewport, getHoveredAreaId } from '../utils/areaUtils';\n\n\n\ninterface UseAreaDragAndDropParams {\n    type?: AreaTypeValue;\n    id?: string;\n    state?: any;\n}\n\nconst useAreaDragAndDrop = (params?: UseAreaDragAndDropParams) => {\n    // Get actions and state selectors from Zustand store\n    const setAreaToOpenAction = useKarmycStore(state => state.setAreaToOpen);\n    const updateAreaToOpenPositionAction = useKarmycStore(state => state.updateAreaToOpenPosition);\n    const finalizeAreaPlacementAction = useKarmycStore(state => state.finalizeAreaPlacement);\n    const cleanupTemporaryStates = useKarmycStore(state => state.cleanupTemporaryStates);\n    const updateLayout = useKarmycStore(state => state.updateLayout);\n\n    // Select necessary state parts\n    const layout = useKarmycStore(state => state.screens[state.activeScreenId]?.areas.layout);\n    const rootId = useKarmycStore(state => state.screens[state.activeScreenId]?.areas.rootId);\n    const areas = useKarmycStore(state => state.screens[state.activeScreenId]?.areas.areas);\n    const areaToOpen = useKarmycStore(state => state.screens[state.activeScreenId]?.areas.areaToOpen);\n    const areaToViewport = useKarmycStore(state => state.screens[state.activeScreenId]?.areas.viewports);\n\n    const dragRef = useRef<{ startX: number; startY: number; sourceId: string | null } | null>(null);\n    const lastUpdateRef = useRef<number>(performance.now());\n    const rafRef = useRef<number | undefined>(undefined);\n    const isUpdatingRef = useRef(false);\n\n    const detectionDimensions = useMemo(() => Vec2.new(300, 200), []);\n\n    const areaToOpenTargetId = useMemo(() => {\n        if (!areaToOpen || !rootId || !areaToViewport || Object.keys(areaToViewport).length === 0) return null;\n        const currentPositionVec2 = Vec2.new(areaToOpen.position.x, areaToOpen.position.y);\n        return getHoveredAreaId(\n            currentPositionVec2,\n            { layout, rootId, areas, areaToOpen },\n            areaToViewport,\n            detectionDimensions\n        );\n    }, [areaToOpen?.position.x, areaToOpen?.position.y, layout, rootId, areas, areaToViewport, detectionDimensions]);\n\n    const areaToOpenTargetViewport = useMemo(() => {\n        return areaToOpenTargetId ? areaToViewport[areaToOpenTargetId] : null;\n    }, [areaToOpenTargetId, areaToViewport]);\n\n    const calculatedPlacement = useMemo(() => {\n        if (!areaToOpen || !areaToOpenTargetViewport) return 'stack';\n        const position = Vec2.new(areaToOpen.position.x, areaToOpen.position.y);\n        return getAreaToOpenPlacementInViewport(areaToOpenTargetViewport, position);\n    }, [areaToOpenTargetViewport, areaToOpen?.position.x, areaToOpen?.position.y, areaToOpen]);\n\n    const updatePosition = useCallback((x: number, y: number) => {\n        if (isUpdatingRef.current) return;\n        isUpdatingRef.current = true;\n\n        rafRef.current = requestAnimationFrame(() => {\n            updateAreaToOpenPositionAction({ x, y });\n            isUpdatingRef.current = false;\n        });\n    }, [updateAreaToOpenPositionAction]);\n\n    const globalDragOverHandler = useCallback((e: DragEvent) => {\n        e.preventDefault();\n        updatePosition(e.clientX, e.clientY);\n    }, [updatePosition]);\n\n    const handleDragStart = useCallback((e: React.DragEvent) => {\n        if (!params?.type || !params?.id || !params?.state) {\n            console.warn('useAreaDragAndDrop - Missing required params for handleDragStart');\n            return;\n        }\n        // Capture params here after the guard. They are now guaranteed to be defined.\n        const { type: areaType, id: areaId, state: areaState } = params;\n\n        // Prevent text selection during drag\n        document.body.style.userSelect = 'none';\n\n        const rect = e.currentTarget.getBoundingClientRect();\n        dragRef.current = {\n            startX: e.clientX - rect.left,\n            startY: e.clientY - rect.top,\n            sourceId: areaId\n        };\n        lastUpdateRef.current = performance.now();\n\n        // Create an invisible drag image\n        const dragImage = document.createElement('div');\n        dragImage.style.width = '1px';\n        dragImage.style.height = '1px';\n        dragImage.style.position = 'fixed';\n        dragImage.style.top = '-1px';\n        dragImage.style.left = '-1px';\n        dragImage.style.opacity = '0.01';\n        dragImage.style.pointerEvents = 'none';\n        document.body.appendChild(dragImage);\n\n        // Configure drag effect\n        e.dataTransfer.effectAllowed = 'move';\n        e.dataTransfer.setData('text/plain', JSON.stringify({\n            type: 'menubar',\n            areaType: areaType,\n            areaId: areaId\n        }));\n        e.dataTransfer.setDragImage(dragImage, 0, 0);\n\n        // Clean up drag image and then set area to open\n        requestAnimationFrame(() => {\n            if (document.body.contains(dragImage)) {\n                document.body.removeChild(dragImage);\n            }\n            // Initialize areaToOpen with the correct position AFTER dragImage is removed\n            setAreaToOpenAction({\n                position: {\n                    x: e.clientX,\n                    y: e.clientY\n                },\n                area: {\n                    type: areaType,\n                    state: { ...areaState, sourceId: areaId }\n                }\n            });\n        });\n\n        // Attach global listener\n        document.addEventListener('dragover', globalDragOverHandler);\n    }, [params, setAreaToOpenAction, globalDragOverHandler]);\n\n    const handleDragOver = useCallback((e: React.DragEvent) => {\n        // If it's a tab being reorganized, let AreaTabs.tsx handle it\n        if (e.dataTransfer.types.includes('karmyc/tab-drag-source')) {\n            // Don't call e.preventDefault() here to allow the event to \"bubble up\"\n            // to AreaTabs if needed, or be ignored by this element\n            return;\n        }\n        // For all other drag types (e.g. a new area from the menubar),\n        // handle dragOver as usual\n        e.preventDefault();\n        e.dataTransfer.dropEffect = 'move';\n    }, []);\n\n    const handleDrop = useCallback((e: React.DragEvent) => {\n        // If the drag source is a tab (for reorganization), AreaTabs.tsx should handle it\n        // Stop processing here to avoid conflicts or duplication\n        // First check if e.dataTransfer.getData was called without error\n        let sourceData;\n        try {\n            const dataString = e.dataTransfer.getData('text/plain');\n            if (dataString) {\n                sourceData = JSON.parse(dataString);\n            }\n        } catch (error) {\n            // Ignore error if getData fails (e.g. native file drag)\n            console.warn('[DropZone] handleDrop - Could not parse drag data', error);\n            cleanupTemporaryStates();\n            return;\n        }\n\n        if (sourceData && sourceData.type === 'tab') {\n            console.warn('[DropZone] handleDrop - Received \"tab\" type drag, assuming handled by AreaTabs. Aborting here.');\n            // It's important NOT to call e.preventDefault() or e.stopPropagation() here,\n            // to ensure that AreaTabs.tsx's handleDrop can execute\n            cleanupTemporaryStates(); // Clean up in case areaToOpen was activated by mistake\n            return;\n        }\n\n        // Rest of handleDrop logic for other data types...\n        e.preventDefault();\n        e.stopPropagation();\n\n        if (!sourceData) {\n            console.warn('[DropZone] handleDrop - Invalid or missing source data type after tab check');\n            cleanupTemporaryStates();\n            return;\n        }\n\n        const sourceAreaId = sourceData.areaId;\n        let targetAreaId: string | null = null;\n\n        const elementsUnderCursor = document.elementsFromPoint(e.clientX, e.clientY);\n\n        for (const element of elementsUnderCursor) {\n            if (element.classList.contains('global-drag-overlay') || element.classList.contains('areaToOpenContainer')) {\n                continue;\n            }\n            const areaElement = element.closest<HTMLElement>('[data-areaid]');\n\n            if (areaElement) {\n                const potentialTargetId = areaElement.dataset.areaid;\n\n                if (potentialTargetId && potentialTargetId !== '-1' && potentialTargetId !== sourceAreaId) {\n                    // Check if target area is a child of a stack\n                    const isChildOfStack = Object.values(layout).some(layoutItem =>\n                        layoutItem.type === 'area_row' &&\n                        layoutItem.orientation === 'stack' &&\n                        layoutItem.areas.some(area => area.id === potentialTargetId)\n                    );\n\n                    if (!isChildOfStack) {\n                        targetAreaId = potentialTargetId;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (!targetAreaId) {\n            console.warn('[DropZone] handleDrop: no targetAreaId found');\n            cleanupTemporaryStates();\n            return;\n        }\n\n        try {\n            updatePosition(e.clientX, e.clientY);\n\n            // Check if dropping on a stack in stack mode\n            const isStack = Object.values(layout).some(layoutItem =>\n                layoutItem.type === 'area_row' &&\n                layoutItem.orientation === 'stack' &&\n                layoutItem.id === targetAreaId\n            );\n\n            if (isStack && calculatedPlacement === 'stack') {\n                // Add area as a new tab in the stack\n                const stackLayout = Object.values(layout).find(layoutItem =>\n                    layoutItem.type === 'area_row' &&\n                    layoutItem.orientation === 'stack' &&\n                    layoutItem.id === targetAreaId\n                ) as AreaRowLayout;\n\n                if (stackLayout) {\n                    // Find source area in layout\n                    const sourceRow = Object.values(layout).find(layoutItem =>\n                        layoutItem.type === 'area_row' &&\n                        layoutItem.areas.some(area => area.id === sourceAreaId)\n                    ) as AreaRowLayout;\n\n                    if (sourceRow) {\n                        // Remove source area from its row\n                        const updatedSourceAreas = sourceRow.areas.filter(area => area.id !== sourceAreaId);\n\n                        // Redistribute sizes of remaining areas\n                        const totalSize = updatedSourceAreas.reduce((sum, area) => sum + area.size, 0);\n                        const normalizedAreas = updatedSourceAreas.map(area => ({\n                            ...area,\n                            size: totalSize > 0 ? area.size / totalSize : 1 / updatedSourceAreas.length\n                        }));\n\n                        // Update source row layout\n                        updateLayout({\n                            ...sourceRow,\n                            areas: normalizedAreas\n                        });\n                    }\n\n                    // Update stack layout\n                    const updatedLayout = {\n                        ...stackLayout,\n                        areas: [...stackLayout.areas, { id: sourceAreaId, size: 1 }]\n                    };\n                    updateLayout(updatedLayout);\n                    // Lock area that was just dropped into the stack\n                    useKarmycStore.getState().updateArea({ id: sourceAreaId, isLocked: true });\n                    cleanupTemporaryStates();\n                }\n            } else {\n                // If creating a new stack, lock both areas\n                if (calculatedPlacement === 'stack') {\n                    useKarmycStore.getState().updateArea({ id: sourceAreaId, isLocked: true });\n                    useKarmycStore.getState().updateArea({ id: targetAreaId, isLocked: true });\n                }\n                finalizeAreaPlacementAction({ targetId: targetAreaId, placement: calculatedPlacement });\n                cleanupTemporaryStates();\n            }\n        } catch (error) {\n            console.error('[DropZone] handleDrop - Error during finalization:', error);\n            cleanupTemporaryStates();\n        }\n\n    }, [cleanupTemporaryStates, finalizeAreaPlacementAction, updatePosition, calculatedPlacement, layout, updateLayout]);\n\n    const handleDragEnd = useCallback(() => {\n        // Reactivate text selection at the end of the drag\n        document.body.style.userSelect = '';\n\n        if (!dragRef.current) return;\n\n        if (rafRef.current) {\n            cancelAnimationFrame(rafRef.current);\n        }\n\n        // Check if the drag lasted long enough\n        const dragDuration = performance.now() - lastUpdateRef.current;\n        if (dragDuration < 100) {\n            return;\n        }\n\n        dragRef.current = null;\n        cleanupTemporaryStates();\n\n        // Detach global listener\n        document.removeEventListener('dragover', globalDragOverHandler);\n    }, [cleanupTemporaryStates, globalDragOverHandler]);\n\n    // Cleanup RAF on unmount\n    useEffect(() => {\n        return () => {\n            if (rafRef.current) {\n                cancelAnimationFrame(rafRef.current);\n            }\n        };\n    }, []);\n\n    return {\n        handleDragStart,\n        handleDragOver,\n        handleDragEnd,\n        handleDrop,\n        areaToOpenTargetId,\n        areaToOpenTargetViewport,\n        calculatedPlacement\n    };\n};\n\nexport default useAreaDragAndDrop; \n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nconst toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\nconst toCamelCase = (string) => string.replace(\n  /^([A-Z])|[\\s-_]+(\\w)/g,\n  (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()\n);\nconst toPascalCase = (string) => {\n  const camelCase = toCamelCase(string);\n  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);\n};\nconst mergeClasses = (...classes) => classes.filter((className, index, array) => {\n  return Boolean(className) && className.trim() !== \"\" && array.indexOf(className) === index;\n}).join(\" \").trim();\nconst hasA11yProp = (props) => {\n  for (const prop in props) {\n    if (prop.startsWith(\"aria-\") || prop === \"role\" || prop === \"title\") {\n      return true;\n    }\n  }\n};\n\nexport { hasA11yProp, mergeClasses, toCamelCase, toKebabCase, toPascalCase };\n//# sourceMappingURL=utils.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nvar defaultAttributes = {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  width: 24,\n  height: 24,\n  viewBox: \"0 0 24 24\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 2,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\"\n};\n\nexport { defaultAttributes as default };\n//# sourceMappingURL=defaultAttributes.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport { forwardRef, createElement } from 'react';\nimport defaultAttributes from './defaultAttributes.js';\nimport { mergeClasses, hasA11yProp } from './shared/src/utils.js';\n\nconst Icon = forwardRef(\n  ({\n    color = \"currentColor\",\n    size = 24,\n    strokeWidth = 2,\n    absoluteStrokeWidth,\n    className = \"\",\n    children,\n    iconNode,\n    ...rest\n  }, ref) => createElement(\n    \"svg\",\n    {\n      ref,\n      ...defaultAttributes,\n      width: size,\n      height: size,\n      stroke: color,\n      strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n      className: mergeClasses(\"lucide\", className),\n      ...!children && !hasA11yProp(rest) && { \"aria-hidden\": \"true\" },\n      ...rest\n    },\n    [\n      ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),\n      ...Array.isArray(children) ? children : [children]\n    ]\n  )\n);\n\nexport { Icon as default };\n//# sourceMappingURL=Icon.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport { forwardRef, createElement } from 'react';\nimport { mergeClasses, toKebabCase, toPascalCase } from './shared/src/utils.js';\nimport Icon from './Icon.js';\n\nconst createLucideIcon = (iconName, iconNode) => {\n  const Component = forwardRef(\n    ({ className, ...props }, ref) => createElement(Icon, {\n      ref,\n      iconNode,\n      className: mergeClasses(\n        `lucide-${toKebabCase(toPascalCase(iconName))}`,\n        `lucide-${iconName}`,\n        className\n      ),\n      ...props\n    })\n  );\n  Component.displayName = toPascalCase(iconName);\n  return Component;\n};\n\nexport { createLucideIcon as default };\n//# sourceMappingURL=createLucideIcon.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"rect\", { x: \"2\", y: \"4\", width: \"20\", height: \"16\", rx: \"2\", key: \"izxlao\" }],\n  [\"path\", { d: \"M10 4v4\", key: \"pp8u80\" }],\n  [\"path\", { d: \"M2 8h20\", key: \"d11cs7\" }],\n  [\"path\", { d: \"M6 4v4\", key: \"1svtjw\" }]\n];\nconst AppWindow = createLucideIcon(\"app-window\", __iconNode);\n\nexport { __iconNode, AppWindow as default };\n//# sourceMappingURL=app-window.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [[\"path\", { d: \"M15 6v6h4l-7 7-7-7h4V6h6z\", key: \"1thax2\" }]];\nconst ArrowBigDown = createLucideIcon(\"arrow-big-down\", __iconNode);\n\nexport { __iconNode, ArrowBigDown as default };\n//# sourceMappingURL=arrow-big-down.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"rect\", { width: \"14\", height: \"14\", x: \"8\", y: \"8\", rx: \"2\", ry: \"2\", key: \"17jyea\" }],\n  [\"path\", { d: \"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2\", key: \"zix9uf\" }]\n];\nconst Copy = createLucideIcon(\"copy\", __iconNode);\n\nexport { __iconNode, Copy as default };\n//# sourceMappingURL=copy.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"circle\", { cx: \"12\", cy: \"12\", r: \"1\", key: \"41hilf\" }],\n  [\"circle\", { cx: \"12\", cy: \"5\", r: \"1\", key: \"gxeob9\" }],\n  [\"circle\", { cx: \"12\", cy: \"19\", r: \"1\", key: \"lyex9k\" }]\n];\nconst EllipsisVertical = createLucideIcon(\"ellipsis-vertical\", __iconNode);\n\nexport { __iconNode, EllipsisVertical as default };\n//# sourceMappingURL=ellipsis-vertical.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"circle\", { cx: \"12\", cy: \"12\", r: \"1\", key: \"41hilf\" }],\n  [\"circle\", { cx: \"19\", cy: \"12\", r: \"1\", key: \"1wjl8i\" }],\n  [\"circle\", { cx: \"5\", cy: \"12\", r: \"1\", key: \"1pcz8c\" }]\n];\nconst Ellipsis = createLucideIcon(\"ellipsis\", __iconNode);\n\nexport { __iconNode, Ellipsis as default };\n//# sourceMappingURL=ellipsis.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"M15 3h6v6\", key: \"1q9fwt\" }],\n  [\"path\", { d: \"M10 14 21 3\", key: \"gplh6r\" }],\n  [\"path\", { d: \"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\", key: \"a6xqqp\" }]\n];\nconst ExternalLink = createLucideIcon(\"external-link\", __iconNode);\n\nexport { __iconNode, ExternalLink as default };\n//# sourceMappingURL=external-link.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z\", key: \"1rqfz7\" }],\n  [\"path\", { d: \"M14 2v4a2 2 0 0 0 2 2h4\", key: \"tnqrlb\" }],\n  [\"path\", { d: \"M12 18v-6\", key: \"17g6i2\" }],\n  [\"path\", { d: \"m9 15 3 3 3-3\", key: \"1npd3o\" }]\n];\nconst FileDown = createLucideIcon(\"file-down\", __iconNode);\n\nexport { __iconNode, FileDown as default };\n//# sourceMappingURL=file-down.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z\", key: \"1rqfz7\" }],\n  [\"path\", { d: \"M14 2v4a2 2 0 0 0 2 2h4\", key: \"tnqrlb\" }],\n  [\"path\", { d: \"M12 12v6\", key: \"3ahymv\" }],\n  [\"path\", { d: \"m15 15-3-3-3 3\", key: \"15xj92\" }]\n];\nconst FileUp = createLucideIcon(\"file-up\", __iconNode);\n\nexport { __iconNode, FileUp as default };\n//# sourceMappingURL=file-up.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\n    \"path\",\n    {\n      d: \"m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2\",\n      key: \"usdka0\"\n    }\n  ]\n];\nconst FolderOpen = createLucideIcon(\"folder-open\", __iconNode);\n\nexport { __iconNode, FolderOpen as default };\n//# sourceMappingURL=folder-open.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8\", key: \"1357e3\" }],\n  [\"path\", { d: \"M3 3v5h5\", key: \"1xhq8a\" }],\n  [\"path\", { d: \"M12 7v5l4 2\", key: \"1fdv2h\" }]\n];\nconst History = createLucideIcon(\"history\", __iconNode);\n\nexport { __iconNode, History as default };\n//# sourceMappingURL=history.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"rect\", { width: \"18\", height: \"11\", x: \"3\", y: \"11\", rx: \"2\", ry: \"2\", key: \"1w4ew1\" }],\n  [\"path\", { d: \"M7 11V7a5 5 0 0 1 9.9-1\", key: \"1mm8w8\" }]\n];\nconst LockOpen = createLucideIcon(\"lock-open\", __iconNode);\n\nexport { __iconNode, LockOpen as default };\n//# sourceMappingURL=lock-open.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"rect\", { width: \"18\", height: \"11\", x: \"3\", y: \"11\", rx: \"2\", ry: \"2\", key: \"1w4ew1\" }],\n  [\"path\", { d: \"M7 11V7a5 5 0 0 1 10 0v4\", key: \"fwvmzm\" }]\n];\nconst Lock = createLucideIcon(\"lock\", __iconNode);\n\nexport { __iconNode, Lock as default };\n//# sourceMappingURL=lock.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"M15 3h6v6\", key: \"1q9fwt\" }],\n  [\"path\", { d: \"m21 3-7 7\", key: \"1l2asr\" }],\n  [\"path\", { d: \"m3 21 7-7\", key: \"tjx5ai\" }],\n  [\"path\", { d: \"M9 21H3v-6\", key: \"wtvkvv\" }]\n];\nconst Maximize2 = createLucideIcon(\"maximize-2\", __iconNode);\n\nexport { __iconNode, Maximize2 as default };\n//# sourceMappingURL=maximize-2.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"m14 10 7-7\", key: \"oa77jy\" }],\n  [\"path\", { d: \"M20 10h-6V4\", key: \"mjg0md\" }],\n  [\"path\", { d: \"m3 21 7-7\", key: \"tjx5ai\" }],\n  [\"path\", { d: \"M4 14h6v6\", key: \"rmj7iw\" }]\n];\nconst Minimize2 = createLucideIcon(\"minimize-2\", __iconNode);\n\nexport { __iconNode, Minimize2 as default };\n//# sourceMappingURL=minimize-2.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"M5 12h14\", key: \"1ays0h\" }],\n  [\"path\", { d: \"M12 5v14\", key: \"s699le\" }]\n];\nconst Plus = createLucideIcon(\"plus\", __iconNode);\n\nexport { __iconNode, Plus as default };\n//# sourceMappingURL=plus.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7\", key: \"1m0v6g\" }],\n  [\n    \"path\",\n    {\n      d: \"M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z\",\n      key: \"ohrbg2\"\n    }\n  ]\n];\nconst SquarePen = createLucideIcon(\"square-pen\", __iconNode);\n\nexport { __iconNode, SquarePen as default };\n//# sourceMappingURL=square-pen.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"M3 6h18\", key: \"d0wm0j\" }],\n  [\"path\", { d: \"M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6\", key: \"4alrt4\" }],\n  [\"path\", { d: \"M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2\", key: \"v07s0e\" }]\n];\nconst Trash = createLucideIcon(\"trash\", __iconNode);\n\nexport { __iconNode, Trash as default };\n//# sourceMappingURL=trash.js.map\n","/**\n * @license lucide-react v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"M18 6 6 18\", key: \"1bl5f8\" }],\n  [\"path\", { d: \"m6 6 12 12\", key: \"d8bk6v\" }]\n];\nconst X = createLucideIcon(\"x\", __iconNode);\n\nexport { __iconNode, X as default };\n//# sourceMappingURL=x.js.map\n","// Dans karmyc/karmyc/packages/core/src/hooks/useRegisterActionHandler.ts\n\nimport { useEffect } from 'react';\nimport { actionRegistry } from './actionRegistry';\n\ninterface ActionMetadata {\n    // UI Metadata\n    menuType?: string;\n    label?: string;\n    icon?: string;\n    isEnabled?: () => boolean;\n    isVisible?: () => boolean;\n    order?: number;\n\n    // History Metadata\n    history?: {\n        enabled: boolean;           // If the action should be recorded in history\n        type: string;              // Action type for history (e.g. 'draw/addLine')\n        getDescription?: (params: any) => string;  // Function to generate the description\n        getPayload?: (params: any) => any;        // Function to extract the payload\n    };\n}\n\nexport function useRegisterActionHandler(\n    actionId: string, \n    handler: (params: any) => void,\n    metadata?: ActionMetadata\n) {\n    useEffect(() => {\n        actionRegistry.registerActionHandler(actionId, handler, metadata);\n        return () => {\n            actionRegistry.unregisterActionHandler(actionId);\n        };\n    }, [actionId, handler, metadata]);\n}\n","import { create } from 'zustand';\n\n// Interface pour le store de traduction\ninterface TranslationStore {\n    t: ((key: string, fallback: string) => string) | null;\n    setTranslationFunction: (t: (key: string, fallback: string) => string) => void;\n}\n\n// Création du store de traduction\nconst useTranslationStore = create<TranslationStore>((set) => ({\n    t: null,\n    setTranslationFunction: (t) => set({ t })\n}));\n\n/**\n * Custom hook to handle translations\n * @returns A translation function that uses the t function provided in the options or returns the fallback\n */\nexport const useTranslation = () => {\n    const { t } = useTranslationStore();\n\n    const translate = (key: string, fallback: string): string => {\n        if (t) {\n            return t(key, fallback);\n        }\n        return fallback;\n    };\n\n    return { t: translate };\n};\n\n/**\n * Fonction pour initialiser le système de traduction\n * @param t La fonction de traduction à utiliser\n */\nexport const initializeTranslation = (t: (key: string, fallback: string) => string) => {\n    useTranslationStore.getState().setTranslationFunction(t);\n}; \n","import React from 'react';\nimport { areaRegistry, useKarmycStore } from '../store';\nimport { AreaTypeValue, AREA_ROLE } from '../types/actions';\nimport { ControlledMenu } from '@szhsin/react-menu';\nimport { useContextMenuStore } from '../store/contextMenuStore';\nimport { useSpaceStore } from '../store/spaceStore';\nimport { useRegisterActionHandler } from '../actions/handlers/useRegisterActionHandler';\nimport { useTranslation } from '../hooks/useTranslation';\n\n// Récupère la map des rôles\nconst getRoleMap = () => (areaRegistry as any)._roleMap || {};\n\nexport const SwitchAreaTypeContextMenu: React.FC = () => {\n    const { t } = useTranslation();\n    const isVisible = useContextMenuStore((state) => state.isVisible && state.menuType === 'custom');\n    const position = useContextMenuStore((state) => state.position);\n    const closeContextMenu = useContextMenuStore((state) => state.closeContextMenu);\n    const targetId = useContextMenuStore((state) => state.targetId) || \"\";\n\n    const roleMap = getRoleMap();\n    const registeredTypes = Array.from(areaRegistry.getRegisteredTypes());\n    const spaces = useSpaceStore((state) => state.spaces);\n    const activeSpaceId = useSpaceStore((state) => state.activeSpaceId);\n\n    // Group types by role\n    const columns = [\n        { role: AREA_ROLE.LEAD, title: t('area.role.lead', 'LEAD'), items: [] as string[] },\n        { role: AREA_ROLE.FOLLOW, title: t('area.role.follow', 'FOLLOW'), items: [] as string[] },\n        { role: AREA_ROLE.SELF, title: t('area.role.self', 'SELF'), items: [] as string[] },\n    ];\n    registeredTypes.forEach(type => {\n        const role = roleMap[type] || AREA_ROLE.SELF;\n        const col = columns.find(c => c.role === role);\n        if (col) col.items.push(type);\n    });\n\n    const handleChangeType = (newType: AreaTypeValue) => {\n        useKarmycStore.getState().updateArea({ id: targetId, type: newType });\n        if (closeContextMenu) closeContextMenu();\n    };\n\n    const handleSetSpace = (spaceId: string) => {\n        useKarmycStore.getState().updateArea({ id: targetId, spaceId });\n        if (closeContextMenu) closeContextMenu();\n    };\n\n    useRegisterActionHandler('switch-area-type', (params) => {\n        if (params?.areaId && params?.newType) {\n            // Logic for changing area type\n            console.log(t('area.switch.log', `Switching area ${params.areaId} to type ${params.newType}`));\n        }\n    });\n\n    return (\n        <ControlledMenu\n            anchorPoint={position}\n            state={isVisible ? 'open' : 'closed'}\n            onClose={closeContextMenu}\n            transition\n            direction=\"right\"\n            menuClassName={'switch-area-type-context-menu'}\n        >\n            {columns.map(col => (\n                <div key={col.role} style={{ flex: 1, margin: '0 8px', width: '250px' }}>\n                    <div style={{ padding: '4px 0 16px', marginBottom: 8, textAlign: 'left', borderBottom: '2px ridge #444', paddingBottom: 4 }}>{col.title}</div>\n                    {col.items.map(type => {\n                        const Icon = areaRegistry.getIcon(type);\n                        return (\n                            <div\n                                key={type}\n                                style={{ display: 'flex', alignItems: 'center', gap: 8, cursor: 'pointer', marginBottom: 4 }}\n                                onClick={() => handleChangeType(type)}\n                                onMouseDown={e => e.preventDefault()}\n                            >\n                                <Icon style={{ width: 16, height: 16 }} />\n                                {t(`area.type.${type}`, areaRegistry.getDisplayName(type))}\n                            </div>\n                        )\n                    })}\n                    {col.role === AREA_ROLE.LEAD && (\n                        <>\n                            <div style={{ padding: '4px 0 16px', marginTop: 16, marginBottom: 8, textAlign: 'left', borderBottom: '2px ridge #444', paddingBottom: 4 }}>{t('area.spaces.title', 'SPACES')}</div>\n                            {Object.entries(spaces).map(([spaceId, space]) => (\n                                <div\n                                    key={spaceId}\n                                    data-testid=\"space-switch-button\"\n                                    style={{ \n                                        display: 'flex', \n                                        alignItems: 'center', \n                                        gap: 8, \n                                        cursor: 'pointer', \n                                        marginBottom: 4,\n                                        backgroundColor: spaceId === activeSpaceId ? 'rgba(255, 255, 255, 0.1)' : 'transparent',\n                                        padding: '4px 8px',\n                                        borderRadius: 4\n                                    }}\n                                    onClick={() => handleSetSpace(spaceId)}\n                                    onMouseDown={e => e.preventDefault()}\n                                >\n                                    <div style={{ \n                                        width: 12, \n                                        height: 12, \n                                        borderRadius: '50%', \n                                        backgroundColor: space.sharedState?.color || '#666' \n                                    }} />\n                                    {t(`space.${spaceId}.name`, space.name)}\n                                </div>\n                            ))}\n                        </>\n                    )}\n                </div>\n            ))}\n        </ControlledMenu>\n    );\n};\n","import { createElement, useRef, useState } from \"react\";\nimport { AreaTypeValue } from \"../../types/actions\";\nimport { useKarmycStore } from \"../../store/areaStore\";\nimport { useContextMenuStore } from \"../../store/contextMenuStore\";\nimport { TOOLBAR_HEIGHT } from \"../../utils/constants\";\nimport { areaRegistry } from \"../../store/registries/areaRegistry\";\nimport { useSpaceStore } from \"../../store/spaceStore\";\nimport useAreaDragAndDrop from \"../../hooks/useAreaDragAndDrop\";\nimport { CopyIcon, LockIcon, LockOpenIcon, XIcon, Maximize2Icon, Minimize2Icon } from \"lucide-react\";\nimport { SwitchAreaTypeContextMenu } from '../SwitchAreatypeContextMenu';\nimport { useTranslation } from \"../../hooks/useTranslation\";\n\ninterface IAreaDragButton {\n    state: any;\n    type: AreaTypeValue;\n    id: string;\n    style?: React.CSSProperties;\n}\n\nexport const AreaDragButton = ({ state, type, id, style }: IAreaDragButton) => {\n    const { t } = useTranslation();\n    const [isDragging, setIsDragging] = useState(false);\n    const updateArea = useKarmycStore(state => state.updateArea);\n    const isLocked = useKarmycStore(state => state.getAreaById(id)?.isLocked || false);\n    const manageableAreas = useKarmycStore(state => state.options?.manageableAreas ?? true);\n    const area = useKarmycStore(state => state.getAreaById(id));\n    const isFullscreen = area?.enableFullscreen ?? false;\n    const supportsFullscreen = (areaRegistry as any)._supportFullscreenMap?.[type] ?? false;\n\n    const {\n        handleDragStart,\n        handleDragOver,\n        handleDrop,\n        handleDragEnd\n    } = useAreaDragAndDrop({ type, id, state });\n\n    const openCustomContextMenu = useContextMenuStore((state) => state.openCustomContextMenu);\n\n    // Ref for the button\n    const selectAreaButtonRef = useRef<HTMLDivElement>(null);\n    // Ref for the parent element containing the area\n\n    const openSelectArea = () => {\n        if (!manageableAreas) return;\n        if (selectAreaButtonRef.current) {\n            const rect = selectAreaButtonRef.current.getBoundingClientRect();\n            openCustomContextMenu({\n                targetId: id,\n                position: { x: rect.left, y: rect.top },\n                component: (\n                    <SwitchAreaTypeContextMenu />\n                )\n            });\n        }\n    };\n\n    const space = useSpaceStore(state => state.getSpaceById(area?.spaceId || ''));\n\n    // If FOLLOW, use the color from the last selected LEAD space\n    let spaceColor = space?.sharedState?.color || '#0000ff';\n    if (area?.role === 'FOLLOW') {\n        const activeScreenId = useKarmycStore.getState().activeScreenId;\n        const lastLeadAreaId = useKarmycStore.getState().screens[activeScreenId]?.areas.lastLeadAreaId;\n        const allAreas = useKarmycStore.getState().screens[activeScreenId]?.areas.areas || {};\n        const leadArea = lastLeadAreaId ? allAreas[lastLeadAreaId] : null;\n        const leadSpaceId = leadArea?.spaceId;\n        if (leadSpaceId) {\n            const leadSpace = useSpaceStore.getState().spaces[leadSpaceId];\n            if (leadSpace && leadSpace.sharedState?.color) {\n                spaceColor = leadSpace.sharedState.color;\n            }\n        }\n    }\n\n    const handleDetach = (e: React.MouseEvent) => {\n        if (!manageableAreas) return;\n        e.stopPropagation();\n        useKarmycStore.getState().detachArea(id);\n    };\n\n    const handleClose = (e: React.MouseEvent) => {\n        if (!manageableAreas) return;\n        e.stopPropagation();\n        useKarmycStore.getState().removeArea(id);\n    };\n\n    const handleToggleFullscreen = (e: React.MouseEvent) => {\n        if (!manageableAreas) return;\n        e.stopPropagation();\n\n        // Find the parent element containing the area\n        const areaContainer = document.querySelector(`[data-areaid=\"${id}\"]`);\n        if (!areaContainer) return;\n\n        if (!isFullscreen) {\n            // Save current state before going fullscreen\n            const currentLayout = useKarmycStore.getState().screens[useKarmycStore.getState().activeScreenId]?.areas.layout;\n            const currentRootId = useKarmycStore.getState().screens[useKarmycStore.getState().activeScreenId]?.areas.rootId;\n            \n            // Update area with previous state\n            updateArea({ \n                id, \n                enableFullscreen: true,\n                previousLayout: currentLayout,\n                previousRootId: currentRootId\n            });\n\n            // Enter fullscreen mode\n            if (areaContainer.requestFullscreen) {\n                areaContainer.requestFullscreen();\n            } else if ((areaContainer as any).webkitRequestFullscreen) {\n                (areaContainer as any).webkitRequestFullscreen();\n            } else if ((areaContainer as any).msRequestFullscreen) {\n                (areaContainer as any).msRequestFullscreen();\n            }\n\n            // Add listener for fullscreen exit\n            const handleFullscreenChange = () => {\n                if (!document.fullscreenElement && \n                    !(document as any).webkitFullscreenElement && \n                    !(document as any).msFullscreenElement) {\n                    // Update area\n                    updateArea({ \n                        id, \n                        enableFullscreen: false,\n                        previousLayout: undefined,\n                        previousRootId: undefined\n                    });\n                    // Clean up listener\n                    document.removeEventListener('fullscreenchange', handleFullscreenChange);\n                    document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);\n                    document.removeEventListener('msfullscreenchange', handleFullscreenChange);\n                }\n            };\n\n            document.addEventListener('fullscreenchange', handleFullscreenChange);\n            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);\n            document.addEventListener('msfullscreenchange', handleFullscreenChange);\n        } else {\n            // Exit fullscreen mode\n            if (document.exitFullscreen) {\n                document.exitFullscreen();\n            } else if ((document as any).webkitExitFullscreen) {\n                (document as any).webkitExitFullscreen();\n            } else if ((document as any).msExitFullscreen) {\n                (document as any).msExitFullscreen();\n            }\n\n            // Update area\n            updateArea({ \n                id, \n                enableFullscreen: false,\n                previousLayout: undefined,\n                previousRootId: undefined\n            });\n        }\n    };\n\n    return (\n        <div\n            className=\"select-area-button\"\n            draggable={manageableAreas && !isLocked && !isFullscreen}\n            title={t('area.drag', 'Move area')}\n            onDragStart={e => {\n                if (!manageableAreas || isFullscreen) return;\n                setIsDragging(true);\n                handleDragStart(e);\n                // Completely disable the button during drag, asynchronously\n                requestAnimationFrame(() => {\n                    if (selectAreaButtonRef.current) {\n                        selectAreaButtonRef.current.style.pointerEvents = 'none';\n                        selectAreaButtonRef.current.style.opacity = '0.5';\n                    }\n                });\n            }}\n            onDragOver={e => {\n                if (!manageableAreas || isFullscreen) return;\n                handleDragOver(e);\n            }}\n            onDrop={e => {\n                if (!manageableAreas || isFullscreen) return;\n                if (!isDragging) {\n                    handleDrop(e);\n                }\n            }}\n            onDragEnd={() => {\n                if (!manageableAreas || isFullscreen) return;\n                setIsDragging(false);\n                selectAreaButtonRef.current!.style.pointerEvents = 'auto';\n                selectAreaButtonRef.current!.style.opacity = '1';\n                handleDragEnd();\n            }}\n            onContextMenu={e => { \n                if (!manageableAreas || isFullscreen) return;\n                e.preventDefault(); \n                openSelectArea(); \n            }}\n            style={{\n                cursor: !manageableAreas || isFullscreen ? 'default' : isLocked ? 'default' : isDragging ? 'grabbing' : 'grab',\n                '--space-color': spaceColor,\n                pointerEvents: 'auto',\n                height: TOOLBAR_HEIGHT + 'px',\n                ...style\n            } as React.CSSProperties}\n            ref={selectAreaButtonRef}\n        >\n            <div className=\"select-area-button__main\">\n                {createElement(areaRegistry.getIcon(type), { className: 'select-area-button__icon', style: { color: spaceColor } })}\n                {areaRegistry.getDisplayName(type)}\n            </div>\n            <div className=\"select-area-button__action-icons\">\n                {manageableAreas && !isLocked &&\n                    <>\n                        <button\n                            className=\"select-area-icons select-area-button__detach\"\n                            onClick={handleDetach}\n                            title={t('area.detach', 'Detach area')}>\n                            <CopyIcon />\n                        </button>\n                        <button\n                            className=\"select-area-icons select-area-button__close\"\n                            onClick={handleClose}\n                            title={t('area.close', 'Close area')}>\n                            <XIcon />\n                        </button>\n                    </>\n                }\n                {manageableAreas &&\n                    <>\n                        {supportsFullscreen && (\n                            <button\n                                className=\"select-area-icons select-area-button__fullscreen\"\n                                onClick={handleToggleFullscreen}\n                                title={t('area.fullscreen', 'Toggle fullscreen')}\n                            >\n                                {isFullscreen ? <Minimize2Icon /> : <Maximize2Icon />}\n                            </button>\n                        )}\n                        <button\n                            className={`select-area-icons select-area-button__lock-icon ${isLocked ? 'locked' : ''}`}\n                            onClick={(e) => {\n                                e.stopPropagation();\n                                updateArea({ id, isLocked: !isLocked });\n                            }}\n                            title={t('area.lock', 'Lock/Unlock area')}\n                        >\n                            {isLocked ? <LockIcon /> : <LockOpenIcon />}\n                        </button>\n                    </>\n                }\n            </div>\n        </div>\n    );\n};\n\nexport default AreaDragButton;\n","import React, { useState } from 'react';\nimport { IArea, AreaRowLayout } from '../types/areaTypes';\nimport { useKarmycStore } from '../store/areaStore';\nimport { AreaDragButton } from './handlers/AreaDragButton';\nimport { useSpaceStore } from '../store/spaceStore';\n\ninterface AreaTabsProps {\n    rowId: string;\n    row: AreaRowLayout;\n    areas: Record<string, IArea>;\n}\n\nexport const AreaTabs: React.FC<AreaTabsProps> = React.memo(({ rowId, row, areas }) => {\n    const updateLayout = useKarmycStore(state => state.updateLayout);\n    const setActiveArea = useKarmycStore(state => state.setActiveArea);\n\n    // State for drop position indicator\n    const [dragIndicator, setDragIndicator] = useState<{ targetId: string | null, position: 'before' | 'after' | null }>({ targetId: null, position: null });\n    // State for currently dragged tab\n    const [draggingTabId, setDraggingTabId] = useState<string | null>(null);\n\n    const handleTabClick = (areaId: string) => {\n        const area = areas[areaId];\n        if (!area) return;\n\n        // First update the layout to change the active tab\n        updateLayout({ id: rowId, activeTabId: areaId });\n        // Then update the active area\n        setActiveArea(areaId);\n\n        // If the area has a space, switch to MANUAL mode and update the active space\n        if (area.spaceId) {\n            useSpaceStore.getState().setActiveSpace(area.spaceId);\n        }\n    };\n\n    // Drag & drop for tab reorganization\n    const handleTabDragStart = (e: React.DragEvent, areaId: string) => {\n        // area.isLocked is true here, so this is a drag for tab reorganization\n        e.stopPropagation(); // Prevents AreaDragButton/useAreaDragAndDrop from interfering\n        setDraggingTabId(areaId); // Mark this tab as being dragged\n        \n        e.dataTransfer.setData('text/plain', JSON.stringify({\n            type: 'tab',\n            areaId,\n            sourceRowId: rowId\n        }));\n        e.dataTransfer.setData('karmyc/tab-drag-source', 'true'); // Marqueur spécifique pour dragOver\n        e.dataTransfer.effectAllowed = 'move';\n    };\n\n    const handleTabDragOver = (e: React.DragEvent, overAreaId: string) => {\n        if (e.dataTransfer.types.includes('karmyc/tab-drag-source')) {\n            e.preventDefault();\n            e.dataTransfer.dropEffect = 'move';\n\n            const targetElement = e.currentTarget as HTMLElement;\n            const rect = targetElement.getBoundingClientRect();\n            const midPoint = rect.left + rect.width / 2;\n            const position = e.clientX < midPoint ? 'before' : 'after';\n\n            // Avoid unnecessary state updates if the indicator is already correct\n            if (dragIndicator.targetId !== overAreaId || dragIndicator.position !== position) {\n                setDragIndicator({ targetId: overAreaId, position });\n            }\n        }\n    };\n\n    // Reset the indicator when drag leaves the tabs area\n    const handleTabsContainerDragLeave = (e: React.DragEvent) => {\n        // Check if the relatedTarget is outside the tabs container\n        if (!(e.currentTarget as HTMLElement).contains(e.relatedTarget as Node)) {\n            setDragIndicator({ targetId: null, position: null });\n        }\n    };\n\n    const handleTabDrop = (e: React.DragEvent, onDropAreaId: string) => {\n        try {\n            const dataString = e.dataTransfer.getData('text/plain');\n            if (!dataString) {\n                setDragIndicator({ targetId: null, position: null });\n                return;\n            }\n            const data = JSON.parse(dataString);\n\n            if (data.type === 'tab' && data.sourceRowId === rowId) {\n                e.preventDefault();\n                e.stopPropagation();\n\n                const sourceAreaId = data.areaId;\n                const { targetId: indicatedTargetId, position: indicatedPosition } = dragIndicator;\n\n                // If we drop the source on itself without clear intention to move (via indicator),\n                // or if the dragged tab is not the one indicated (e.g., desynchronized indicator)\n                if (sourceAreaId === onDropAreaId && indicatedTargetId !== onDropAreaId) {\n                    setDragIndicator({ targetId: null, position: null });\n                    return;\n                }\n                // If we drop the source on itself and the indicator doesn't show a position change\n                if (sourceAreaId === onDropAreaId && indicatedTargetId === onDropAreaId && indicatedPosition === null) {\n                    setDragIndicator({ targetId: null, position: null });\n                    return;\n                }\n\n                const workingAreas = [...row.areas];\n                const sourceIndex = workingAreas.findIndex(a => a.id === sourceAreaId);\n                const onDropAreaOriginalIndex = row.areas.findIndex(a => a.id === onDropAreaId);\n\n                if (sourceIndex === -1 || onDropAreaOriginalIndex === -1) {\n                    setDragIndicator({ targetId: null, position: null });\n                    return; // Source or target not found (shouldn't happen)\n                }\n                \n                const [movedArea] = workingAreas.splice(sourceIndex, 1); // Remove the source element\n\n                // Calculate the target index in the modified array (after source removal)\n                let targetIndexInModifiedArray = onDropAreaOriginalIndex;\n                if (sourceIndex < onDropAreaOriginalIndex) {\n                    targetIndexInModifiedArray--; \n                }\n                // If sourceIndex === onDropAreaOriginalIndex, then we're dropping on the source's original position\n                // targetIndexInModifiedArray will be the index of the element that took the source's place (or sourceIndex if it was the last one)\n                // If we drop on the source itself, targetIndexInModifiedArray is the index where the source *would be* if it wasn't moved\n                if (sourceAreaId === onDropAreaId) {\n                    targetIndexInModifiedArray = sourceIndex; // Insertion will be relative to the source's original position\n                }\n\n                let finalInsertionIndex = targetIndexInModifiedArray;\n                // Use the indicator to determine if we insert before or after the target\n                if (indicatedTargetId === onDropAreaId && indicatedPosition === 'after') {\n                    finalInsertionIndex = targetIndexInModifiedArray + 1;\n                }\n                // If indicatedPosition === 'before', finalInsertionIndex is already correct (targetIndexInModifiedArray)\n                // If the indicator is not on onDropAreaId (e.g., dragLeave then quick drop),\n                // we insert by default before onDropAreaId\n\n                workingAreas.splice(finalInsertionIndex, 0, movedArea);\n                \n                updateLayout({ \n                    id: rowId, \n                    areas: workingAreas,\n                    activeTabId: row.activeTabId // Preserve the active tab\n                });\n            }\n        } catch (error) {\n            console.error('Error handling tab drop:', error);\n        }\n        // Always reset the indicator after drop or in case of error\n        setDragIndicator({ targetId: null, position: null });\n        // And the currently dragged tab, as the drag is finished\n        setDraggingTabId(null);\n    };\n\n    // Handle drag end (if drop didn't occur on a valid target or was cancelled)\n    const handleTabDragEnd = () => {\n        setDraggingTabId(null);\n        setDragIndicator({ targetId: null, position: null });\n    };\n\n        return (\n        <div className=\"area-tabs\" onDragLeave={handleTabsContainerDragLeave}>\n            {row.areas.map(({ id }) => {\n                const area = areas[id];\n\n                if (!area) return null;\n\n                const isActive = row.activeTabId === id;\n                const isDragTarget = dragIndicator.targetId === id;\n                const indicatorClass = isDragTarget ? `drop-indicator-${dragIndicator.position}` : '';\n                const isDraggingSource = draggingTabId === id;\n\n                return (\n                    <div\n                        key={id}\n                        className={`area-tab ${isActive ? 'area-tab--active' : ''} ${indicatorClass} ${isDraggingSource ? 'is-dragging-source' : ''}`}\n                        onClick={() => handleTabClick(id)}\n                        draggable={area.isLocked} // Draggable only if locked for internal reorganization\n                        onDragStart={e => area.isLocked ? handleTabDragStart(e, id) : undefined}\n                        onDragOver={e => handleTabDragOver(e, id)} // Pass the hovered tab id\n                        onDrop={e => handleTabDrop(e, id)}\n                        onDragEnd={handleTabDragEnd} // Add the onDragEnd handler\n                        data-areaid={id}\n                    >\n                        <AreaDragButton id={id} state={area.state} type={area.type} />\n                    </div>\n                );\n            })}\n        </div>\n    );\n}); \n","import { Dispatch, SetStateAction } from 'react'; \nimport { capToRange, Vec2 } from \"../../utils\";\nimport { AREA_MIN_CONTENT_WIDTH } from \"../../utils/constants\";\nimport { useKarmycStore } from \"../../store/areaStore\"; \nimport { AreaRowLayout } from \"../../types/areaTypes\";\nimport { CardinalDirection, IntercardinalDirection } from \"../../types/directions\";\nimport type { Rect } from \"../../types\";\nimport { computeAreaToParentRow } from \"../../utils/areaToParentRow\";\nimport { computeAreaToViewport } from \"../../utils/areaToViewport\";\nimport { getAreaRootViewport } from \"../../utils/getAreaViewport\";\n\ninterface ResizePreviewState {\n    rowId: string;\n    separatorIndex: number;\n    t: number;\n}\n\n\n// Function to determine if the movement is toward the inside of the area\nfunction determineIfMovingInwards(corner: IntercardinalDirection, moveVec: Vec2): boolean {\n    // For purely horizontal or vertical movements, we consider the main direction\n    const absX = Math.abs(moveVec.x);\n    const absY = Math.abs(moveVec.y);\n    const isMainlyHorizontal = absX > absY;\n    const isMainlyVertical = absY > absX;\n\n    // If the movement is mainly horizontal, we only consider the x component\n    // If the movement is mainly vertical, we only consider the y component\n    if (isMainlyHorizontal) {\n        switch (corner) {\n        case \"ne\":\n        case \"se\":\n            return moveVec.x < 0; // Left = inward\n        case \"nw\":\n        case \"sw\":\n            return moveVec.x > 0; // Right = inward\n        }\n    } else if (isMainlyVertical) {\n        switch (corner) {\n        case \"ne\":\n        case \"nw\":\n            return moveVec.y > 0; // Down = inward\n        case \"se\":\n        case \"sw\":\n            return moveVec.y < 0; // Up = inward\n        }\n    }\n\n    // For diagonal movements, we use the previous logic\n    switch (corner) {\n    case \"ne\":\n        return moveVec.x < 0 && moveVec.y > 0;\n    case \"nw\":\n        return moveVec.x > 0 && moveVec.y > 0;\n    case \"se\":\n        return moveVec.x < 0 && moveVec.y < 0;\n    case \"sw\":\n        return moveVec.x > 0 && moveVec.y < 0;\n    default:\n        console.warn(\"Unknown corner direction in determineIfMovingInwards:\", corner);\n        return false;\n    }\n}\n\nexport const handleAreaDragFromCorner = (\n    e: MouseEvent,\n    corner: IntercardinalDirection,\n    areaId: string,\n    viewport: Rect, // Initial viewport of the dragged area\n    setResizePreview: Dispatch<SetStateAction<ResizePreviewState | null>>,\n    setAreaResizing: (resizing: boolean) => void\n) => {\n    // Check if we are in a detached window\n    const isDetached = useKarmycStore.getState().screens[useKarmycStore.getState().activeScreenId]?.areas.isDetached;\n    if (isDetached) {\n        return;\n    }\n\n    e.preventDefault();\n    setAreaResizing(true);\n\n    const initialMousePosition = Vec2.fromEvent(e);\n    let lastMousePosition: Vec2 = initialMousePosition;\n    // Store references to the currently active move/mouseup handlers\n    let currentOnMove: ((vec: Vec2) => void) | null = null;\n    let currentOnMouseUp: (() => void) | null = null;\n\n    // --- Helper to get fresh state for the ACTIVE SCREEN --- (Crucial change)\n    const getActiveScreenState = () => {\n        const rootState = useKarmycStore.getState();\n        return rootState.screens[rootState.activeScreenId]?.areas;\n    };\n\n    // --- Initial State Acquisition from ACTIVE SCREEN --- (Crucial change)\n    const initialActiveScreenState = getActiveScreenState();\n    if (!initialActiveScreenState) {\n        console.error(\"handleAreaDragFromCorner: Could not get active screen state.\");\n        setAreaResizing(false);\n        return;\n    }\n    const initialLayout = initialActiveScreenState.layout;\n    const initialRootId = initialActiveScreenState.rootId;\n\n    if (!initialRootId || !initialLayout || !initialLayout[initialRootId]) { // Check layout itself too\n        console.error(\"handleAreaDragFromCorner: Invalid initial active screen state (rootId or layout missing/invalid)\");\n        setAreaResizing(false);\n        return;\n    }\n\n    // Pass the active screen's layout and rootId\n    const areaToParentRowMap = computeAreaToParentRow(initialLayout);\n    const parentRowId = areaToParentRowMap[areaId];\n\n    // --- Function: createNewArea (Initiate Split) ---\n    function createNewArea(horizontal: boolean) {\n        const currentViewportSize = horizontal ? viewport.width : viewport.height;\n        const minRequiredSize = AREA_MIN_CONTENT_WIDTH * 2;\n        \n        if (currentViewportSize < minRequiredSize) {\n            setupJoinMoveHandlers();\n            if (currentOnMove) {\n                currentOnMove(lastMousePosition);\n            }\n            return;\n        }\n\n        // Get source area type and state\n        const sourceAreaData = useKarmycStore.getState().getAreaById(areaId);\n        if (!sourceAreaData) {\n            console.error(\"Source area data not found\");\n            setAreaResizing(false);\n            return;\n        }\n\n        // --- Perform State Updates using Zustand (Actions are on root store) ---\n        const splitResult = useKarmycStore.getState().splitArea({\n            areaIdToSplit: areaId,\n            parentRowId: parentRowId,\n            horizontal: horizontal,\n            corner: corner,\n        });\n\n        if (!splitResult || !splitResult.newRowId || splitResult.separatorIndex === undefined) {\n            console.error(\"Failed to split area or get split result info. Switching to join/move.\");\n            setupJoinMoveHandlers();\n            if (currentOnMove) {\n                currentOnMove(lastMousePosition);\n            }\n            return;\n        }\n\n        const { newRowId, separatorIndex } = splitResult;\n\n        // Wait for layout to be updated\n        const checkLayout = () => {\n            const currentActiveScreenStateAfterSplit = getActiveScreenState();\n            if (!currentActiveScreenStateAfterSplit) {\n                console.error(\"Failed to get active screen state after split\");\n                setAreaResizing(false);\n                return;\n            }\n            \n            const newRowLayout = currentActiveScreenStateAfterSplit.layout[newRowId] as AreaRowLayout;\n\n            if (!newRowLayout || newRowLayout.type !== 'area_row') {\n                console.error(`Split seemed successful but row ${newRowId} not found or not a row in active screen state.`);\n                setAreaResizing(false);\n                return;\n            }\n\n            // Check that areas have valid sizes\n            const hasValidSizes = newRowLayout.areas.every(area => area.size >= 0.1);\n            if (!hasValidSizes) {\n                console.error(\"Invalid sizes detected in new row layout\");\n                setAreaResizing(false);\n                return;\n            }\n\n            // Update new area type and state\n            const newAreaId = newRowLayout.areas[separatorIndex].id;\n            useKarmycStore.getState().updateArea({\n                id: newAreaId,\n                type: sourceAreaData.type,\n                state: { ...sourceAreaData.state }\n            });\n\n            // Update area sizes to be equal\n            const equalSizes = newRowLayout.areas.map(() => 1 / newRowLayout.areas.length);\n            useKarmycStore.getState().setRowSizes({ \n                rowId: newRowId, \n                sizes: equalSizes \n            });\n\n            setupResizeHandlers(newRowLayout, separatorIndex, setResizePreview);\n            if (currentOnMove) {\n                currentOnMove(lastMousePosition);\n            }\n        };\n\n        // Wait one tick to ensure layout is updated\n        setTimeout(checkLayout, 0);\n    }\n\n    // --- Function: setupResizeHandlers (After Split) ---\n    function setupResizeHandlers(\n        rowToResize: AreaRowLayout,\n        sepIndex: number,\n        setResizePreviewFn: Dispatch<SetStateAction<ResizePreviewState | null>>\n    ) {\n        const isHorizontalRow = rowToResize.orientation === 'horizontal';\n        const areaBeforeId = rowToResize.areas[sepIndex - 1]?.id;\n        const areaAfterId = rowToResize.areas[sepIndex]?.id;\n\n        if (!areaBeforeId || !areaAfterId) {\n            console.error(\"Cannot set up resize handlers: invalid separator index or missing areas.\", { rowToResize, sepIndex });\n            currentOnMove = null;\n            currentOnMouseUp = () => { setAreaResizing(false); };\n            return;\n        }\n\n        const initialSizes = rowToResize.areas.map(a => a.size);\n        const sizeToShare = initialSizes[sepIndex - 1] + initialSizes[sepIndex];\n\n        // Vérifier que la taille totale est valide\n        if (sizeToShare <= 0) {\n            console.error(\"Invalid total size for resize operation\");\n            currentOnMove = null;\n            currentOnMouseUp = () => { setAreaResizing(false); };\n            return;\n        }\n\n        // --- Debounce Logic --- similar to areaDragResize\n        let timeoutId: ReturnType<typeof setTimeout> | null = null;\n        const debounceDelay = 75; // ms\n        let lastT = 0.5; // Store last calculated t for final update\n\n        const performGlobalUpdate = (sizes: number[]) => {\n            // Vérifier que les tailles sont valides avant la mise à jour\n            const minSize = 0.1; // 10% minimum\n            const hasInvalidSizes = sizes.some(size => size < minSize);\n            \n            if (hasInvalidSizes) {\n                console.warn(\"Invalid sizes detected, adjusting to minimum values\");\n                // Ajuster les tailles pour respecter le minimum\n                const adjustedSizes = sizes.map(size => Math.max(size, minSize));\n                const total = adjustedSizes.reduce((sum, s) => sum + s, 0);\n                const normalizedSizes = adjustedSizes.map(s => s / total);\n                useKarmycStore.getState().setRowSizes({ rowId: rowToResize.id, sizes: normalizedSizes });\n            } else {\n                useKarmycStore.getState().setRowSizes({ rowId: rowToResize.id, sizes });\n            }\n        };\n\n        const triggerDebouncedUpdate = (sizes: number[]) => {\n            if (timeoutId !== null) {\n                clearTimeout(timeoutId);\n            }\n            timeoutId = setTimeout(() => {\n                timeoutId = null;\n                performGlobalUpdate(sizes);\n            }, debounceDelay);\n        };\n\n        const cancelDebouncedUpdate = () => {\n            if (timeoutId !== null) {\n                clearTimeout(timeoutId);\n                timeoutId = null;\n            }\n        };\n        // --- End Debounce Logic ---\n\n        currentOnMove = (vec: Vec2) => {\n            // Get FRESH ACTIVE screen state\n            const currentActiveState = getActiveScreenState();\n            if (!currentActiveState) return;\n            const currentLayout = currentActiveState.layout;\n            const currentRow = currentLayout[rowToResize.id] as AreaRowLayout;\n            const currentRootId = currentActiveState.rootId;\n\n            if (!currentRow || !currentRootId || currentRow.type !== 'area_row') {\n                console.warn(\"Resize handler: Row or rootId not found/invalid in current active screen state.\");\n                return;\n            }\n\n            // Use active screen layout/rootId for viewport calculation\n            const areaToViewportMap = computeAreaToViewport(\n                currentLayout,\n                currentRootId,\n                getAreaRootViewport()\n            );\n\n            const v0 = areaToViewportMap[areaBeforeId];\n            const v1 = areaToViewportMap[areaAfterId];\n\n            if (!v0 || !v1) {\n                console.warn(\"Resize handler: Viewports for adjacent areas not found.\");\n                return;\n            }\n\n            const sharedViewport: Rect = isHorizontalRow\n                ? { left: v0.left, top: v0.top, width: v0.width + v1.width, height: v0.height }\n                : { left: v0.left, top: v0.top, width: v0.width, height: v0.height + v1.height };\n\n            const viewportSize = isHorizontalRow ? sharedViewport.width : sharedViewport.height;\n            if (viewportSize <= 0) {\n                console.warn(\"Resize handler: Shared viewport size is zero or negative.\");\n                return;\n            }\n\n            const minT = Math.max(0.1, AREA_MIN_CONTENT_WIDTH / viewportSize); // Minimum 10%\n            const t0 = isHorizontalRow ? sharedViewport.left : sharedViewport.top;\n            const t1 = t0 + viewportSize;\n            const val = isHorizontalRow ? vec.x : vec.y;\n            const t = capToRange(minT, 1 - minT, (val - t0) / (t1 - t0));\n\n            // Store last t\n            lastT = t;\n\n            // 1. Update PREVIEW state IMMEDIATELY\n            setResizePreviewFn({\n                rowId: rowToResize.id,\n                separatorIndex: sepIndex,\n                t: t\n            });\n\n            // 2. Trigger DEBOUNCED global state update\n            const tempSize0 = t * sizeToShare;\n            const tempSize1 = (1 - t) * sizeToShare;\n            const tempSizes = currentRow.areas.map((area, index) => {\n                if (index === sepIndex - 1) return tempSize0;\n                if (index === sepIndex) return tempSize1;\n                return area.size;\n            });\n\n            // Vérifier que les tailles sont valides\n            const minSize = 0.1; // 10% minimum\n            const hasInvalidSizes = tempSizes.some(size => size < minSize);\n            \n            if (hasInvalidSizes) {\n                console.warn(\"Invalid sizes detected in preview, adjusting to minimum values\");\n                // Ajuster les tailles pour respecter le minimum\n                const adjustedSizes = tempSizes.map(size => Math.max(size, minSize));\n                const total = adjustedSizes.reduce((sum, s) => sum + s, 0);\n                const normalizedSizes = adjustedSizes.map(s => s / total);\n                triggerDebouncedUpdate(normalizedSizes);\n            } else {\n                const tempTotalSize = tempSizes.reduce((sum, s) => sum + s, 0);\n                if (tempTotalSize > 0) {\n                    const normalizedSizes = tempSizes.map(s => s / tempTotalSize);\n                    triggerDebouncedUpdate(normalizedSizes);\n                } else {\n                    console.warn(\"Resize handler: Debounce skipped, zero total size.\");\n                }\n            }\n        };\n\n        currentOnMouseUp = () => {\n            // 1. Cancel any pending debounced update\n            cancelDebouncedUpdate();\n\n            // 2. Calculate FINAL sizes based on lastT\n            const finalSize0 = lastT * sizeToShare;\n            const finalSize1 = (1 - lastT) * sizeToShare;\n\n            // Get the latest row state to construct the final sizes array correctly\n            const finalRowState = getActiveScreenState()?.layout[rowToResize.id] as AreaRowLayout;\n            if (!finalRowState || finalRowState.type !== 'area_row') {\n                console.error(\"Resize mouseup: Cannot find final row state.\");\n                setResizePreviewFn(null); // Attempt cleanup\n                setAreaResizing(false);\n                currentOnMove = null;\n                currentOnMouseUp = null;\n                return;\n            }\n\n            const finalSizes = finalRowState.areas.map((area, index) => {\n                if (index === sepIndex - 1) return finalSize0;\n                if (index === sepIndex) return finalSize1;\n                return area.size;\n            });\n\n            // Normalize final sizes\n            const finalTotalSize = finalSizes.reduce((sum, s) => sum + s, 0);\n            let finalNormalizedSizes = finalSizes;\n            if (finalTotalSize > 0) {\n                finalNormalizedSizes = finalSizes.map(s => s / finalTotalSize);\n            } else {\n                console.error(\"Resize mouseup: Final total size is zero, cannot normalize. Using equal distribution as fallback.\");\n                const count = finalRowState.areas.length;\n                finalNormalizedSizes = Array(count).fill(1 / count);\n            }\n\n            // 3. Update global state IMMEDIATELY with final sizes\n            performGlobalUpdate(finalNormalizedSizes);\n\n            // 4. Clean up preview state AFTER a tick\n            setTimeout(() => setResizePreviewFn(null), 0);\n\n            // 5. General cleanup\n            setAreaResizing(false);\n            currentOnMove = null;\n            currentOnMouseUp = null;\n        };\n    }\n\n    // --- Function: setupJoinMoveHandlers (If Split Fails or Area too Small) ---\n    function setupJoinMoveHandlers() {\n        // Find the parent row of the source area ONCE\n        const initialParentRow = parentRowId ? initialLayout[parentRowId] as AreaRowLayout : null;\n        if (!initialParentRow || initialParentRow.type !== 'area_row') {\n            console.error(\"Join/Move setup: Source area does not have a valid parent row. Cannot determine siblings.\");\n            // Cannot proceed with join logic without siblings\n            currentOnMove = null;\n            currentOnMouseUp = () => { setAreaResizing(false); useKarmycStore.getState().setJoinPreview(null); }; // Basic cleanup\n            return;\n        }\n        const sourceAreaIndex = initialParentRow.areas.findIndex(a => a.id === areaId);\n        if (sourceAreaIndex === -1) {\n            console.error(`Join/Move setup: Source area ${areaId} not found within its supposed parent row ${parentRowId}.`);\n            currentOnMove = null;\n            currentOnMouseUp = () => { setAreaResizing(false); useKarmycStore.getState().setJoinPreview(null); };\n            return;\n        }\n\n        // Determine the ACTUAL eligible siblings (all others in the same row, based on original logic)\n        const actualEligibleAreaIds = initialParentRow.areas\n            .filter((_, index) => index !== sourceAreaIndex)\n            .map(a => a.id);\n\n        // Identify IMMEDIATE siblings\n        const leftSiblingId = sourceAreaIndex > 0 ? initialParentRow.areas[sourceAreaIndex - 1].id : null;\n        const rightSiblingId = sourceAreaIndex < initialParentRow.areas.length - 1 ? initialParentRow.areas[sourceAreaIndex + 1].id : null;\n        const immediateSiblings = [leftSiblingId, rightSiblingId].filter(id => id !== null) as string[];\n\n        currentOnMove = (vec: Vec2) => {\n            const currentActiveState = getActiveScreenState(); // Use helper\n            if (!currentActiveState) return;\n\n            const currentLayout = currentActiveState.layout;\n            const currentRootId = currentActiveState.rootId;\n            if (!currentRootId) return;\n\n            const areaToViewportMap = computeAreaToViewport(currentLayout, currentRootId, getAreaRootViewport());\n\n            let targetAreaId: string | null = null;\n            let direction: CardinalDirection | null = null;\n\n            // Logic to find target area based on vec and viewports\n            // Iterate ONLY over IMMEDIATE eligible siblings to find the target\n            for (const eligibleId of immediateSiblings) {\n                // No need to check for self (id === areaId)\n                const vp = areaToViewportMap[eligibleId];\n                if (vp && vec.x >= vp.left && vec.x <= vp.left + vp.width && vec.y >= vp.top && vec.y <= vp.top + vp.height) {\n                    targetAreaId = eligibleId;\n                    // Determine direction (simplified)\n                    const sourceVp = areaToViewportMap[areaId]; // Viewport of the area being dragged\n                    if (sourceVp) {\n                        // Use target viewport center vs source viewport center for more robust direction?\n                        const targetVp = vp;\n                        const deltaX = (targetVp.left + targetVp.width / 2) - (sourceVp.left + sourceVp.width / 2);\n                        const deltaY = (targetVp.top + targetVp.height / 2) - (sourceVp.top + sourceVp.height / 2);\n\n                        if (initialParentRow.orientation === 'horizontal') {\n                            direction = deltaX > 0 ? 'e' : 'w';\n                        } else {\n                            direction = deltaY > 0 ? 's' : 'n';\n                        }\n                    }\n                    break; // Found the target among immediate eligible siblings\n                }\n            }\n\n            // Call setJoinPreview ONLY if a valid immediate sibling target is hovered\n            if (targetAreaId && direction) {\n                useKarmycStore.getState().setJoinPreview({\n                    areaId: targetAreaId, // The immediate eligible sibling area currently hovered\n                    movingInDirection: direction,\n                    eligibleAreaIds: actualEligibleAreaIds // Pass the correct full list of *all* siblings for potential future use?\n                    // Or should this also be immediateSiblings? Let's keep all siblings for now.\n                });\n            } else {\n                // If not hovering over an eligible immediate sibling, clear the preview\n                if (getActiveScreenState()?.joinPreview !== null) { // Only clear if needed\n                    useKarmycStore.getState().setJoinPreview(null);\n                }\n            }\n        };\n\n        currentOnMouseUp = () => {\n            const state = getActiveScreenState();\n            const preview = state?.joinPreview;\n\n            // Check if the PREVIEW state contains a valid IMMEDIATE sibling target when mouse is released\n            if (preview && preview.areaId && preview.movingInDirection && immediateSiblings.includes(preview.areaId)) {\n                useKarmycStore.getState().joinOrMoveArea({ sourceAreaId: areaId, targetAreaId: preview.areaId, direction: preview.movingInDirection });\n            } \n\n            // Clear preview regardless of whether the action was triggered\n            if (getActiveScreenState()?.joinPreview !== null) {\n                useKarmycStore.getState().setJoinPreview(null);\n            }\n            setAreaResizing(false);\n            currentOnMove = null;\n            currentOnMouseUp = null;\n        };\n    }\n\n    // --- Initial Decision Logic ---\n    let initialDirectionDetermined = false;\n\n    const determineInitialDirection = (currentPos: Vec2) => {\n        // Use new Vec2 for delta calculation to avoid modifying original vectors\n        const delta = new Vec2(currentPos.x - initialMousePosition.x, currentPos.y - initialMousePosition.y);\n\n        const dist = delta.length();\n\n        if (dist < 10) { // Threshold\n            return; // Not moved enough\n        }\n\n        // DIRECTION DETERMINED - Detach this initial listener and attach the correct one\n        window.removeEventListener(\"mousemove\", handleMouseMove);\n        window.removeEventListener(\"mouseup\", handleMouseUp);\n\n        // *** LOG before determination ***\n        const isMovingInwards = determineIfMovingInwards(corner, delta);\n        \n        // Déterminer si le mouvement est principalement horizontal ou vertical\n        const absX = Math.abs(delta.x);\n        const absY = Math.abs(delta.y);\n        const horizontalSplit = absX > absY;\n\n        if (isMovingInwards) {\n            // Si le mouvement est vers l'intérieur, créer une nouvelle zone (division)\n            createNewArea(horizontalSplit);\n        } else {\n            // Si le mouvement est vers l'extérieur, initier join/move\n            setupJoinMoveHandlers();\n        }\n\n        initialDirectionDetermined = true;\n        // Trigger the first move event for the selected handler\n        if (currentOnMove) {\n            currentOnMove(currentPos);\n        }\n    };\n\n    // --- Global Mouse Event Listeners ---\n    const handleMouseMove = (moveEvent: MouseEvent) => {\n        const vec = Vec2.fromEvent(moveEvent);\n        lastMousePosition = vec;\n\n        if (!initialDirectionDetermined) {\n            determineInitialDirection(vec);\n        } else if (currentOnMove) {\n            currentOnMove(vec);\n        }\n    };\n\n    const handleMouseUp = () => {\n        document.removeEventListener('mousemove', handleMouseMove);\n        document.removeEventListener('mouseup', handleMouseUp);\n\n        if (!initialDirectionDetermined) {\n            setAreaResizing(false);\n            // Ensure join preview is cleared if mouseup happens early\n            if (getActiveScreenState()?.joinPreview !== null) {\n                useKarmycStore.getState().setJoinPreview(null);\n            }\n        } else if (currentOnMouseUp) {\n            currentOnMouseUp();\n        } else {\n            console.warn(\"Mouse up, direction determined but no final handler set.\");\n            setAreaResizing(false);\n        }\n    };\n\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n};\n","import React from \"react\";\nimport { AreaComponentProps } from \"../types/areaTypes\";\nimport { useTranslation } from '../hooks/useTranslation';\n\ninterface Props {\n    component: React.ComponentType<AreaComponentProps<any>>;\n    areaId: string;\n    areaState: any;\n    type: string;\n    viewport: {\n        left: number;\n        top: number;\n        width: number;\n        height: number;\n    };\n}\n\ninterface State {\n    hasError: boolean;\n    error: Error | null;\n}\n\n// Composant fonctionnel pour l'affichage de l'erreur\nconst ErrorDisplay: React.FC<{\n    viewport: Props['viewport'];\n    error: Error | null;\n}> = ({ viewport, error }) => {\n    const { t } = useTranslation();\n    \n    return (\n        <div\n            style={{\n                position: \"absolute\",\n                left: viewport.left,\n                top: viewport.top,\n                width: viewport.width,\n                height: viewport.height,\n                backgroundColor: \"#fff5f5\",\n                border: \"1px solid #feb2b2\",\n                borderRadius: \"4px\",\n                padding: \"16px\",\n                color: \"#c53030\",\n            }}\n        >\n            <h3>{t('area.error.title', 'An error occurred in the area')}</h3>\n            <p>{error?.message}</p>\n        </div>\n    );\n};\n\nexport class AreaErrorBoundary extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n        this.state = { hasError: false, error: null };\n    }\n\n    static getDerivedStateFromError(error: Error): State {\n        return { hasError: true, error };\n    }\n\n    componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n        console.error(\"Area error:\", error, errorInfo);\n    }\n\n    render() {\n        if (this.state.hasError) {\n            return <ErrorDisplay viewport={this.props.viewport} error={this.state.error} />;\n        }\n\n        const Component = this.props.component;\n        return (\n            <Component\n                id={this.props.areaId}\n                state={this.props.areaState}\n                type={this.props.type}\n                viewport={this.props.viewport}\n                Component={Component}\n            />\n        );\n    }\n} \n","import { useCallback } from 'react';\n\nimport { useContextMenuStore } from '../store/contextMenuStore';\nimport { ContextMenuItem } from '../types/contextMenu';\n\n/**\n * Hook for managing the context menu\n * Provides simplified functions to open and close the context menu\n */\nexport const useContextMenu = () => {\n    // Selectors\n    const isVisible = useContextMenuStore((state) => state.isVisible);\n    const position = useContextMenuStore((state) => state.position);\n    const openAction = useContextMenuStore((state) => state.openContextMenu);\n    const closeAction = useContextMenuStore((state) => state.closeContextMenu);\n\n    // Actions\n    const open = useCallback((params: {\n        position: { x: number; y: number };\n        items: ContextMenuItem[];\n        targetId?: string;\n        metadata?: Record<string, any>;\n        menuClassName?: string;\n    }) => {\n        openAction(params);\n    }, [openAction]);\n\n    const close = useCallback(() => {\n        closeAction();\n    }, [closeAction]);\n\n    return {\n        // State\n        isVisible,\n        position,\n\n        // Actions\n        open,\n        close,\n    };\n} \n","import React from 'react';\nimport { useContextMenu } from '../hooks/useContextMenu';\nimport { useRegisterActionHandler } from '../actions/handlers/useRegisterActionHandler';\nimport { PlusIcon, CopyIcon, AppWindow, ExternalLinkIcon, TrashIcon } from 'lucide-react';\nimport { useTranslation } from '../hooks/useTranslation';\nimport { useScreenManagement } from '../hooks/useScreenManagement';\n\nexport const ScreenSwitcher: React.FC = () => {\n    const { t } = useTranslation();\n    const { screens, activeScreenId, switchScreen, addScreen, removeScreen, duplicateScreen } = useScreenManagement();\n    const { open } = useContextMenu();\n\n    // Enregistrer les actions du menu contextuel\n    useRegisterActionHandler('open-new-window', (params) => {\n        if (params?.screenId) {\n            window.open(`?screen=${params.screenId}`, '_blank', 'noopener,noreferrer');\n        }\n    });\n\n    useRegisterActionHandler('open-new-tab', (params) => {\n        if (params?.screenId) {\n            window.open(`?screen=${params.screenId}`, '_blank');\n        }\n    });\n\n    useRegisterActionHandler('delete-screen', (params) => {\n        if (params?.screenId) {\n            // Vérifier s'il reste plus d'un écran\n            if (Object.keys(screens).length > 1) {\n                removeScreen(params.screenId);\n            } else {\n                console.warn('Cannot remove the last screen');\n            }\n        }\n    });\n\n    useRegisterActionHandler('duplicate-screen', (params) => {\n        if (params?.screenId) {\n            duplicateScreen(params.screenId);\n        }\n    });\n\n    useRegisterActionHandler('add-screen', () => {\n        addScreen();\n    });\n\n    // Filtrer et trier les screens non détachés\n    const filteredScreenIds = Object.keys(screens)\n        .filter((id) => !screens[id]?.isDetached)\n        .sort((a, b) => parseInt(a) - parseInt(b));\n\n    const handleContextMenu = (e: React.MouseEvent, id: string) => {\n        e.preventDefault();\n        open({\n            position: { x: e.clientX, y: e.clientY },\n            menuClassName: 'screen-switcher-menu',\n            items: [\n                {\n                    id: 'add',\n                    label: t('screen.menu.add', 'Add'),\n                    icon: PlusIcon,\n                    actionId: 'add-screen',\n                    metadata: {}\n                },\n                {\n                    id: 'duplicate',\n                    label: t('screen.menu.duplicate', 'Duplicate'),\n                    icon: CopyIcon,\n                    actionId: 'duplicate-screen',\n                    metadata: { screenId: id }\n                },\n                {\n                    id: 'open-new-window',\n                    label: t('screen.menu.openNewWindow', 'Open in new window'),\n                    icon: AppWindow,\n                    actionId: 'open-new-window',\n                    metadata: { screenId: id }\n                },\n                {\n                    id: 'open-new-tab',\n                    label: t('screen.menu.openNewTab', 'Open in new tab'),\n                    icon: ExternalLinkIcon,\n                    actionId: 'open-new-tab',\n                    metadata: { screenId: id }\n                },\n                {\n                    id: 'delete',   \n                    label: t('screen.menu.delete', 'Delete'),\n                    icon: TrashIcon,\n                    actionId: 'delete-screen',\n                    metadata: { screenId: id },\n                    disabled: Object.keys(screens).length <= 1\n                }\n            ],\n            targetId: id\n        });\n    };\n\n    return (\n        <div style={{ display: 'flex', alignItems: 'center', gap: '5px', padding: '0 10px' }}>\n            {/* Lister les boutons pour chaque écran */}\n            {filteredScreenIds.map((id, idx) => (\n                <button\n                    key={id}\n                    onClick={() => switchScreen(id)}\n                    onContextMenu={(e) => handleContextMenu(e, id)}\n                    title={t('screen.switch', `Switch to screen ${idx + 1}`)}\n                    style={{\n                        padding: '2px 8px',\n                        border: '1px solid #555',\n                        borderRadius: '3px',\n                        background: activeScreenId === id ? '#444' : '#2a2a2a',\n                        color: activeScreenId === id ? '#eee' : '#aaa',\n                        cursor: 'pointer',\n                        minWidth: '25px', // Ensure minimum width\n                        textAlign: 'center',\n                    }}\n                    disabled={activeScreenId === id} // Disable active screen button\n                >\n                    {idx + 1}\n                </button>\n            ))}\n        </div>\n    );\n}; \n","import { useKarmycStore } from '../store/areaStore';\r\n\r\nexport interface ScreenManagement {\r\n    screens: Record<string, any>;\r\n    activeScreenId: string;\r\n    switchScreen: (screenId: string) => void;\r\n    addScreen: () => void;\r\n    removeScreen: (screenId: string) => void;\r\n    duplicateScreen: (screenId: string) => void;\r\n}\r\n\r\nexport function useScreenManagement(): ScreenManagement {\r\n    const screens = useKarmycStore((state) => state.screens);\r\n    const activeScreenId = useKarmycStore((state) => state.activeScreenId);\r\n    const switchScreen = useKarmycStore((state) => state.switchScreen);\r\n    const addScreen = useKarmycStore((state) => state.addScreen);\r\n    const removeScreen = useKarmycStore((state) => state.removeScreen);\r\n    const duplicateScreen = useKarmycStore((state) => state.duplicateScreen);\r\n\r\n    return {\r\n        screens,\r\n        activeScreenId,\r\n        switchScreen,\r\n        addScreen,\r\n        removeScreen,\r\n        duplicateScreen\r\n    };\r\n} \r\n","import { ToolsBarComponent } from '../components/ToolsSlot';\r\n\r\n// Global registry\r\nexport const toolsBarRegistry: Record<string, ToolsBarComponent[]> = {};\r\n\r\n// Subscription system for registry reactivity\r\nconst listeners = new Set<() => void>();\r\nexport function notifyToolsRegistryChange() {\r\n    listeners.forEach((cb) => cb());\r\n}\r\n\r\nexport function subscribeToRegistryChanges(callback: () => void) {\r\n    listeners.add(callback);\r\n    return () => {\r\n        listeners.delete(callback);\r\n    };\r\n} \r\n","import { useEffect } from 'react';\r\nimport { toolsEventBus } from '../utils/toolsEventBus';\r\nimport { toolsBarRegistry, notifyToolsRegistryChange } from '../utils/toolsRegistry';\r\n\r\n// Fonction pour nettoyer le registre des outils d'une zone\r\nfunction cleanupToolsRegistry(areaId: string) {\r\n    const positions = ['top-outer', 'top-inner', 'bottom-outer', 'bottom-inner'];\r\n    positions.forEach(position => {\r\n        const registryKey = `${areaId}:${position}`;\r\n        if (toolsBarRegistry[registryKey]) {\r\n            delete toolsBarRegistry[registryKey];\r\n        }\r\n    });\r\n    notifyToolsRegistryChange();\r\n}\r\n\r\n// Hook pour gérer le nettoyage des outils\r\nexport function useToolsCleanup() {\r\n    useEffect(() => {\r\n        const unsubscribe = toolsEventBus.subscribe((event) => {\r\n            if (event.type === 'cleanup') {\r\n                cleanupToolsRegistry(event.areaId);\r\n            }\r\n        });\r\n        return unsubscribe;\r\n    }, []);\r\n} \r\n","import React, { useCallback, useEffect } from 'react';\nimport { ScreenSwitcher } from './ScreenSwitcher';\nimport { TOOLBAR_HEIGHT } from '../utils/constants';\nimport { Rect } from '../types/math';\nimport { useToolsState } from '../hooks/useToolsState';\nimport { useToolsScreenState } from '../hooks/useToolsScreenState';\nimport { toolsBarRegistry, subscribeToRegistryChanges } from '../utils/toolsRegistry';\nimport { useToolsCleanup } from '../hooks/useToolsCleanup';\n\n// Type to uniquely identify a component\nexport type ComponentIdentifier = {\n    name: string;\n    type: string;\n};\n\n// Alignment possible in the toolbar\nexport type ToolsBarAlignment = 'left' | 'center' | 'right';\n\n// Positioning of the toolbar\nexport type ToolsBarPosition =\n    | 'top-outer'\n    | 'top-inner'\n    | 'bottom-outer'\n    | 'bottom-inner'\n    | string;\n\n// Structure of a registered component\nexport interface ToolsBarComponent {\n    component: React.ComponentType<any>;\n    order: number;\n    alignment: ToolsBarAlignment;\n    width?: string | number;\n    identifier: ComponentIdentifier;\n    allowedLayerTypes?: string[];\n    callback?: (() => void)[];\n}\n\n// Global registry\nconst listeners = new Set<() => void>();\nfunction notifyToolsRegistryChange() {\n    listeners.forEach((cb) => cb());\n}\n\n// Hook for registration\n/**\n * Hook for dynamically registering components in a Tools bar.\n * @param key ID of the area or type of area\n * @param position Position of the bar\n */\nexport function useToolsSlot(\n    key: string,\n    position: ToolsBarPosition,\n) {\n    // Use the key (ID or type) and position as registry key\n    const registryKey = `${key}:${position}`;\n\n    // Register a component in the bar\n    const registerComponent = useCallback(\n        (\n            component: React.ComponentType<any>,\n            identifier: ComponentIdentifier,\n            options: {\n                order?: number;\n                alignment?: ToolsBarAlignment;\n                width?: string | number;\n                allowedLayerTypes?: string[];\n                callback?: (() => void)[];\n            } = {}\n        ) => {\n            const { order = 0, alignment = 'left', width, allowedLayerTypes, callback } = options;\n            if (!toolsBarRegistry[registryKey]) {\n                toolsBarRegistry[registryKey] = [];\n            } else {\n                toolsBarRegistry[registryKey] = toolsBarRegistry[registryKey].filter(\n                    item => !(item.identifier.name === identifier.name && item.identifier.type === identifier.type)\n                );\n            }\n            const id = Math.random().toString(36).substr(2, 9);\n            toolsBarRegistry[registryKey].push({\n                component,\n                order,\n                alignment,\n                width,\n                identifier,\n                allowedLayerTypes,\n                callback\n            });\n            toolsBarRegistry[registryKey].sort((a, b) => a.order - b.order);\n            notifyToolsRegistryChange();\n            return id;\n        },\n        [registryKey]\n    );\n\n    // Get registered components\n    const getComponents = useCallback(() => {\n        return toolsBarRegistry[registryKey] || [];\n    }, [registryKey]);\n\n    return {\n        registerComponent,\n        getComponents\n    };\n}\n\n// Hook for subscribing to registry changes (useSyncExternalStore)\nfunction useToolsRegistrySubscription() {\n    const [, forceUpdate] = React.useReducer((x) => x + 1, 0);\n    useEffect(() => {\n        return subscribeToRegistryChanges(forceUpdate);\n    }, []);\n}\n\n// Props of the Tools component\ninterface ToolsProps {\n    areaId?: string;\n    areaType?: string;\n    areaState?: any;\n    children: React.ReactNode;\n    style?: React.CSSProperties;\n    viewport?: Rect;\n}\n\nexport const Tools: React.FC<ToolsProps> = ({\n    areaId,\n    areaType = 'app',\n    areaState = {},\n    children,\n    viewport = {\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n    },\n}) => {\n    useToolsRegistrySubscription();\n    useToolsCleanup();\n\n    const combineAndDedupe = (...componentArrays: ToolsBarComponent[][]) => {\n        const componentMap = new Map<string, ToolsBarComponent>();\n        componentArrays.flat().forEach(comp => {\n            const key = `${comp.identifier.name}:${comp.identifier.type}`;\n            if (!componentMap.has(key)) {\n                componentMap.set(key, comp);\n            }\n        });\n        return Array.from(componentMap.values()).sort((a, b) => a.order - b.order);\n    };\n\n    const { getComponents: getMenuComponentsById } = useToolsSlot(areaId || '', 'top-outer');\n    const { getComponents: getMenuComponentsByType } = useToolsSlot(areaType, 'top-outer');\n    const menuComponents = combineAndDedupe(getMenuComponentsById(), getMenuComponentsByType());\n\n    const { getComponents: getStatusComponentsById } = useToolsSlot(areaId || '', 'bottom-outer');\n    const { getComponents: getStatusComponentsByType } = useToolsSlot(areaType, 'bottom-outer');\n    const statusComponents = combineAndDedupe(getStatusComponentsById(), getStatusComponentsByType());\n\n    const { getComponents: getToolbarTopInnerById } = useToolsSlot(areaId || '', 'top-inner');\n    const { getComponents: getToolbarTopInnerByType } = useToolsSlot(areaType, 'top-inner');\n    const toolbarTopInnerComponents = combineAndDedupe(getToolbarTopInnerById(), getToolbarTopInnerByType());\n\n    const { getComponents: getToolbarBottomInnerById } = useToolsSlot(areaId || '', 'bottom-inner');\n    const { getComponents: getToolbarBottomInnerByType } = useToolsSlot(areaType, 'bottom-inner');\n    const toolbarBottomInnerComponents = combineAndDedupe(getToolbarBottomInnerById(), getToolbarBottomInnerByType());\n\n    const {\n        handleFocus,\n    } = useToolsState(areaId);\n\n    const {\n        isDetached,\n        multiScreen\n    } = useToolsScreenState();\n\n    // Calculate toolbar heights\n    const hasTopOuter = menuComponents.length > 0;\n    const hasBottomOuter = statusComponents.length > 0;\n    const hasTopInner = toolbarTopInnerComponents.length > 0;\n    const hasBottomInner = toolbarBottomInnerComponents.length > 0;\n\n    const topOuterHeight = hasTopOuter ? TOOLBAR_HEIGHT : 0;\n    const bottomOuterHeight = hasBottomOuter ? TOOLBAR_HEIGHT : 0;\n\n    // Organize by alignment and filter for each position\n    const renderToolbar = (components: ToolsBarComponent[], position: ToolsBarPosition) => {\n        const leftComponents = components.filter(c => c.alignment === 'left');\n        const centerComponents = components.filter(c => c.alignment === 'center');\n        const rightComponents = components.filter(c => c.alignment === 'right');\n\n        if (leftComponents.length === 0 && centerComponents.length === 0 && rightComponents.length === 0) {\n            return null;\n        }\n\n        if ((position.includes('inner')) || (!isDetached && position.includes('outer'))) {\n            return (\n                <div \n                    className={`tools-bar tools-bar-${position}`} \n                    style={{ \n                        height: TOOLBAR_HEIGHT, \n                        minHeight: TOOLBAR_HEIGHT,\n                        position: position.includes('outer') ? 'absolute' : 'relative',\n                        left: 0,\n                        right: 0,\n                        ...(position.includes('bottom') ? { bottom: 0 } : { top: 0 })\n                    }}\n                    onFocusCapture={handleFocus}\n                    tabIndex={0}\n                    data-testid={`tools-bar-${position}`}\n                >\n                    <div className=\"tools-bar-section tools-bar-section--left\" style={{ display: leftComponents.length > 0 ? 'flex' : 'none'}}>\n                        {leftComponents.map((item, idx) => {\n                            const Component = item.component;\n                            return (\n                                <Component \n                                    key={`${item.identifier.type}-${item.identifier.name}-${idx}`} \n                                    areaState={areaState}\n                                    onFocusCapture={handleFocus}\n                                />\n                            );\n                        })}\n                    </div>\n                    <div className=\"tools-bar-section tools-bar-section--center\" style={{ display: centerComponents.length > 0 ? 'flex' : 'none'}}>\n                        {centerComponents.map((item, idx) => {\n                            const Component = item.component;\n                            return (\n                                <Component \n                                    key={`${item.identifier.type}-${item.identifier.name}-${idx}`} \n                                    areaState={areaState}\n                                    onFocusCapture={handleFocus}\n                                />\n                            );\n                        })}\n                    </div>\n                    <div className=\"tools-bar-section tools-bar-section--right\" style={{ display: rightComponents.length > 0 ? 'flex' : 'none'}}>\n                        {rightComponents.map((item, idx) => {\n                            const Component = item.component;\n                            return (\n                                <Component \n                                    key={`${item.identifier.type}-${item.identifier.name}-${idx}`} \n                                    areaState={areaState}\n                                    onFocusCapture={handleFocus}\n                                />\n                            );\n                        })}\n                        {multiScreen && areaType === 'app' && position === 'bottom-outer' && <ScreenSwitcher />}\n                    </div>\n                </div>\n            );\n        }\n        return null;\n    };\n\n    return (\n        <div \n            className=\"tools-container\" \n            style={{ \n                position: 'relative', \n                width: viewport.width, \n                height: isDetached ? '100%' : 'calc(100%)',\n                overflow: 'hidden'\n            }}\n            data-testid=\"tools-container\"\n        >\n            <div \n                className=\"tools-content\"\n                style={{ \n                    position: 'absolute',\n                    top: topOuterHeight,\n                    left: 0,\n                    right: 0,\n                    bottom: bottomOuterHeight,\n                    overflow: 'hidden',\n                    display: 'flex',\n                    flexDirection: 'column'\n                }}\n                data-testid=\"tools-content\"\n            >\n                <div style={{ flex: 1, overflow: 'hidden' }}>\n                    {children}\n                </div>\n            </div>\n\n            {hasTopOuter && renderToolbar(menuComponents, 'top-outer')}\n            {hasBottomOuter && renderToolbar(statusComponents, 'bottom-outer')}\n            {hasTopInner && renderToolbar(toolbarTopInnerComponents, 'top-inner')}\n            {hasBottomInner && renderToolbar(toolbarBottomInnerComponents, 'bottom-inner')}\n        </div>\n    );\n}; \n","import { useCallback } from 'react';\r\nimport { useKarmycStore } from '../store/areaStore';\r\nimport { useSpaceStore } from '../store/spaceStore';\r\n\r\n/**\r\n * Hook pour gérer l'état des outils\r\n * @param areaId L'ID de l'aire\r\n * @returns Les états et actions nécessaires pour les outils\r\n */\r\nexport const useToolsState = (areaId?: string) => {\r\n    const activeScreenId = useKarmycStore((state) => state.activeScreenId);\r\n    const isDetached = useKarmycStore((state) => state.screens[activeScreenId]?.isDetached) || false;\r\n    const multiScreen = useKarmycStore((state) => state.options.multiScreen) || false;\r\n\r\n    // Get the area ID and its associated space\r\n    const currentArea = useKarmycStore(state => {\r\n        const activeScreenAreas = state.screens[state.activeScreenId]?.areas;\r\n        if (!activeScreenAreas) return undefined;\r\n        // Activation of space by focus only applies to areas with an ID\r\n        return areaId ? Object.values(activeScreenAreas.areas).find(area => area.id === areaId) : undefined;\r\n    });\r\n    const currentSpaceId = currentArea?.spaceId;\r\n\r\n    // Focus manager to activate space\r\n    const handleFocus = useCallback(() => {\r\n        if (currentSpaceId) {\r\n            useSpaceStore.getState().setActiveSpace(currentSpaceId);\r\n        }\r\n    }, [currentSpaceId]);\r\n\r\n    return {\r\n        activeScreenId,\r\n        isDetached,\r\n        multiScreen,\r\n        currentArea,\r\n        currentSpaceId,\r\n        handleFocus,\r\n        isFullscreen: currentArea?.enableFullscreen ?? false\r\n    };\r\n}; \r\n","import { useKarmycStore } from '../store/areaStore';\r\n\r\n/**\r\n * Hook pour gérer l'état des écrans dans ToolsSlot\r\n * @returns Les états et actions nécessaires pour les écrans dans ToolsSlot\r\n */\r\nexport const useToolsScreenState = () => {\r\n    const activeScreenId = useKarmycStore((state) => state.activeScreenId);\r\n    const isDetached = useKarmycStore((state) => state.screens[activeScreenId]?.isDetached) || false;\r\n    const multiScreen = useKarmycStore((state) => state.options.multiScreen) || false;\r\n\r\n    return {\r\n        activeScreenId,\r\n        isDetached,\r\n        multiScreen\r\n    };\r\n}; \r\n","import React, { Dispatch, SetStateAction, useRef, useEffect } from \"react\";\r\nimport { handleAreaDragFromCorner } from \"./handlers/areaDragFromCorner\";\r\nimport { AreaErrorBoundary } from \"./AreaErrorBoundary\";\r\nimport { Tools } from './ToolsSlot';\r\nimport { AREA_ROLE } from \"../types/actions\";\r\nimport { TOOLBAR_HEIGHT } from \"../utils/constants\";\r\nimport { useKarmycStore } from \"../store/areaStore\";\r\nimport { AreaComponentProps, ResizePreviewState } from \"../types/areaTypes\";\r\nimport { AreaIdContext } from \"../utils/AreaIdContext\";\r\nimport { useSpaceStore } from \"../store/spaceStore\";\r\nimport { AreaDragButton } from \"./handlers/AreaDragButton\";\r\n\r\ninterface AreaComponentOwnProps extends AreaComponentProps {\r\n    setResizePreview: Dispatch<SetStateAction<ResizePreviewState | null>>;\r\n    isChildOfStack: boolean;\r\n}\r\n\r\nexport const AreaComponent: React.FC<AreaComponentOwnProps> = ({\r\n    id,\r\n    Component,\r\n    state,\r\n    type,\r\n    viewport,\r\n    raised,\r\n    isChildOfStack = false,\r\n    setResizePreview,\r\n}) => {\r\n    if (!viewport) {\r\n        console.warn(`No viewport found for area ${id}, using default viewport`);\r\n        viewport = {\r\n            left: 0,\r\n            top: 0,\r\n            width: 100,\r\n            height: 100\r\n        };\r\n    }\r\n\r\n    const active = useKarmycStore(state => state.screens[state.activeScreenId]?.areas.activeAreaId === id);\r\n    const setActiveArea = useKarmycStore(state => state.setActiveArea);\r\n    const viewportRef = useRef<HTMLDivElement>(null);\r\n    const area = useKarmycStore(state => state.getAreaById(id));\r\n    const setActiveSpace = useSpaceStore(state => state.setActiveSpace);\r\n    const activeSpaceId = useSpaceStore(state => state.activeSpaceId);\r\n    const pilotMode = useSpaceStore(state => state.pilotMode);\r\n    const spaces = useSpaceStore(state => state.spaces);\r\n    const resizableAreas = useKarmycStore(state => state.options?.resizableAreas ?? true);\r\n    const manageableAreas = useKarmycStore(state => state.options?.manageableAreas ?? true);\r\n\r\n    // Effet pour mettre à jour les zones FOLLOW quand l'espace actif change\r\n    useEffect(() => {\r\n        if (activeSpaceId) {\r\n            // En mode AUTO, les areas FOLLOW suivent toujours le LEAD\r\n            if (pilotMode === 'AUTO' && area?.role === AREA_ROLE.FOLLOW) {\r\n                const activeScreenId = useKarmycStore.getState().activeScreenId;\r\n                const lastLeadAreaId = useKarmycStore.getState().screens[activeScreenId]?.areas.lastLeadAreaId;\r\n                const allAreas = useKarmycStore.getState().screens[activeScreenId]?.areas.areas || {};\r\n                const leadArea = lastLeadAreaId ? allAreas[lastLeadAreaId] : null;\r\n                \r\n                if (leadArea && leadArea.spaceId === activeSpaceId) {\r\n                    setActiveArea(leadArea.id);\r\n                }\r\n            }\r\n            // En mode MANUAL, toutes les areas suivent l'espace actif\r\n            else if (pilotMode === 'MANUAL') {\r\n                if (area?.spaceId !== activeSpaceId) {\r\n                    useKarmycStore.getState().updateArea({ id, spaceId: activeSpaceId });\r\n                }\r\n            }\r\n        }\r\n    }, [activeSpaceId, area?.role, pilotMode]);\r\n\r\n    const onActivate = () => {\r\n        if (!active) {\r\n            setActiveArea(id);\r\n            // Si c'est une area LEAD, on met à jour l'espace actif seulement si on n'est pas en mode MANUAL\r\n            if (area?.role === AREA_ROLE.LEAD && pilotMode !== 'MANUAL') {\r\n                if (area.spaceId) {\r\n                    setActiveSpace(area.spaceId);\r\n                } else {\r\n                    // Si pas d'espace défini, on utilise le dernier espace actif ou on en crée un nouveau\r\n                    const existingSpaces = Object.keys(spaces);\r\n                    if (existingSpaces.length > 0) {\r\n                        // Utiliser le dernier espace actif ou le premier disponible\r\n                        const spaceToUse = activeSpaceId || existingSpaces[0];\r\n                        useKarmycStore.getState().updateArea({ id, spaceId: spaceToUse });\r\n                        setActiveSpace(spaceToUse);\r\n                    } else {\r\n                        // Créer un nouvel espace seulement s'il n'y en a aucun\r\n                        const newSpaceId = useSpaceStore.getState().addSpace({\r\n                            name: `Space for ${area.type}`,\r\n                            sharedState: {}\r\n                        });\r\n                        if (newSpaceId) {\r\n                            useKarmycStore.getState().updateArea({ id, spaceId: newSpaceId });\r\n                            setActiveSpace(newSpaceId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    const activeScreenId = useKarmycStore((state) => state.activeScreenId);\r\n    const isDetached = useKarmycStore((state) => state.screens[activeScreenId]?.isDetached) || false;\r\n\r\n    return (\r\n        <AreaIdContext.Provider value={id}>\r\n            {(!isDetached && !isChildOfStack) && <AreaDragButton id={id} state={state} type={type} />}\r\n            <Tools\r\n                areaId={id}\r\n                areaType={type}\r\n                areaState={state}\r\n                viewport={viewport}\r\n            >\r\n                <div\r\n                    ref={viewportRef}\r\n                    data-areaid={id}\r\n                    data-testid={`area-${id}`}\r\n                    data-testid-resize-handle={`area-${id}-resize-handle`}\r\n                    className={`area ${raised ? 'active' : ''}`}\r\n                    style={{\r\n                        width: '100%',\r\n                        height: isDetached || area?.enableFullscreen ? '100%' : `calc(${typeof viewport.height === 'string' ? viewport.height : viewport.height + 'px'} - ${TOOLBAR_HEIGHT}px)`,\r\n                    }}\r\n                    onClick={onActivate}\r\n                >\r\n                    {!isDetached && !isChildOfStack && resizableAreas && manageableAreas && ['ne', 'nw', 'se', 'sw'].map((dir) => (\r\n                        <div\r\n                            key={dir}\r\n                            className={`area__corner area__corner--${dir}`}\r\n                            data-testid={`area-${id}-resize-handle`}\r\n                            onMouseDown={(e) => handleAreaDragFromCorner(e.nativeEvent, dir as 'ne', id, viewport, setResizePreview, () => { })}\r\n                        />\r\n                    ))}\r\n\r\n                    <div\r\n                        className={`area-main-content-wrapper ${type}`}\r\n                        data-areatype={type}\r\n                        data-testid={`area-${id}-role-button`}\r\n                        style={{\r\n                            opacity: active ? 1 : 0.9,\r\n                            height: '100%',\r\n                            width: area?.enableFullscreen ? '100vw' : '100%',\r\n                            top: area?.enableFullscreen ? 0 : 'auto',\r\n                            left: area?.enableFullscreen ? 0 : 'auto',\r\n                            zIndex: area?.enableFullscreen ? 9999 : 'auto',\r\n                            overflow: 'hidden',\r\n                        }}\r\n                    >\r\n                        {Component ? (\r\n                            <AreaErrorBoundary\r\n                                component={Component}\r\n                                areaId={id}\r\n                                areaState={state}\r\n                                type={type}\r\n                                viewport={{\r\n                                    left: 0,\r\n                                    top: 0,\r\n                                    width: area?.enableFullscreen ? window.innerWidth : viewport.width,\r\n                                    height: area?.enableFullscreen ? window.innerHeight : viewport.height - (!isDetached ? TOOLBAR_HEIGHT : 0)\r\n                                }}\r\n                            />\r\n                        ) : (\r\n                            <div\r\n                                style={{\r\n                                    position: \"absolute\",\r\n                                    left: 0,\r\n                                    top: 0,\r\n                                    width: area?.enableFullscreen ? window.innerWidth : viewport.width,\r\n                                    height: area?.enableFullscreen ? window.innerHeight : viewport.height - (!isDetached ? TOOLBAR_HEIGHT : 0),\r\n                                    backgroundColor: \"#fff5f5\",\r\n                                    border: \"1px solid #feb2b2\",\r\n                                    borderRadius: \"4px\",\r\n                                    padding: \"16px\",\r\n                                    color: \"#c53030\",\r\n                                }}\r\n                            >\r\n                                <h3>Invalid area type: {type}</h3>\r\n                                <p>This area type is not registered in the area registry.</p>\r\n                            </div>\r\n                        )}\r\n                    </div>\r\n                </div>\r\n            </Tools>\r\n        </AreaIdContext.Provider>\r\n    );\r\n}; \r\n","import React, { Dispatch, SetStateAction, useEffect, useState } from 'react';\nimport { IArea, AreaRowLayout } from '../types/areaTypes';\nimport { AreaTabs } from './AreaTabs';\nimport { AreaComponent } from './AreaComponent';\nimport { areaRegistry } from '../store/registries/areaRegistry';\nimport { ResizePreviewState } from '../types/areaTypes';\nimport { TOOLBAR_HEIGHT } from '../utils/constants';\n\ninterface AreaStackProps {\n    id: string;\n    layout: AreaRowLayout;\n    areas: Record<string, IArea>;\n    viewport: { left: number; top: number; width: number; height: number };\n    setResizePreview: Dispatch<SetStateAction<ResizePreviewState | null>>;\n}\n\nexport const AreaStack: React.FC<AreaStackProps> = React.memo(({ id, layout, areas, viewport, setResizePreview }) => {\n    const activeAreaId = layout.activeTabId || layout.areas[0]?.id;\n    const activeArea = activeAreaId ? areas[activeAreaId] : null;\n    const [isComponentReady, setIsComponentReady] = useState(false);\n\n    useEffect(() => {\n        if (activeArea?.type) {\n            const checkComponent = () => {\n                const component = areaRegistry.getComponent(activeArea.type);\n                if (component) {\n                    setIsComponentReady(true);\n                } else {\n                    // Si le composant n'est pas encore disponible, on réessaie après un court délai\n                    setTimeout(checkComponent, 25);\n                }\n            };\n            checkComponent();\n        }\n    }, [activeArea?.type]);\n\n    const Component = activeArea?.type ? areaRegistry.getComponent(activeArea.type) : null;\n    if (!Component || !isComponentReady) {\n        return null;\n    }\n\n    return (\n        <div\n            className=\"area-stack\"\n            style={{\n                left: viewport.left,\n                top: viewport.top,\n                width: viewport.width,\n                height: viewport.height + TOOLBAR_HEIGHT\n            }}\n            data-areaid={id}\n        >\n            <AreaTabs\n                rowId={layout.id}\n                row={layout}\n                areas={areas}\n            />\n            <div className=\"area-stack__content\">\n                <AreaComponent\n                    isChildOfStack={true}\n                    id={activeAreaId}\n                    Component={Component}\n                    state={activeArea?.state}\n                    type={activeArea?.type || ''}\n                    viewport={{\n                        left: 0,\n                        top: 0,\n                        width: viewport.width,\n                        height: viewport.height\n                    }}\n                    setResizePreview={setResizePreview}\n                    raised={!!activeArea?.raised}\n                />\n            </div>\n        </div>\n    );\n}); \n","import React from \"react\";\nimport { AreaComponent } from \"./AreaComponent\";\nimport { areaRegistry } from \"../store/registries/areaRegistry\";\nimport { Vec2 } from \"../utils\";\nimport { AreaToOpen } from \"../types/areaTypes\";\nimport { useTranslation } from '../hooks/useTranslation';\n\ninterface AreaPreviewProps {\n    areaToOpen: AreaToOpen;\n    dimensions: Vec2;\n}\n\nexport const AreaPreview: React.FC<AreaPreviewProps> = React.memo(({ areaToOpen, dimensions }) => {\n    const { t } = useTranslation();\n    const Component = areaRegistry.getComponent(areaToOpen.area.type);\n    if (!Component) {\n        return null;\n    }\n\n    return (\n        <div\n            className=\"area-preview\"\n            style={{\n                left: areaToOpen.position.x,\n                top: areaToOpen.position.y,\n            }}\n        >\n            <AreaComponent\n                id=\"-1\"\n                Component={Component}\n                raised\n                isChildOfStack={false}\n                state={areaToOpen.area.state}\n                type={areaToOpen.area.type}\n                viewport={{\n                    left: 0,\n                    top: 0,\n                    height: dimensions.y,\n                    width: dimensions.x,\n                }}\n                setResizePreview={() => { }}\n            />\n            <div className=\"area-preview-content\">\n                {t(`area.preview.${areaToOpen.area.type}`, `Preview of ${areaToOpen.area.type}`)}\n            </div>\n        </div>\n    );\n}); \n","import React, { Dispatch, SetStateAction, useMemo } from \"react\";\nimport { useToolsSlot } from './ToolsSlot';\nimport { areaRegistry } from \"../store/registries/areaRegistry\";\nimport { AreaTypeValue } from \"../types/actions\";\nimport { TOOLBAR_HEIGHT } from \"../utils/constants\";\nimport { useKarmycStore } from \"../store/areaStore\";\nimport { ResizePreviewState } from \"../types/areaTypes\";\nimport { Rect } from \"../types\";\nimport { AreaStack } from \"./AreaStack\";\nimport { AreaRowLayout } from \"../types/areaTypes\";\nimport { AreaComponent } from \"./AreaComponent\";\n\ninterface OwnProps {\n    id: string;\n    viewport: Rect;\n}\n\ninterface AreaContainerProps extends OwnProps {\n    setResizePreview: Dispatch<SetStateAction<ResizePreviewState | null>>;\n}\n\nexport const Area: React.FC<AreaContainerProps> = React.memo(({ id, viewport, setResizePreview }) => {\n    const areaData = useKarmycStore(state => state.getAreaById(id));\n    const layoutData = useKarmycStore(state => state.screens[state.activeScreenId]?.areas.layout[id]);\n    const allAreasData = useKarmycStore(state => state.screens[state.activeScreenId]?.areas.areas);\n    const activeScreenId = useKarmycStore((state) => state.activeScreenId);\n    const isDetached = useKarmycStore((state) => state.screens[activeScreenId]?.isDetached) || false;\n\n    const isLayoutRow = layoutData?.type === 'area_row';\n    const rowLayout = isLayoutRow ? layoutData as AreaRowLayout : null;\n    const isStack = isLayoutRow && rowLayout!.orientation === 'stack';\n    const isHorizontalOrVerticalRow = isLayoutRow && !isStack;\n\n    const Component = areaData?.type ? areaRegistry.getComponent(areaData.type) : null;\n\n    let activeAreaIdForRender = id;\n    let dataForRender = areaData;\n    let componentForRender = Component;\n\n    if (isStack) {\n        if (rowLayout!.activeTabId) {\n            activeAreaIdForRender = rowLayout!.activeTabId;\n            dataForRender = allAreasData?.[activeAreaIdForRender];\n            componentForRender = dataForRender?.type ? areaRegistry.getComponent(dataForRender.type) : null;\n        } else {\n            // Un stack sans activeTabId, AreaStack gérera l'affichage (peut-être un message vide)\n            dataForRender = undefined;\n            componentForRender = null;\n        }\n    }\n\n    // Récupérer les toolbars du parent\n    const { getComponents: getParentMenuComponents } = useToolsSlot(dataForRender?.type || '', 'top-outer');\n    const { getComponents: getParentStatusComponents } = useToolsSlot(dataForRender?.type || '', 'bottom-outer');\n    const parentMenuComponents = getParentMenuComponents();\n    const parentStatusComponents = getParentStatusComponents();\n\n    // Calculer les hauteurs des toolbars du parent\n    const hasParentTopOuter = parentMenuComponents.length > 0;\n    const hasParentBottomOuter = parentStatusComponents.length > 0;\n    const parentTopOuterHeight = hasParentTopOuter ? TOOLBAR_HEIGHT : 0;\n    const parentBottomOuterHeight = hasParentBottomOuter ? TOOLBAR_HEIGHT : 0;\n\n    const adjustedViewport = useMemo(() => {\n        // Si l'écran est détaché, ne pas ajuster le viewport\n        if (isDetached) {\n            return viewport;\n        }\n\n        // Ajuster le viewport en fonction des toolbars du parent\n        return {\n            ...viewport,\n            top: viewport.top + parentTopOuterHeight,\n            height: viewport.height - parentTopOuterHeight - parentBottomOuterHeight\n        };\n    }, [viewport, isDetached, parentTopOuterHeight, parentBottomOuterHeight]);\n\n    const containerStyle = useMemo(() => ({\n        position: 'absolute' as const,\n        left: adjustedViewport.left,\n        top: adjustedViewport.top,\n        width: adjustedViewport.width,\n        height: adjustedViewport.height,\n        display: 'flex',\n        flexDirection: isHorizontalOrVerticalRow \n            ? (rowLayout?.orientation === 'horizontal' ? 'row' : 'column') \n            : 'column' as 'row' | 'column',\n    }), [adjustedViewport, isHorizontalOrVerticalRow, rowLayout?.orientation]);\n\n    const contentViewport = useMemo(() => ({\n        left: 0,\n        top: 0,\n        width: adjustedViewport.width,\n        height: adjustedViewport.height\n    }), [adjustedViewport]);\n\n    return (\n        (!id.includes('row-') || isStack) && (id !== 'root') &&\n        (<div\n            className={\"area-container \" + id}\n            style={containerStyle}\n            data-areaid={id}\n            data-testid={`area-${id}`}\n            data-areatype={isStack ? 'stack-row' : isHorizontalOrVerticalRow ? `${rowLayout?.orientation}-row` : areaData?.type || 'unknown-leaf'}\n        >\n            {isStack && rowLayout &&\n                (<AreaStack\n                    id={id}\n                    areas={allAreasData}\n                    layout={rowLayout}\n                    viewport={contentViewport}\n                    setResizePreview={setResizePreview}\n                />)\n            }\n            {!isLayoutRow && componentForRender && dataForRender &&\n                <AreaComponent\n                    id={dataForRender.id}\n                    Component={componentForRender}\n                    state={dataForRender.state}\n                    type={dataForRender.type as AreaTypeValue}\n                    viewport={contentViewport}\n                    raised={!!dataForRender.raised}\n                    setResizePreview={setResizePreview}\n                    isChildOfStack={false}\n                />\n            }\n        </div>)\n    );\n}); \n","import { Dispatch, SetStateAction } from 'react';\nimport { capToRange, interpolate, Vec2 } from \"../../utils\";\nimport { AREA_MIN_CONTENT_WIDTH } from \"../../utils/constants\";\nimport { useKarmycStore } from \"../../store/areaStore\";\nimport { AreaRowLayout } from \"../../types/areaTypes\";\nimport type { Rect } from \"../../types\";\nimport { computeAreaRowToMinSize } from \"../../utils/areaRowToMinSize\";\nimport { computeAreaToViewport } from \"../../utils/areaToViewport\";\nimport { getAreaRootViewport } from \"../../utils/getAreaViewport\";\n\ninterface ResizePreviewState {\n    rowId: string;\n    separatorIndex: number;\n    t: number;\n}\n\nfunction simpleDragHandler(\n    onDrag: (e: MouseEvent) => void,\n    onDragEnd: () => void\n) {\n    // Disable text selection during drag\n    document.body.style.userSelect = 'none';\n    const handleMouseMove = (e: MouseEvent) => {\n        onDrag(e);\n    };\n\n    const handleMouseUp = () => {\n        document.removeEventListener('mousemove', handleMouseMove);\n        document.removeEventListener('mouseup', handleMouseUp);\n        // Re-enable text selection at the end of drag\n        document.body.style.userSelect = '';\n        onDragEnd();\n    };\n\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n}\n\nexport const handleDragAreaResize = (\n    row: AreaRowLayout,\n    horizontal: boolean,\n    areaIndex: number, // 1 is the first separator\n    setResizePreview: Dispatch<SetStateAction<ResizePreviewState | null>>\n) => {\n    // Check if we are in a detached window\n    const isDetached = useKarmycStore.getState().screens[useKarmycStore.getState().activeScreenId]?.areas.isDetached;\n    if (isDetached) {\n        return;\n    }\n\n    // Input validation\n    if (!row || !row.areas || row.areas.length === 0) {\n        console.error(\"Invalid row data for resize\");\n        return;\n    }\n\n    if (areaIndex < 1 || areaIndex >= row.areas.length) {\n        console.error(\"Invalid areaIndex for resize:\", { areaIndex, areasLength: row.areas.length });\n        return;\n    }\n\n    // --- Get active screen state at the beginning ---\n    const initialRootState = useKarmycStore.getState();\n    const initialActiveScreenId = initialRootState.activeScreenId;\n    const initialActiveScreenAreas = initialRootState.screens[initialActiveScreenId]?.areas;\n\n    if (!initialActiveScreenAreas || !initialActiveScreenAreas.layout || !initialActiveScreenAreas.rootId) {\n        console.error(\"Invalid active screen area state for resize:\", initialActiveScreenAreas);\n        return;\n    }\n    // Use these specific states for the rest\n    const activeLayout = initialActiveScreenAreas.layout;\n    const activeRootId = initialActiveScreenAreas.rootId;\n    // --- End active state retrieval ---\n\n    // Initial calculations based on active screen state\n    const rowToMinSize = computeAreaRowToMinSize(activeRootId, activeLayout);\n    const rootViewport = getAreaRootViewport();\n    if (!rootViewport) {\n        console.error(\"Unable to get root viewport\");\n        return;\n    }\n    const initialAreaToViewport = computeAreaToViewport(\n        activeLayout,\n        activeRootId,\n        rootViewport,\n    );\n\n    const a0 = row.areas[areaIndex - 1];\n    const a1 = row.areas[areaIndex];\n    if (!a0 || !a1) {\n        console.error('Invalid area indices:', { areaIndex, areas: row.areas });\n        return;\n    }\n\n    let v0 = initialAreaToViewport[a0.id];\n    let v1 = initialAreaToViewport[a1.id];\n    if (!v0 || !v1) {\n        console.error('Missing initial viewports:', { a0: a0.id, a1: a1.id, viewports: initialAreaToViewport });\n        // Maybe attempt a recalculation here if needed, or just return\n        return;\n    }\n\n    const getMinSize = (id: string) => {\n        const layoutItem = activeLayout[id];\n        if (!layoutItem) return 1;\n        if (layoutItem.type === \"area\") return 1;\n        const minSize = rowToMinSize[layoutItem.id];\n        return horizontal ? (minSize?.width ?? 1) : (minSize?.height ?? 1);\n    };\n\n    const m0 = getMinSize(a0.id);\n    const m1 = getMinSize(a1.id);\n    let sizeToShare = a0.size + a1.size;\n    if (isNaN(sizeToShare) || sizeToShare <= 0) {\n        sizeToShare = 1.0; // Default correction\n    }\n\n    const sharedViewport: Rect = {\n        width: horizontal ? v0.width + v1.width : v0.width,\n        height: !horizontal ? v0.height + v1.height : v0.height,\n        left: v0.left,\n        top: v0.top,\n    };\n\n    const viewportSize = horizontal ? sharedViewport.width : sharedViewport.height;\n    if (viewportSize <= 0) {\n        console.error(\"Invalid viewport size:\", viewportSize);\n        return;\n    }\n\n    const tMin0 = (AREA_MIN_CONTENT_WIDTH * m0) / viewportSize;\n    const tMin1 = (AREA_MIN_CONTENT_WIDTH * m1) / viewportSize;\n    if (tMin0 + tMin1 >= 0.99) {\n        console.warn('Not enough space to resize:', { tMin0, tMin1 });\n        return;\n    }\n\n    let timeoutId: ReturnType<typeof setTimeout> | null = null;\n    let lastUpdateTime = 0;\n    const minUpdateInterval = 16; // ~60fps\n    let animationFrameId: number | null = null;\n    let lastMousePosition: Vec2 | null = null;\n\n    const performGlobalUpdate = (sizes: number[]) => {\n        const now = performance.now();\n        if (now - lastUpdateTime < minUpdateInterval) {\n            return;\n        }\n        lastUpdateTime = now;\n        useKarmycStore.getState().setRowSizes({ rowId: row.id, sizes });\n    };\n\n    const updateFromMousePosition = (vec: Vec2) => {\n        if (!lastMousePosition) {\n            lastMousePosition = vec;\n            return;\n        }\n\n        const t0 = horizontal ? sharedViewport.left : sharedViewport.top;\n        const t1 = horizontal\n            ? sharedViewport.left + sharedViewport.width\n            : sharedViewport.top + sharedViewport.height;\n        const val = horizontal ? vec.x : vec.y;\n        const t = capToRange(tMin0, 1 - tMin1, (val - t0) / (t1 - t0));\n\n        // Update local preview IMMEDIATELY\n        setResizePreview({\n            rowId: row.id,\n            separatorIndex: areaIndex,\n            t: t\n        });\n\n        const tempFinalSizes = [t, 1 - t].map((v) => interpolate(0, sizeToShare, v));\n        if (!tempFinalSizes.some(s => isNaN(s) || s < 0)) {\n            const latestFinalPercentages = row.areas.map((_, i) => {\n                if (i === areaIndex - 1) return tempFinalSizes[0];\n                if (i === areaIndex) return tempFinalSizes[1];\n                const initialRowState = activeLayout[row.id] as AreaRowLayout | undefined;\n                return initialRowState?.areas?.[i]?.size || 0;\n            });\n            const sum = latestFinalPercentages.reduce((a, b) => a + b, 0);\n            if (sum > 0 && Math.abs(sum - 1.0) > 0.001) {\n                const normalizedPercentages = latestFinalPercentages.map(s => s / sum);\n                performGlobalUpdate(normalizedPercentages);\n            } else {\n                performGlobalUpdate(latestFinalPercentages);\n            }\n        }\n    };\n\n    const animate = () => {\n        if (lastMousePosition) {\n            updateFromMousePosition(lastMousePosition);\n        }\n        animationFrameId = requestAnimationFrame(animate);\n    };\n\n    const triggerDebouncedUpdate = (vec: Vec2) => {\n        lastMousePosition = vec;\n        if (!animationFrameId) {\n            animationFrameId = requestAnimationFrame(animate);\n        }\n    };\n\n    const cancelDebouncedUpdate = () => {\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n            timeoutId = null;\n        }\n        if (animationFrameId !== null) {\n            cancelAnimationFrame(animationFrameId);\n            animationFrameId = null;\n        }\n        lastMousePosition = null;\n    };\n\n    simpleDragHandler(\n        // onDrag (mousemove)\n        (e) => {\n            const vec = Vec2.fromEvent(e);\n            triggerDebouncedUpdate(vec);\n        },\n        // onDragEnd (mouseup)\n        () => {\n            cancelDebouncedUpdate();\n            setTimeout(() => setResizePreview(null), 0);\n        }\n    );\n};\n","import React, { Dispatch, SetStateAction } from \"react\";\nimport { AREA_BORDER_WIDTH, TOOLBAR_HEIGHT } from \"../utils/constants\";\nimport { useKarmycStore } from \"../store/areaStore\";\nimport { AreaRowLayout } from \"../types/areaTypes\";\nimport { Rect } from \"../types\";\nimport { handleDragAreaResize } from \"./handlers/areaDragResize\";\nimport { Ellipsis, EllipsisVertical } from 'lucide-react';\nimport { useTranslation } from '../hooks/useTranslation';\n\n\ninterface ResizePreviewState {\n    rowId: string;\n    separatorIndex: number;\n    t: number;\n}\n\ninterface OwnProps {\n    row: AreaRowLayout;\n    setResizePreview: Dispatch<SetStateAction<ResizePreviewState | null>>;\n    offset: number;\n}\n\ntype Props = OwnProps;\n\nexport const AreaRowSeparators: React.FC<Props> = props => {\n    const { row, setResizePreview, offset } = props;\n    const layout = useKarmycStore(state => state.screens[state.activeScreenId]?.areas.layout ?? {});\n    const rootId = useKarmycStore(state => state.screens[state.activeScreenId]?.areas.rootId);\n    const areaToViewport = useKarmycStore(state => state.screens[state.activeScreenId]?.areas.viewports);\n    const resizableAreas = useKarmycStore(state => state.options?.resizableAreas ?? true);\n    const { t } = useTranslation();\n\n    // Do not render separators for stacked rows or if resizableAreas is false\n    if (row.orientation === 'stack') {\n        return null;\n    }\n\n    // Basic validation before continuing\n    if (!row || !row.areas || row.areas.length <= 1 || !layout || !rootId) {\n        return null;\n    }\n\n    // Check that all necessary viewports are available\n    const allViewportsAvailable = row.areas.every(area =>\n        areaToViewport[area.id] &&\n        layout[area.id]\n    );\n\n    // If viewports are missing, don't try to render separators\n    if (!allViewportsAvailable) {\n        return null;\n    }\n\n    // Create an array to collect separators\n    const separators = [];\n\n    // Improved method: don't use slice(1) but calculate\n    // position between two adjacent areas\n    for (let i = 0; i < row.areas.length - 1; i++) {\n        const currentArea = row.areas[i];\n        const nextArea = row.areas[i + 1];\n\n        if (!currentArea || !nextArea) continue;\n\n        const currentViewport = areaToViewport[currentArea.id];\n        const nextViewport = areaToViewport[nextArea.id];\n\n        if (!layout[currentArea.id] || !layout[nextArea.id] ||\n            !currentViewport || !nextViewport) {\n            continue;\n        }\n\n        // Determine orientation\n        const horizontal = row.orientation === \"horizontal\";\n\n        // Calculate separator position based on two adjacent viewports\n        let separatorRect: Rect;\n\n        if (horizontal) {\n            separatorRect = {\n                left: nextViewport.left - AREA_BORDER_WIDTH,\n                top: nextViewport.top + TOOLBAR_HEIGHT - offset,\n                width: AREA_BORDER_WIDTH * 2,\n                height: Math.max(nextViewport.height - TOOLBAR_HEIGHT, 5)\n            };\n        } else {\n            separatorRect = {\n                left: nextViewport.left,\n                top: nextViewport.top - AREA_BORDER_WIDTH - offset,\n                width: Math.max(nextViewport.width, 5),\n                height: AREA_BORDER_WIDTH * 2\n            };\n        }\n\n        // Ensure calculated dimensions are valid numbers\n        if (isNaN(separatorRect.left) || isNaN(separatorRect.top) || isNaN(separatorRect.width) || isNaN(separatorRect.height)) {\n            continue;\n        }\n        // Ensure dimensions are not negative\n        separatorRect.width = Math.max(0, separatorRect.width);\n        separatorRect.height = Math.max(0, separatorRect.height);\n\n        const handleMouseDown = (e: React.MouseEvent) => {\n            e.stopPropagation();\n            handleDragAreaResize(row, horizontal, i + 1, setResizePreview);\n        };\n\n        separators.push(\n            <div\n                key={`sep-${currentArea.id}-${nextArea.id}`}\n                className={`area-separator ${horizontal ? 'area-separator--horizontal' : ''}`}\n                style={{\n                    ...separatorRect,\n                    flexDirection: !horizontal ? 'row' : 'column',\n                    zIndex: horizontal ? 2001 : 2000,\n                    cursor: resizableAreas ? undefined : 'default'\n                }}\n                onMouseDown={resizableAreas ? handleMouseDown : undefined}\n                title={t('area.separator.resize', 'Resize')}\n            >\n                {resizableAreas && (\n                    !horizontal ?\n                        <><Ellipsis size={32} /><Ellipsis size={32} /></>\n                        :\n                        <><EllipsisVertical size={32} /><EllipsisVertical size={32} />\n                        </>\n\n                )}\n            </div>\n        );\n    }\n\n    return <>{separators}</>;\n};\n","import React, { useEffect, useMemo } from \"react\";\nimport { Vec2 } from \"../utils\";\nimport { AreaToOpen } from \"../types/areaTypes\";\nimport { PlaceArea } from \"../utils/areaUtils\";\nimport { useKarmycStore } from \"../store/areaStore\";\nimport useAreaDragAndDrop from \"../hooks/useAreaDragAndDrop\";\nimport { AREA_PLACEMENT_TRESHOLD } from \"../utils/constants\";\n\ninterface DropZoneProps {\n    areaToOpen: AreaToOpen;\n    dimensions: Vec2;\n    setAreaToOpenDimensions: (dimensions: Vec2) => void;\n}\n\nexport const DropZone: React.FC<DropZoneProps> = React.memo(({\n    dimensions,\n    setAreaToOpenDimensions\n}) => {\n    const setViewports = useKarmycStore(state => state.setViewports);\n    const areaToViewport = useKarmycStore(state => state.screens[state.activeScreenId]?.areas.viewports);\n    \n    const {\n        handleDragOver,\n        handleDrop,\n        areaToOpenTargetId,\n        areaToOpenTargetViewport,\n        calculatedPlacement\n    } = useAreaDragAndDrop();\n\n    useEffect(() => {\n        if (!areaToOpenTargetId || !areaToOpenTargetViewport) return;\n        const newDimensions = Vec2.new(areaToOpenTargetViewport.width, areaToOpenTargetViewport.height);\n        if (newDimensions.x !== dimensions.x || newDimensions.y !== dimensions.y) {\n            setAreaToOpenDimensions(newDimensions);\n        }\n    }, [areaToOpenTargetId, areaToOpenTargetViewport, dimensions, setAreaToOpenDimensions]);\n\n    // Update viewports\n    useEffect(() => {\n        setViewports(areaToViewport);\n    }, [areaToViewport, setViewports]);\n\n    const placementLinesMemo = useMemo(() => {\n        if (!areaToOpenTargetViewport) return { lines: [], placementLines: {} as Record<PlaceArea, Vec2[]> };\n        const viewport = areaToOpenTargetViewport;\n        const treshold = Math.min(viewport.width, viewport.height) * AREA_PLACEMENT_TRESHOLD;\n        const O = Vec2.new(treshold, treshold);\n        const w = viewport.width; const h = viewport.height;\n        const nw_0 = Vec2.new(0, 0); const ne_0 = Vec2.new(w, 0);\n        const se_0 = Vec2.new(w, h); const sw_0 = Vec2.new(0, h);\n        const nw_1 = nw_0.add(O); const ne_1 = ne_0.add(O.scaleX(-1));\n        const se_1 = se_0.add(O.scale(-1)); const sw_1 = sw_0.add(O.scaleY(-1));\n        const lines = [[nw_0, nw_1], [ne_0, ne_1], [sw_0, sw_1], [se_0, se_1], [nw_1, ne_1], [ne_1, se_1], [se_1, sw_1], [sw_1, nw_1]];\n        const placementLines: Record<PlaceArea, Vec2[]> = {\n            left: [nw_0, nw_1, sw_1, sw_0], top: [nw_0, ne_0, ne_1, nw_1],\n            right: [ne_1, ne_0, se_0, se_1], bottom: [sw_0, sw_1, se_1, se_0],\n            stack: [nw_1, ne_1, se_1, sw_1],\n        };\n        return { lines, placementLines };\n    }, [areaToOpenTargetViewport]);\n\n    const pathData = useMemo(() => {\n        if (!areaToOpenTargetViewport || !placementLinesMemo.placementLines || !placementLinesMemo.placementLines[calculatedPlacement]) return \"\";\n        const hlines = placementLinesMemo.placementLines[calculatedPlacement];\n        return hlines.map((p: Vec2) => [p.x, p.y].join(\",\")).map((str: string, i: number) => [i === 0 ? \"M\" : \"L\", str].join(\" \")).join(\" \") + \" Z\";\n    }, [areaToOpenTargetViewport, placementLinesMemo.placementLines, calculatedPlacement]);\n\n    if (!areaToOpenTargetViewport) {\n        return null;\n    }\n\n    return (\n        <div\n            className={`area-to-open-overlay`}\n            onDragOver={handleDragOver}\n            onDrop={handleDrop}\n        >\n\n            {areaToOpenTargetViewport && (\n                <svg\n                    width={areaToOpenTargetViewport.width}\n                    height={areaToOpenTargetViewport.height}\n                    className=\"area-to-open-overlay__placement\"\n                    style={{\n                        left: areaToOpenTargetViewport.left,\n                        top: areaToOpenTargetViewport.top,\n                    }}\n                >\n                    {placementLinesMemo.lines.map(([p0, p1], i) => (\n                        <line key={i} x1={p0.x} y1={p0.y} x2={p1.x} y2={p1.y} />\n                    ))}\n                    <path d={pathData} />\n                </svg>\n            )}\n        </div>\n    );\n}); \n","import React, { useMemo, useState } from \"react\";\n\nimport { Vec2 } from \"../utils\";\nimport { useKarmycStore } from \"../store/areaStore\";\nimport { AreaPreview } from \"./AreaPreview\";\nimport { DropZone } from \"./DropZone\";\n\n\ninterface OwnProps {}\n\nexport const AreaToOpenPreview: React.FC<OwnProps> = React.memo((): React.ReactElement | null => {\n    // Lire chaque partie de l'état séparément pour éviter les problèmes de référence d'objet\n    const areaToOpen = useKarmycStore(state => state.screens[state.activeScreenId]?.areas.areaToOpen);\n    const initialDimensions = useMemo(() => Vec2.new(100, 100), []);\n    const [areaToOpenDimensions, setAreaToOpenDimensions] = useState(initialDimensions);\n    \n    if (!areaToOpen) {\n        return null;\n    }\n\n    return (\n        <>\n            <AreaPreview\n                areaToOpen={areaToOpen}\n                dimensions={areaToOpenDimensions}\n            />\n            <DropZone\n                areaToOpen={areaToOpen}\n                dimensions={areaToOpenDimensions}\n                setAreaToOpenDimensions={setAreaToOpenDimensions}\n            />\n        </>\n    );\n});\n","import React from \"react\";\nimport { ArrowBigDown } from 'lucide-react';\nimport { CardinalDirection } from \"../types/directions\";\nimport { useTranslation } from '../hooks/useTranslation';\n\ninterface Props {\n    viewport: { left: number; top: number; width: number; height: number };\n    movingInDirection: CardinalDirection;\n}\n\nexport const JoinAreaPreview: React.FC<Props> = props => {\n    const { viewport, movingInDirection } = props;\n    const { t } = useTranslation();\n    const arrowWidth = Math.min(256, Math.min(viewport.width, viewport.height) * 5);\n    return (\n        <div\n            className=\"join-area-preview\"\n            style={{ left: viewport.left, top: viewport.top, width: viewport.width, height: viewport.height }}\n        >\n            <div className={`join-area-preview__arrow-container join-area-preview__arrow-container--${movingInDirection}`}>\n                <div\n                    className={`join-area-preview__arrow join-area-preview__arrow--${movingInDirection}`}\n                    style={{ width: arrowWidth, height: arrowWidth }}\n                >\n                    <ArrowBigDown size={arrowWidth + 'px'} style={{ color: 'transparent' }} />\n                </div>\n            </div>\n            <div className=\"join-area-preview-content\">\n                {t('area.join.preview', 'Join areas')}\n            </div>\n        </div>\n    );\n};\n","import React from \"react\";\nimport { ControlledMenu, MenuItem, SubMenu } from '@szhsin/react-menu';\n\nimport { useContextMenuStore } from '../store/contextMenuStore';\nimport { actionRegistry } from '../actions/handlers/actionRegistry';\nimport { ContextMenuItem } from '../types';\nimport { useTranslation } from '../hooks/useTranslation';\n\nexport const ContextMenu: React.FC = () => {\n  const isVisible = useContextMenuStore((state) => state.isVisible && state.menuType === 'default');\n  const items = useContextMenuStore((state) => state.items);\n  const position = useContextMenuStore((state) => state.position);\n  const closeContextMenu = useContextMenuStore((state) => state.closeContextMenu);\n  const metadata = useContextMenuStore((state) => state.metadata);\n  const menuClassName = useContextMenuStore((state) => state.menuClassName);\n  const { t } = useTranslation();\n\n  // To be adapted according to business logic to trigger the action\n  const handleAction = (actionId: string, itemMetadata?: Record<string, any>) => {\n    actionRegistry.executeAction(actionId, { ...metadata, ...itemMetadata });\n    if (closeContextMenu) closeContextMenu();\n  };\n\n  // Recursive utility function to generate items and submenus\n  const renderMenuItems = (items: ContextMenuItem[], handleAction: (actionId: string, metadata?: Record<string, any>, option?: ContextMenuItem) => void) => {\n    return items.map((item) => {\n      if (item.children && item.children.length > 0) {\n        return (\n          <SubMenu key={item.id} label={t(`menu.${item.id}.label`, item.label)} disabled={item.disabled}>\n            {renderMenuItems(item.children, handleAction)}\n          </SubMenu>\n        );\n      }\n      // Visual separator\n      if (item.actionId === 'area.separator' || item.label.match(/^[-\\u2500]+$/)) {\n        return <div key={item.id} style={{ margin: '4px 0', borderBottom: '1px solid #ccc' }} />;\n      }\n      return (\n        <MenuItem\n          key={item.id}\n          disabled={item.disabled}\n          onClick={() => handleAction(item.actionId, item.metadata, item)}\n        >\n          {item.icon && React.createElement(item.icon)}\n          {t(`menu.${item.id}.label`, item.label)}\n        </MenuItem>\n      );\n    });\n  };\n\n  if (!isVisible) return null;\n\n  return (\n    <ControlledMenu\n      anchorPoint={position}\n      state={isVisible ? 'open' : 'closed'}\n      onClose={closeContextMenu}\n      transition\n      direction=\"right\"\n      menuClassName={menuClassName}\n    >\n      {renderMenuItems(items, handleAction)}\n    </ControlledMenu>\n  );\n};\n","import React from 'react';\nimport { ContextMenu } from '../components/ContextMenu';\nimport { SwitchAreaTypeContextMenu } from '../components/SwitchAreatypeContextMenu';\n\nexport const ContextMenuProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {  \n    return (\n        <>\n            {children}\n            <ContextMenu />\n            <SwitchAreaTypeContextMenu />\n        </>\n    );\n}; \n","import { useEffect } from 'react';\nimport { useKarmycStore } from '../store/areaStore';\n\n/**\n * This component removes the detached screen from the store when the window is closed.\n * It should be mounted in all windows, but only acts if the current screen is detached.\n */\nexport function DetachedWindowCleanup() {\n  const activeScreenId = useKarmycStore((s) => s.activeScreenId);\n  const isDetached = useKarmycStore((s) => s.screens[activeScreenId]?.isDetached);\n  const removeScreen = useKarmycStore((s) => s.removeScreen);\n\n  useEffect(() => {\n    if (!isDetached) return;\n    const handleUnload = () => {\n      removeScreen(activeScreenId);\n    };\n    window.addEventListener('beforeunload', handleUnload);\n    return () => window.removeEventListener('beforeunload', handleUnload);\n  }, [activeScreenId, isDetached, removeScreen]);\n\n  return null;\n} \n","import { create } from 'zustand';\r\n\r\ninterface HistoryEntry {\r\n    id: string;\r\n    type: string;\r\n    payload: any;\r\n    timestamp: number;\r\n    description: string;\r\n}\r\n\r\ninterface SpaceHistoryState {\r\n    entries: HistoryEntry[];\r\n    addEntry: (entry: HistoryEntry) => void;\r\n    clearHistory: () => void;\r\n}\r\n\r\nexport const spaceHistoryStore = create<SpaceHistoryState>((set) => ({\r\n    entries: [],\r\n    addEntry: (entry) => set((state) => ({ entries: [...state.entries, entry] })),\r\n    clearHistory: () => set({ entries: [] })\r\n})); \r\n","import { Action, ActionPriority, IActionPlugin } from '../types/actions';\r\nimport { useTranslation } from '../hooks/useTranslation';\r\nimport { spaceHistoryStore } from '../store/spaceHistoryStore';\r\n\r\n/**\r\n * List of action types that must be recorded in the history\r\n * Only these actions will be available for undo/redo\r\n */\r\nconst HISTORY_ACTION_TYPES = [\r\n    'area/addArea',\r\n    'area/removeArea',\r\n    'area/updateArea',\r\n    'area/moveArea',\r\n    'area/resizeArea',\r\n    'composition/update',\r\n    'composition/addElement',\r\n    'composition/removeElement',\r\n    'composition/updateElement',\r\n    'project/update',\r\n    // Drawing actions\r\n    'draw/addLine',\r\n    'draw/updateLine',\r\n    'draw/removeLine',\r\n    'draw/updateStrokeWidth',\r\n    'draw/updateColor',\r\n    'draw/updateZoom',\r\n    'draw/updatePan',\r\n    'draw/clearCanvas'\r\n];\r\n\r\n/**\r\n * Plugin that manages the action history\r\n * Records actions in the history to allow undo/redo\r\n */\r\nexport const historyPlugin: IActionPlugin = {\r\n    id: 'history',\r\n    priority: ActionPriority.HIGH, // High priority to run before other plugins\r\n    actionTypes: HISTORY_ACTION_TYPES, // List of action types to record\r\n    handler: (action: Action) => {\r\n        // Record the action in the history\r\n        const { type, payload } = action;\r\n\r\n        // Generate a unique identifier for this history action\r\n        const historyEntryId = `${type}-${Date.now()}`;\r\n\r\n        // Record the history entry with important metadata\r\n        const historyEntry = {\r\n            id: historyEntryId,\r\n            type,\r\n            payload,\r\n            timestamp: Date.now(),\r\n            description: getActionDescription(type, payload)\r\n        };\r\n\r\n        // Add to history\r\n        spaceHistoryStore.getState().addEntry(historyEntry);\r\n    }\r\n};\r\n\r\n/**\r\n * Generates a human-readable description for an action\r\n * Used to display messages in the history UI\r\n */\r\nexport function getActionDescription(type: string, payload: any): string {\r\n    const { t } = useTranslation();\r\n    \r\n    switch (type) {\r\n    case 'area/addArea':\r\n        return t('action.area.add', `Add area ${payload.type || ''}`);\r\n    case 'area/removeArea':\r\n        return t('action.area.remove', 'Remove area');\r\n    case 'area/updateArea':\r\n        return t('action.area.update', 'Update area');\r\n    case 'area/moveArea':\r\n        return t('action.area.move', 'Move area');\r\n    case 'area/resizeArea':\r\n        return t('action.area.resize', 'Resize area');\r\n    case 'composition/addElement':\r\n        return t('action.composition.add', `Add element ${payload.elementType || ''}`);\r\n    case 'composition/removeElement':\r\n        return t('action.composition.remove', 'Remove element');\r\n    case 'composition/updateElement':\r\n        return t('action.composition.update', 'Update element');\r\n    // Drawing actions\r\n    case 'draw/addLine':\r\n        return t('action.draw.addLine', 'Add line');\r\n    case 'draw/updateLine':\r\n        return t('action.draw.updateLine', 'Edit line');\r\n    case 'draw/removeLine':\r\n        return t('action.draw.removeLine', 'Remove line');\r\n    case 'draw/updateStrokeWidth':\r\n        return t('action.draw.updateStrokeWidth', `Change stroke width: ${payload.oldValue} → ${payload.newValue}`);\r\n    case 'draw/updateColor':\r\n        return t('action.draw.updateColor', `Change color: ${payload.oldValue} → ${payload.newValue}`);\r\n    case 'draw/clearCanvas':\r\n        return t('action.draw.clearCanvas', 'Clear drawing');\r\n    default:\r\n        return t('action.unknown', `Action ${type}`);\r\n    }\r\n} \r\n","import { useCallback } from 'react';\nimport { AreaTypeValue, AREA_ROLE } from '../types/actions';\nimport { useKarmycStore } from '../store/areaStore';\nimport { IArea } from '../types/areaTypes';\nimport { useSpaceStore } from '../store/spaceStore';\nimport { areaRegistry } from '../store/registries/areaRegistry';\n\n/**\n * Hook for managing areas\n * Provides functions to manipulate areas and access their state\n */\nexport function useArea() {\n    const {\n        addArea,\n        removeArea: removeAreaAction,\n        setActiveArea,\n        updateArea,\n        getActiveArea,\n        getAreaById,\n        getAllAreas,\n        getAreaErrors\n    } = useKarmycStore();\n\n    const createArea = useCallback((type: AreaTypeValue, state: any, position?: { x: number, y: number }, id?: string): string => {\n        // Vérifier si le type est valide\n        const registeredTypes = areaRegistry.getRegisteredTypes();\n        if (!registeredTypes.has(type)) {\n            throw new Error(`Invalid area type: ${type}`);\n        }\n\n        const area: IArea<AreaTypeValue> = {\n            id: id || '',\n            type,\n            state,\n            position\n        };\n\n        // Si c'est une area LEAD, on s'assure qu'elle a un espace\n        const roleMap = (areaRegistry as any)._roleMap || {};\n        if (roleMap[type] === AREA_ROLE.LEAD) {\n            const spaces = useSpaceStore.getState().spaces;\n            const existingSpaces = Object.keys(spaces);\n            if (existingSpaces.length > 0) {\n                // Utiliser le dernier espace actif ou le premier disponible\n                const activeSpaceId = useSpaceStore.getState().activeSpaceId;\n                area.spaceId = activeSpaceId || existingSpaces[0];\n            } else {\n                // Create a new space only if there are none\n                const newSpaceId = useSpaceStore.getState().addSpace({\n                    name: `Space for ${type}`,\n                    sharedState: {}\n                });\n                if (newSpaceId) {\n                    area.spaceId = newSpaceId;\n                }\n            }\n        }\n        return addArea(area);\n    }, [addArea]);\n\n    const removeArea = useCallback((id: string) => {\n        removeAreaAction(id);\n    }, [removeAreaAction]);\n\n    const setActive = useCallback((id: string | null) => {\n        setActiveArea(id);\n    }, [setActiveArea]);\n\n    const update = useCallback((id: string, changes: Partial<IArea<AreaTypeValue>>) => {\n        updateArea({ id, ...changes });\n    }, [updateArea]);\n\n    const getActive = useCallback(() => {\n        return getActiveArea();\n    }, [getActiveArea]);\n\n    const getById = useCallback((id: string) => {\n        return getAreaById(id);\n    }, [getAreaById]);\n\n    const getAll = useCallback(() => {\n        return getAllAreas();\n    }, [getAllAreas]);\n\n    const getErrors = useCallback(() => {\n        return getAreaErrors();\n    }, [getAreaErrors]);\n\n    return {\n        createArea,\n        removeArea,\n        setActive,\n        update,\n        getActive,\n        getById,\n        getAll,\n        getErrors\n    };\n} \n","import React, { useEffect, useRef } from 'react';\nimport { historyPlugin } from '../types/spaceTypes';\nimport { actionRegistry } from '../actions/handlers/actionRegistry';\nimport { useArea } from '../hooks/useArea';\nimport { useKarmycStore } from '../store/areaStore';\nimport { AreaRowLayout } from '../types/areaTypes';\nimport { IKarmycOptions } from '../types/karmyc';\nimport { IActionPlugin } from '../types/actions';\nimport { validateArea } from '../utils/validation';\n\ninterface IKarmycInitializerProps {\n    options?: IKarmycOptions;\n    children?: React.ReactNode;\n    onError?: (error: Error) => void;\n}\n\nexport const KarmycInitializer: React.FC<IKarmycInitializerProps> = ({ options = {}, children, onError }) => {\n    const initialized = useRef(false);\n    const { createArea } = useArea();\n\n    useEffect(() => {\n        if (initialized.current) {\n            return;\n        }\n        initialized.current = true;\n\n        try {\n            // Register default plugins\n            const defaultPlugins = [historyPlugin];\n            const customPlugins = options.plugins || [];\n            const allPlugins = [...defaultPlugins, ...customPlugins];\n\n            const pluginIds: string[] = [];\n            allPlugins.forEach(plugin => {\n                if (plugin && typeof plugin === 'object' && plugin.id) {\n                    actionRegistry.registerPlugin(plugin);\n                    pluginIds.push(plugin.id);\n                }\n            });\n\n            if (options.validators) {\n                options.validators.forEach(({ actionType, validator }) => {\n                    if (actionType && typeof validator === 'function') {\n                        actionRegistry.registerValidator(actionType, validator);\n                    }\n                });\n            }\n\n            const storeState = useKarmycStore.getState();\n            const activeScreenId = storeState.activeScreenId;\n            const activeScreenAreasState = storeState.screens[activeScreenId]?.areas;\n            const isAlreadyInitialized = activeScreenAreasState?.rootId || Object.keys(activeScreenAreasState?.areas || {}).length > 0;\n\n            if (!isAlreadyInitialized) {\n                const areasToInitialize = options.initialAreas || [];\n                const newAreaIds: string[] = [];\n\n                areasToInitialize.forEach((areaConfig, index) => {\n                    if (!areaConfig || typeof areaConfig !== 'object') {\n                        const error = new Error(`Invalid area config at index ${index}`);\n                        console.error('[KarmycInitializer] Invalid area config', error);\n                        onError?.(error);\n                        return;\n                    }\n\n                    if (!areaConfig.type || typeof areaConfig.type !== 'string') {\n                        const error = new Error(`Invalid area type for area at index ${index}`);\n                        console.error('[KarmycInitializer] Invalid area config', error);\n                        onError?.(error);\n                        return;\n                    }\n\n                    // Valider la configuration de la zone\n                    const validation = validateArea(areaConfig);\n                    if (!validation.isValid) {\n                        const error = new Error(`Invalid area configuration: ${validation.errors.join(', ')}`);\n                        console.error('[KarmycInitializer] Invalid area config', error);\n                        onError?.(error);\n                        return;\n                    }\n\n                    let newId: string | undefined;\n                    try {\n                        newId = createArea(\n                            areaConfig.type,\n                            areaConfig.state || {},\n                            undefined,\n                            areaConfig.id\n                        );\n                    } catch (error) {\n                        console.error('[KarmycInitializer] Invalid area config', error);\n                        onError?.(error instanceof Error ? error : new Error(String(error)));\n                        return;\n                    }\n                    if (newId) {\n                        newAreaIds.push(newId);\n                    } else {\n                        const error = new Error(`Failed to create area at index ${index}`);\n                        console.error('[KarmycInitializer] Invalid area config', error);\n                        onError?.(error);\n                    }\n                });\n\n                if (newAreaIds.length > 0) {\n                    const defaultRowLayout: AreaRowLayout = {\n                        id: 'root',\n                        type: 'area_row',\n                        orientation: 'horizontal',\n                        areas: newAreaIds.map(areaId => ({ id: areaId, size: 1 / newAreaIds.length }))\n                    };\n\n                    useKarmycStore.setState(state => {\n                        if (!state.screens[state.activeScreenId]?.areas) {\n                            const error = new Error(`Active screen areas ${state.activeScreenId} not found during layout update.`);\n                            onError?.(error);\n                            return state;\n                        }\n\n                        const newLayoutMap = {\n                            ...(state.screens[state.activeScreenId].areas.layout || {}),\n                            ['root']: defaultRowLayout,\n                            ...newAreaIds.reduce((acc, id) => {\n                                if (!acc[id]) {\n                                    acc[id] = { type: 'area', id: id };\n                                }\n                                return acc;\n                            }, {} as Record<string, AreaRowLayout | { type: 'area'; id: string }>)\n                        };\n\n                        return {\n                            ...state,\n                            screens: {\n                                ...state.screens,\n                                [state.activeScreenId]: {\n                                    ...state.screens[state.activeScreenId],\n                                    areas: {\n                                        ...state.screens[state.activeScreenId].areas,\n                                        rootId: 'root',\n                                        layout: newLayoutMap\n                                    }\n                                }\n                            }\n                        };\n                    }, false, 'KarmycInitializer/setDefaultLayout');\n                }\n            }\n        } catch (error) {\n            console.error('[KarmycInitializer] Invalid area config', error);\n            onError?.(error instanceof Error ? error : new Error(String(error)));\n        }\n\n        // Cleanup\n        return () => {\n            try {\n                const storeState = useKarmycStore.getState();\n                const options = storeState.options as IKarmycOptions;\n                const pluginIds = (options.plugins || []).map((p: IActionPlugin) => p.id);\n                pluginIds.forEach((id: string) => {\n                    if (id) {\n                        actionRegistry.unregisterPlugin(id);\n                    }\n                });\n            } catch (error) {\n                console.error('[KarmycInitializer] Error during cleanup:', error);\n                onError?.(error instanceof Error ? error : new Error(String(error)));\n            }\n        };\n    }, [onError]); // Add onError to dependencies\n\n    // Toujours rendre les enfants, même en cas d'erreur\n    return <>{children}</>;\n}; \n","export interface KeyboardShortcut {\n    key: string;\n    name: string;\n    fn: (areaId: string, params: any) => void;\n    modifierKeys?: string[];\n    optionalModifierKeys?: string[];\n    history?: boolean;\n    shouldAddToStack?: (areaId: string, prevState: any, nextState: any) => boolean;\n    isGlobal?: boolean;\n    /**\n     * Le type d'aire auquel ce raccourci est associé\n     * Requis pour les raccourcis non-globaux\n     */\n    areaType?: string;\n}\n\n\n/**\n * Keyboard shortcuts registry for each area type\n * Allows registering, retrieving and removing shortcuts\n */\ninterface KeyboardShortcutRegistry {\n    registerShortcuts: (areaType: string, shortcuts: KeyboardShortcut[]) => void;\n    getShortcuts: (areaType: string) => KeyboardShortcut[];\n    clearShortcuts: (areaType: string) => void;\n    unregisterShortcuts: (areaType: string) => void;\n\n    // Simplified methods for direct usage\n    register: (shortcut: KeyboardShortcut) => string; // Returns a unique ID\n    remove: (id: string) => boolean; // Returns true if the shortcut was found and removed\n\n    // New method to get all shortcuts\n    getAllShortcuts: () => KeyboardShortcut[];\n}\n\n// In-memory storage of shortcuts by area type\nconst shortcutsStorage = new Map<string, KeyboardShortcut[]>();\n\n// Storage of global shortcuts with ID\nconst globalShortcuts = new Map<string, KeyboardShortcut>();\nlet nextId = 1;\n\nexport const keyboardShortcutRegistry: KeyboardShortcutRegistry = {\n    registerShortcuts: (areaType, shortcuts) => {\n        shortcutsStorage.set(areaType, shortcuts);\n    },\n\n    getShortcuts: (areaType) => {\n        return shortcutsStorage.get(areaType) || [];\n    },\n\n    clearShortcuts: (areaType) => {\n        shortcutsStorage.delete(areaType);\n    },\n\n    unregisterShortcuts: (areaType) => {\n        shortcutsStorage.delete(areaType);\n    },\n\n    // Adding a global shortcut with ID generation\n    register: (shortcut) => {\n        const id = `kbd-${nextId++}`;\n        globalShortcuts.set(id, shortcut);\n        return id;\n    },\n\n    // Removing a shortcut by ID\n    remove: (id) => {\n        return globalShortcuts.delete(id);\n    },\n\n    // New method to get all shortcuts\n    getAllShortcuts: () => {\n        const allShortcuts: KeyboardShortcut[] = [];\n        \n        // Ajouter les raccourcis par type d'aire\n        for (const shortcuts of shortcutsStorage.values()) {\n            allShortcuts.push(...shortcuts);\n        }\n        \n        // Ajouter les raccourcis globaux\n        for (const shortcut of globalShortcuts.values()) {\n            allShortcuts.push(shortcut);\n        }\n        \n        return allShortcuts;\n    }\n}; \n","import React, { useEffect, useRef, createContext } from 'react';\nimport { useKarmycStore, initializeKarmycStore } from '../store/areaStore';\nimport { IKarmycProviderProps, IKarmycOptions } from '../types/karmyc';\nimport { KarmycInitializer } from './KarmycInitializer';\nimport { keyboardShortcutRegistry } from '../store/registries/keyboardShortcutRegistry';\nimport { checkShouldPreventDefault, ModifierKey } from '../utils/keyboard';\nimport { initializeTranslation } from '../hooks/useTranslation';\n\nimport '@szhsin/react-menu/dist/index.css';\nimport '@szhsin/react-menu/dist/transitions/zoom.css';\n\ninterface KarmycContextType {\n    options: IKarmycOptions;\n}\n\nexport const KarmycContext = createContext<KarmycContextType>({ options: {} });\n\n/**\n * Main component that provides the global context for the layout system\n * \n * This component encapsulates:\n * - System initialization with specified options\n * - The context menu provider\n * - URL synchronization for active screen\n */\nexport const KarmycProvider: React.FC<IKarmycProviderProps> = ({\n    children,\n    options = {},\n    onError\n}) => {\n    const isInitialLoad = useRef(true);\n    const isUpdatingUrl = useRef(false);\n    const lastActiveScreenId = useRef<string | null>(null);\n    const lastScreenCount = useRef<number>(0);\n    const lastScreenOrder = useRef<string[]>([]);\n\n    const handleInitializationError = (error: Error) => {\n        console.error('[KarmycInitializer] Error during initialization:', error);\n        onError?.(error);\n    };\n\n    // Initialiser le store explicitement\n    useEffect(() => {\n        initializeKarmycStore(options);\n        // Initialiser le système de traduction\n        if (options.t) {\n            initializeTranslation(options.t);\n        }\n    }, [options]);\n\n    useEffect(() => {\n        document.addEventListener(\"contextmenu\", (e) => e.preventDefault(), false);\n    }, []);\n\n    // Effect 1: Read URL on initial load and set active screen\n    useEffect(() => {\n        const params = new URLSearchParams(window.location.search);\n        const screenIdFromUrl = params.get('screen');\n\n        if (screenIdFromUrl) {\n            const state = useKarmycStore.getState();\n            if (state.screens[screenIdFromUrl]) {\n                // Set state directly, effect 2 will handle URL update if needed after init\n                useKarmycStore.setState({ activeScreenId: screenIdFromUrl });\n                lastActiveScreenId.current = screenIdFromUrl;\n            } else {\n                console.warn(`[KarmycProvider] Screen ID '${screenIdFromUrl}' from URL not found in store.`);\n                // Remove invalid param from URL\n                const url = new URL(window.location.href);\n                url.searchParams.delete('screen');\n                window.history.replaceState({}, '', url.toString());\n            }\n        }\n        // Mark initial load as done *after* potential state set\n        const timer = setTimeout(() => {\n            isInitialLoad.current = false;\n        }, 0);\n        return () => clearTimeout(timer);\n    }, []); // Run only once on mount\n\n    // Effect 2: Update URL when activeScreenId changes in the store\n    const activeScreenId = useKarmycStore(state => state.activeScreenId);\n    const screens = useKarmycStore(state => state.screens);\n    useEffect(() => {\n        // Don't update URL during the very initial load/check phase\n        if (isInitialLoad.current || isUpdatingUrl.current) {\n            return;\n        }\n\n        const state = useKarmycStore.getState();\n        const currentScreenCount = Object.keys(state.screens).length;\n\n        // Check if the number of screens has changed (screen removal)\n        if (currentScreenCount !== lastScreenCount.current) {\n            const currentScreenOrder = Object.keys(state.screens).sort((a, b) => parseInt(a) - parseInt(b));\n\n            // If it's the first time, initialize lastScreenOrder\n            if (lastScreenOrder.current.length === 0) {\n                lastScreenOrder.current = currentScreenOrder;\n                lastScreenCount.current = currentScreenCount;\n                return;\n            }\n\n            // Find the removed screen\n            const deletedScreenId = lastScreenOrder.current.find(id => !currentScreenOrder.includes(id));\n            if (deletedScreenId) {\n                const deletedScreenIndex = lastScreenOrder.current.indexOf(deletedScreenId);\n                const oldActiveIndex = lastScreenOrder.current.indexOf(activeScreenId);\n\n                // If the active screen was after the removed screen, we need to adjust its index\n                if (oldActiveIndex > deletedScreenIndex) {\n                    const newIndex = oldActiveIndex - 1;\n                    const newActiveScreenId = currentScreenOrder[newIndex];\n                    if (newActiveScreenId) {\n                        useKarmycStore.setState({ activeScreenId: newActiveScreenId });\n                        lastActiveScreenId.current = newActiveScreenId;\n                    }\n                }\n            }\n\n            lastScreenOrder.current = currentScreenOrder;\n            lastScreenCount.current = currentScreenCount;\n            return; // Exit the effect after renumbering\n        }\n\n        // Check if the active screen is valid (only if no renumbering)\n        if (!state.screens[activeScreenId]) {\n            console.warn(`[KarmycProvider] Invalid active screen ID '${activeScreenId}', resetting to '1'`);\n            useKarmycStore.setState({ activeScreenId: '1' });\n            return;\n        }\n\n        // Avoid unnecessary updates\n        if (lastActiveScreenId.current === activeScreenId) {\n            return;\n        }\n\n        const currentUrl = new URL(window.location.href);\n        const currentScreenParam = currentUrl.searchParams.get('screen');\n\n        if (activeScreenId !== currentScreenParam) {\n            isUpdatingUrl.current = true;\n            if (activeScreenId) {\n                currentUrl.searchParams.set('screen', activeScreenId);\n            } else {\n                currentUrl.searchParams.delete('screen');\n            }\n            // Use replaceState to avoid polluting browser history\n            window.history.replaceState({}, '', currentUrl.toString());\n            isUpdatingUrl.current = false;\n            lastActiveScreenId.current = activeScreenId;\n        }\n    }, [activeScreenId, screens]); // Re-run when activeScreenId or screens change\n\n    // Effect 3: Listen for localStorage changes to sync space-storage across tabs\n\n    // Effect 4: Initialize keyboard shortcuts system\n    useEffect(() => {\n        const handleKeyDown = (e: KeyboardEvent) => {\n            // Vérifier si les raccourcis sont activés\n            const store = useKarmycStore.getState();\n            if (!store.options.keyboardShortcutsEnabled) {\n                return;\n            }\n\n            // Ignore modifier-only events\n            if (e.key === 'Control' || e.key === 'Alt' || e.key === 'Shift' || e.key === 'Meta') {\n                return;\n            }\n\n            // Get active modifiers directly from the event\n            const activeModifiers = new Set<ModifierKey>();\n            if (e.ctrlKey) activeModifiers.add('Control');\n            if (e.altKey) activeModifiers.add('Alt');\n            if (e.shiftKey) activeModifiers.add('Shift');\n            if (e.metaKey) activeModifiers.add('Command');\n\n            // Get the active area\n            const activeAreaId = store.screens[store.activeScreenId]?.areas.activeAreaId;\n            const activeAreaType = activeAreaId ? store.getAreaById(activeAreaId)?.type : null;\n\n            // Check global shortcuts first\n            const globalShortcuts = keyboardShortcutRegistry.getAllShortcuts().filter(s => s.isGlobal);\n\n            for (const shortcut of globalShortcuts) {\n                if (shortcut.key.toUpperCase() === e.key.toUpperCase()) {\n                    const requiredModifiers = new Set(shortcut.modifierKeys || []);\n                    let allModifiersMatch = true;\n\n                    // Check required modifiers\n                    for (const modKey of requiredModifiers) {\n                        if (!activeModifiers.has(modKey as ModifierKey)) {\n                            allModifiersMatch = false;\n                            break;\n                        }\n                    }\n\n                    // Check optional modifiers\n                    if (allModifiersMatch) {\n                        const optionalModifiers = new Set(shortcut.optionalModifierKeys || []);\n                        for (const activeMod of activeModifiers) {\n                            if (!requiredModifiers.has(activeMod) && !optionalModifiers.has(activeMod)) {\n                                allModifiersMatch = false;\n                                break;\n                            }\n                        }\n                    }\n\n                    // If it's a valid shortcut, prevent default behavior and execute\n                    if (allModifiersMatch) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                        try {\n                            shortcut.fn(activeAreaId || '', {});\n                        } catch (error) {\n                            console.error(`Error executing global shortcut ${shortcut.name}:`, error);\n                        }\n                        return;\n                    }\n                }\n            }\n\n            // If no area is active, stop here\n            if (!activeAreaId || !activeAreaType) {\n                return;\n            }\n\n            // Check area-specific shortcuts\n            const shortcuts = keyboardShortcutRegistry.getShortcuts(activeAreaType);\n            \n            for (const shortcut of shortcuts) {\n                // Ignore global shortcuts already checked\n                if (shortcut.isGlobal) continue;\n\n                if (shortcut.key.toUpperCase() === e.key.toUpperCase()) {\n                    const requiredModifiers = new Set(shortcut.modifierKeys || []);\n                    let allModifiersMatch = true;\n\n                    // Check required modifiers\n                    for (const modKey of requiredModifiers) {\n                        if (!activeModifiers.has(modKey as ModifierKey)) {\n                            allModifiersMatch = false;\n                            break;\n                        }\n                    }\n\n                    // Check optional modifiers\n                    if (allModifiersMatch) {\n                        const optionalModifiers = new Set(shortcut.optionalModifierKeys || []);\n                        for (const activeMod of activeModifiers) {\n                            if (!requiredModifiers.has(activeMod) && !optionalModifiers.has(activeMod)) {\n                                allModifiersMatch = false;\n                                break;\n                            }\n                        }\n                    }\n\n                    // If it's a valid shortcut, prevent default behavior and execute\n                    if (allModifiersMatch) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                        try {\n                            shortcut.fn(activeAreaId, {});\n                        } catch (error) {\n                            console.error(`Error executing shortcut ${shortcut.name}:`, error);\n                        }\n                        return;\n                    }\n                }\n            }\n\n            // Check system shortcuts\n            if (checkShouldPreventDefault(e.key, activeModifiers)) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        };\n\n        // Use capture to intercept the event before it propagates\n        window.addEventListener('keydown', handleKeyDown, true);\n        return () => window.removeEventListener('keydown', handleKeyDown, true);\n    }, []);\n\n    return (\n        <KarmycContext.Provider value={{ options }}>\n            <KarmycInitializer options={options} onError={handleInitializationError}>\n                {children}\n            </KarmycInitializer>\n        </KarmycContext.Provider>\n    );\n}; \n","import { keyboardShortcutRegistry, KeyboardShortcut } from \"../store/registries/keyboardShortcutRegistry\";\nimport { useKarmycStore } from \"../store/areaStore\";\n\n/**\n * List of supported modifier keys\n */\nexport const modifierKeys = [\"Command\", \"Alt\", \"Shift\", \"Control\"] as const;\nexport type ModifierKey = typeof modifierKeys[number];\n\n/**\n * Mapping between key codes and key names\n * This list is partial and should be extended as needed\n */\nconst keyCodeMap: Record<number, string> = {\n    // Letters\n    65: \"A\", 66: \"B\", 67: \"C\", 68: \"D\", 69: \"E\", 70: \"F\", 71: \"G\", 72: \"H\",\n    73: \"I\", 74: \"J\", 75: \"K\", 76: \"L\", 77: \"M\", 78: \"N\", 79: \"O\", 80: \"P\",\n    81: \"Q\", 82: \"R\", 83: \"S\", 84: \"T\", 85: \"U\", 86: \"V\", 87: \"W\", 88: \"X\",\n    89: \"Y\", 90: \"Z\",\n\n    // Numbers\n    48: \"0\", 49: \"1\", 50: \"2\", 51: \"3\", 52: \"4\", 53: \"5\", 54: \"6\", 55: \"7\",\n    56: \"8\", 57: \"9\",\n\n    // Function keys\n    112: \"F1\", 113: \"F2\", 114: \"F3\", 115: \"F4\", 116: \"F5\", 117: \"F6\",\n    118: \"F7\", 119: \"F8\", 120: \"F9\", 121: \"F10\", 122: \"F11\", 123: \"F12\",\n\n    // Navigation\n    37: \"ArrowLeft\", 38: \"ArrowUp\", 39: \"ArrowRight\", 40: \"ArrowDown\",\n    33: \"PageUp\", 34: \"PageDown\", 36: \"Home\", 35: \"End\",\n\n    // Editing\n    8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 27: \"Escape\", 32: \"Space\",\n    46: \"Delete\", 45: \"Insert\",\n\n    // Modifier keys\n    16: \"Shift\", 17: \"Control\", 18: \"Alt\", 91: \"Command\", 93: \"Command\"\n};\n\n// Key state (to replace navigator.keyboard which is not available everywhere)\nconst keyState = new Map<string, boolean>();\n\n/**\n * Converts a key code to a key name\n */\nexport function getKeyFromKeyCode(keyCode: number): string | null {\n    return keyCodeMap[keyCode] || null;\n}\n\n/**\n * Updates the state of a key\n * This function should be called by global event handlers\n */\nexport function updateKeyState(key: string, isDown: boolean): void {\n    keyState.set(key, isDown);\n}\n\n/**\n * Checks if a key is currently pressed\n */\nexport function isKeyDown(key: string): boolean {\n    return keyState.get(key) || false;\n}\n\n/**\n * Checks if we should prevent the browser's default behavior\n * for the given key combination\n */\nexport function checkShouldPreventDefault(key: string, activeModifiers: Set<ModifierKey>): boolean {\n    // Get all registered shortcuts\n    const allShortcuts = keyboardShortcutRegistry.getAllShortcuts();\n    \n    // Check if the combination matches a registered shortcut\n    for (const shortcut of allShortcuts) {\n        if (shortcut.key === key) {\n            // Check modifiers\n            const requiredModifiers = new Set(shortcut.modifierKeys || []);\n            let allModifiersMatch = true;\n\n            // Check that all required modifiers are active\n            for (const modKey of requiredModifiers) {\n                if (!activeModifiers.has(modKey as ModifierKey)) {\n                    allModifiersMatch = false;\n                    break;\n                }\n            }\n\n            // Check that there are no additional unauthorized modifiers\n            if (allModifiersMatch) {\n                const optionalModifiers = new Set(shortcut.optionalModifierKeys || []);\n                for (const activeMod of activeModifiers) {\n                    if (!requiredModifiers.has(activeMod) && !optionalModifiers.has(activeMod)) {\n                        allModifiersMatch = false;\n                        break;\n                    }\n                }\n            }\n\n            // If all modifiers match, prevent default behavior\n            if (allModifiersMatch) {\n                return true;\n            }\n        }\n    }\n\n    // List of system shortcuts to always intercept\n    const systemShortcuts = [\n        { key: 'R', modifiers: ['Control'] },  // Ctrl+R (Refresh)\n        { key: 'S', modifiers: ['Control'] },  // Ctrl+S (Save)\n        { key: 'P', modifiers: ['Control'] },  // Ctrl+P (Print)\n        { key: 'F', modifiers: ['Control'] },  // Ctrl+F (Find)\n        { key: 'L', modifiers: ['Control'] },  // Ctrl+L (Focus URL)\n        { key: 'U', modifiers: ['Control'] },  // Ctrl+U (View Source)\n        { key: 'I', modifiers: ['Control'] },  // Ctrl+I (DevTools)\n        { key: 'J', modifiers: ['Control'] },  // Ctrl+J (Downloads)\n        { key: 'K', modifiers: ['Control'] },  // Ctrl+K (Search)\n        { key: 'N', modifiers: ['Control'] },  // Ctrl+N (New Window)\n        { key: 'T', modifiers: ['Control'] },  // Ctrl+T (New Tab)\n        { key: 'W', modifiers: ['Control'] },  // Ctrl+W (Close Tab)\n    ];\n\n    // Check system shortcuts\n    for (const shortcut of systemShortcuts) {\n        if (key === shortcut.key) {\n            const requiredModifiers = new Set(shortcut.modifiers);\n            let allModifiersMatch = true;\n\n            // Check that all required modifiers are active\n            for (const modKey of requiredModifiers) {\n                if (!activeModifiers.has(modKey as ModifierKey)) {\n                    allModifiersMatch = false;\n                    break;\n                }\n            }\n\n            // Check that there are no additional modifiers\n            if (allModifiersMatch && activeModifiers.size === requiredModifiers.size) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks and executes keyboard shortcuts matching the pressed key\n */\nexport function checkAndExecuteShortcuts(key: string): void {\n    // Get active modifiers\n    const activeModifiers = new Set<ModifierKey>();\n    for (const modKey of modifierKeys) {\n        if (isKeyDown(modKey)) {\n            activeModifiers.add(modKey);\n        }\n    }\n\n    // Get the active area ID using useKarmycStore\n    const store = useKarmycStore.getState();\n    const activeAreaId = store.screens[store.activeScreenId]?.areas.activeAreaId;\n    const activeAreaType = activeAreaId ? store.getAreaById(activeAreaId)?.type : null;\n\n    if (!activeAreaId || !activeAreaType) {\n        return;\n    }\n\n    // Get shortcuts for this area type\n    const shortcuts = keyboardShortcutRegistry.getShortcuts(activeAreaType);\n\n    if (!shortcuts || shortcuts.length === 0) {\n        return;\n    }\n\n    // Find the best matching shortcut\n    const bestShortcut = findBestShortcut(shortcuts, key, activeModifiers);\n\n    if (bestShortcut) {\n        // Execute the shortcut function with the active area ID\n        try {\n            bestShortcut.fn(activeAreaId, {});\n        } catch (error) {\n            console.error(`Error executing shortcut ${bestShortcut.name}:`, error);\n        }\n    }\n}\n\n/**\n * Finds the best keyboard shortcut matching the key and active modifiers\n * \"Best\" means the one with the highest number of modifiers\n */\nexport function findBestShortcut(\n    shortcuts: KeyboardShortcut[],\n    key: string,\n    activeModifiers: Set<ModifierKey>\n): KeyboardShortcut | null {\n    let bestShortcut: KeyboardShortcut | null = null;\n    let nModifierKeys = -1;\n\n    for (const shortcut of shortcuts) {\n        if (shortcut.key !== key) {\n            continue;\n        }\n\n        // Check that all required modifiers are active\n        if (shortcut.modifierKeys) {\n            const requiredModifiers = new Set(shortcut.modifierKeys);\n            let allModifiersDown = true;\n\n            for (const modKey of requiredModifiers) {\n                if (!activeModifiers.has(modKey as ModifierKey)) {\n                    allModifiersDown = false;\n                    break;\n                }\n            }\n\n            if (!allModifiersDown) continue;\n        }\n\n        // Check that there are no additional active modifiers\n        // unless they are in optionalModifierKeys\n        const optionalModifiers = new Set<string>([]); // If optionalModifierKeys doesn't exist, use an empty set\n\n        let hasExtraModifiers = false;\n\n        for (const activeModKey of activeModifiers) {\n            if (\n                !(shortcut.modifierKeys || []).includes(activeModKey) &&\n                !optionalModifiers.has(activeModKey)\n            ) {\n                hasExtraModifiers = true;\n                break;\n            }\n        }\n\n        if (hasExtraModifiers) continue;\n\n        // Valid shortcut, check if it's better (more modifiers)\n        const currNModifierKeys = (shortcut.modifierKeys || []).length;\n        if (currNModifierKeys > nModifierKeys) {\n            bestShortcut = shortcut;\n            nModifierKeys = currNModifierKeys;\n        }\n    }\n\n    return bestShortcut;\n} \n","import React, { useCallback, useEffect, useState, useMemo, useRef, useContext } from \"react\";\nimport { useKarmycStore } from \"../store/areaStore\";\nimport { AreaRowLayout } from \"../types/areaTypes\";\nimport { computeAreaToViewport } from \"../utils/areaToViewport\";\nimport { getAreaRootViewport } from \"../utils/getAreaViewport\";\nimport { Area } from \"./Area\";\nimport { AreaRowSeparators } from \"./AreaRowSeparators\";\nimport { AreaToOpenPreview } from \"./AreaToOpenPreview\";\nimport { JoinAreaPreview } from \"./JoinAreaPreview\";\nimport { ContextMenuProvider } from \"../providers/ContextMenuProvider\";\nimport { DetachedWindowCleanup } from \"./DetachedWindowCleanup\";\nimport { areViewportMapsEqual } from \"../utils/objectEquality\";\nimport { KarmycContext } from \"../providers/KarmycProvider\";\n\ninterface Rect {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n}\n\n// Définir le type ResizePreviewState ici ou l'importer\ninterface ResizePreviewState {\n    rowId: string;\n    separatorIndex: number;\n    t: number;\n}\n\n// Helper function to select active screen area state\nconst selectActiveScreenAreas = (state: ReturnType<typeof useKarmycStore.getState>) => {\n    return state.screens[state.activeScreenId]?.areas;\n};\n\nexport const Karmyc: React.FC<{ offset?: number }> = ({ offset = 0 }) => {\n    const context = useContext(KarmycContext);\n    \n    if (!context) {\n        throw new Error('Karmyc must be used within a KarmycProvider');\n    }\n\n    // Selectors for active screen state\n    const activeScreenAreas = useKarmycStore(selectActiveScreenAreas);\n    const isDetached = useKarmycStore(state => state.screens[state.activeScreenId]?.isDetached);\n\n    // Memoize the derived state to avoid unnecessary re-renders\n    const rootId = useMemo(() => activeScreenAreas?.rootId, [activeScreenAreas?.rootId]);\n    const layout = useMemo(() => activeScreenAreas?.layout ?? {}, [activeScreenAreas?.layout]);\n    const joinPreview = useMemo(() => activeScreenAreas?.joinPreview, [activeScreenAreas?.joinPreview]);\n    const areaToOpen = useMemo(() => activeScreenAreas?.areaToOpen, [activeScreenAreas?.areaToOpen]);\n\n    // Utiliser useRef pour stocker le dernier viewport calculé\n    const lastViewportRef = useRef<Rect | null>(null);\n    const [viewport, setViewport] = useState(() => {\n        if (isDetached) {\n            return {\n                left: 0,\n                top: 0,\n                width: window.innerWidth,\n                height: window.innerHeight\n            };\n        }\n        return getAreaRootViewport();\n    });\n    const [resizePreview, setResizePreview] = useState<ResizePreviewState | null>(null);\n\n    const setViewports = useKarmycStore(state => state.setViewports);\n\n    // Effect pour initialiser le viewport après le montage\n    useEffect(() => {\n        if (!isDetached) {\n            const areaRoot = document.querySelector('.area-root');\n            if (areaRoot) {\n                const rect = areaRoot.getBoundingClientRect();\n                setViewport({\n                    left: 0,\n                    top: 0,\n                    width: rect.width,\n                    height: rect.height\n                });\n            }\n        }\n    }, [isDetached]);\n\n    // Ne mettre à jour le viewport que si nécessaire\n    useEffect(() => {\n        const handleResize = () => {\n            if (isDetached) {\n                const newViewport = {\n                    left: 0,\n                    top: 0,\n                    width: window.innerWidth,\n                    height: window.innerHeight\n                };\n                if (!lastViewportRef.current || \n                    newViewport.width !== lastViewportRef.current.width || \n                    newViewport.height !== lastViewportRef.current.height) {\n                    setViewport(newViewport);\n                }\n            } else {\n                const areaRoot = document.querySelector('.area-root');\n                if (areaRoot) {\n                    const rect = areaRoot.getBoundingClientRect();\n                    const newViewport = {\n                        left: 0,\n                        top: 0,\n                        width: rect.width,\n                        height: rect.height\n                    };\n                    if (!lastViewportRef.current || \n                        newViewport.width !== lastViewportRef.current.width || \n                        newViewport.height !== lastViewportRef.current.height) {\n                        setViewport(newViewport);\n                    }\n                }\n            }\n        };\n\n        window.addEventListener('resize', handleResize);\n        return () => window.removeEventListener('resize', handleResize);\n    }, [isDetached]);\n\n    // Effect for viewport calculation and direct store update\n    useEffect(() => {\n        const layoutSize = Object.keys(layout).length;\n        const currentRootItem = rootId ? layout[rootId] : null;\n\n        if (!rootId || !currentRootItem || layoutSize === 0) {\n            if (lastViewportRef.current !== null) {\n                lastViewportRef.current = null;\n                setViewports({});\n            }\n            return;\n        }\n\n        // Vérifier que le viewport a des dimensions valides\n        if (!viewport || viewport.width <= 0 || viewport.height <= 0) {\n            return;\n        }\n\n        try {\n            const newViewportMap = computeAreaToViewport(layout, rootId, {...viewport, top: viewport.top + offset});\n            const currentStoreViewports = useKarmycStore.getState().screens[useKarmycStore.getState().activeScreenId]?.areas.viewports;\n\n            // Ne mettre à jour que si les viewports ont réellement changé\n            if (!areViewportMapsEqual(currentStoreViewports, newViewportMap)) {\n                // Vérifier si le changement est significatif\n                const hasSignificantChange = Object.keys(newViewportMap).some(key => {\n                    const oldViewport = currentStoreViewports?.[key];\n                    const newViewport = newViewportMap[key];\n                    if (!oldViewport) return true;\n                    \n                    return Math.abs(oldViewport.left - newViewport.left) > 1 ||\n                           Math.abs(oldViewport.top - newViewport.top) > 1 ||\n                           Math.abs(oldViewport.width - newViewport.width) > 1 ||\n                           Math.abs(oldViewport.height - newViewport.height) > 1;\n                });\n\n                if (hasSignificantChange) {\n                    lastViewportRef.current = viewport;\n                    setViewports(newViewportMap);\n                }\n            }\n        } catch (error) {\n            console.error(\"[Karmyc] Erreur lors du calcul du viewportMap:\", error);\n        }\n    }, [layout, rootId, viewport, resizePreview, setViewports]);\n\n    const getAreaVisualViewport = useCallback((areaId: string): Rect | undefined => {\n        const state = useKarmycStore.getState();\n        const activeScreen = state.screens[state.activeScreenId];\n        const currentGlobalViewportMap = activeScreen?.areas.viewports || {};\n\n        const baseViewport = currentGlobalViewportMap[areaId];\n\n        // Si l'écran est détaché, retourner le viewport de base avec les dimensions de la fenêtre\n        if (activeScreen?.isDetached) {\n            return {\n                ...baseViewport,\n                left: 0,\n                top: 0,\n                width: window.innerWidth,\n                height: window.innerHeight\n            };\n        }\n\n        // Si pas de resizePreview, retourner le viewport de base\n        if (!resizePreview) {\n            return baseViewport;\n        }\n\n        let parentRow: AreaRowLayout | undefined;\n        let areaIndexInRow: number = -1;\n        parentRow = Object.values(layout)\n            .filter((item): item is AreaRowLayout => item.type === 'area_row')\n            .find(row => {\n                const index = row.areas.findIndex(a => a.id === areaId);\n                if (index !== -1) { areaIndexInRow = index; return true; }\n                return false;\n            });\n\n        if (!parentRow || parentRow.id !== resizePreview.rowId) {\n            return baseViewport;\n        }\n\n        const sepIndex = resizePreview.separatorIndex;\n\n        if (areaIndexInRow === sepIndex - 1 || areaIndexInRow === sepIndex) {\n            const siblingIndex = areaIndexInRow === sepIndex - 1 ? sepIndex : sepIndex - 1;\n            const siblingId = parentRow.areas[siblingIndex]?.id;\n            if (!siblingId) return baseViewport;\n            const siblingViewport = currentGlobalViewportMap[siblingId];\n            if (!siblingViewport) return baseViewport;\n            const isFirst = areaIndexInRow === sepIndex - 1;\n            const t = resizePreview.t;\n            const parentRowViewport = currentGlobalViewportMap[parentRow.id];\n            if (!parentRowViewport) return baseViewport;\n\n            const vp0 = isFirst ? baseViewport : siblingViewport;\n            const vp1 = isFirst ? siblingViewport : baseViewport;\n\n            const sharedRect: Rect = {\n                left: vp0.left,\n                top: vp0.top,\n                width: vp0.width + vp1.width,\n                height: vp0.height + vp1.height\n            };\n\n            if (parentRow.orientation === 'horizontal') {\n                const totalPixelWidth = sharedRect.width;\n                const newPixelWidth0 = Math.max(0, Math.floor(totalPixelWidth * t));\n                const newPixelWidth1 = Math.max(0, totalPixelWidth - newPixelWidth0);\n\n                const newWidth = isFirst ? newPixelWidth0 : newPixelWidth1;\n                const newLeft = isFirst ? sharedRect.left : sharedRect.left + newPixelWidth0;\n\n                if (isNaN(newWidth) || isNaN(newLeft)) {\n                    console.warn(`[VisViewport] ${areaId}: NaN detected in horizontal calc.`);\n                    return baseViewport;\n                }\n                return { ...baseViewport, width: newWidth, left: newLeft };\n\n            } else if (parentRow.orientation === 'vertical') {\n                const totalPixelHeight = sharedRect.height;\n                const newPixelHeight0 = Math.max(0, Math.floor(totalPixelHeight * t));\n                const newPixelHeight1 = Math.max(0, totalPixelHeight - newPixelHeight0);\n\n                const newHeight = isFirst ? newPixelHeight0 : newPixelHeight1;\n                const newTop = isFirst ? sharedRect.top : sharedRect.top + newPixelHeight0;\n\n                if (isNaN(newHeight) || isNaN(newTop)) {\n                    console.warn(`[VisViewport] ${areaId}: NaN detected in vertical calc.`);\n                    return baseViewport;\n                }\n                return { ...baseViewport, height: newHeight, top: newTop };\n            } else if (parentRow.orientation === 'stack') {\n                // Pour un stack, chaque tab occupe tout l'espace (hors barre d'onglets)\n                return baseViewport;\n            }\n        }\n        return baseViewport;\n    }, [layout, resizePreview]);\n\n    return (\n        <ContextMenuProvider>\n            <DetachedWindowCleanup />\n            <div className=\"area-root\">\n                {Object.values(layout).map((item) => {\n                    if (item.type === 'area_row') {\n                        const rowLayout = item as AreaRowLayout;\n                        const currentGlobalViewportMap = useKarmycStore.getState().screens[useKarmycStore.getState().activeScreenId]?.areas.viewports || {};\n                        const areChildrenReady = rowLayout.areas.every(area => currentGlobalViewportMap[area.id]);\n                        if (areChildrenReady) {\n                            return (\n                                <AreaRowSeparators\n                                    offset={offset}\n                                    key={item.id}\n                                    row={rowLayout}\n                                    setResizePreview={setResizePreview}\n                                />\n                            );\n                        }\n                    }\n                    return null;\n                })}\n\n                {Object.entries(layout).map(([id]) => {\n                    const visualViewport = getAreaVisualViewport(id);\n                    if (visualViewport) {\n                        return (\n                            <Area\n                                key={id}\n                                id={id}\n                                viewport={{...visualViewport, top: visualViewport.top - offset}}\n                                setResizePreview={setResizePreview}\n                            />\n                        );\n                    }\n                    return null;\n                })}\n\n                {joinPreview && joinPreview.areaId &&\n                    (() => {\n                        const currentGlobalViewportMap = useKarmycStore.getState().screens[useKarmycStore.getState().activeScreenId]?.areas.viewports || {};\n                        const joinViewport = currentGlobalViewportMap[joinPreview.areaId!];\n                        return joinViewport ? (\n                            <JoinAreaPreview\n                                viewport={joinViewport}\n                                movingInDirection={joinPreview.movingInDirection!}\n                            />\n                        ) : null;\n                    })()\n                }\n                {areaToOpen && (\n                    <AreaToOpenPreview />\n                )}\n            </div>\n        </ContextMenuProvider>\n    );\n};\n","import { Rect } from '../types/math';\r\n\r\n/**\r\n * Represents a map of area IDs to their viewport rectangles.\r\n * Can be undefined or null if no viewports are present.\r\n */\r\nexport type ViewportMap = { [key: string]: Rect } | undefined | null;\r\n\r\n/**\r\n * Deeply compares two viewport maps.\r\n * @param map1 The first viewport map.\r\n * @param map2 The second viewport map.\r\n * @returns True if the maps are deeply equal, false otherwise.\r\n */\r\nexport function areViewportMapsEqual(map1: ViewportMap, map2: ViewportMap): boolean {\r\n    // Handles cases where both are null, undefined, or the same instance\r\n    if (map1 === map2) {\r\n        return true;\r\n    }\r\n\r\n    // If one is null/undefined and the other isn't, they are not equal\r\n    if (!map1 || !map2) {\r\n        return false;\r\n    }\r\n\r\n    const keys1 = Object.keys(map1);\r\n    const keys2 = Object.keys(map2);\r\n\r\n    // Different number of areas means they are not equal\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n\r\n    // Check each area's viewport\r\n    for (const key of keys1) {\r\n        // If map2 doesn't have a key that map1 has\r\n        if (!map2.hasOwnProperty(key)) {\r\n            return false;\r\n        }\r\n        const rect1 = map1[key];\r\n        const rect2 = map2[key];\r\n\r\n        // If any Rect property differs, the maps are not equal\r\n        if (rect1.left !== rect2.left ||\r\n            rect1.top !== rect2.top ||\r\n            rect1.width !== rect2.width ||\r\n            rect1.height !== rect2.height) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // All checks passed, the maps are deeply equal\r\n    return true;\r\n} \r\n","function shallow$1(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false;\n    for (const [key, value] of objA) {\n      if (!Object.is(value, objB.get(key))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false;\n    for (const value of objA) {\n      if (!objB.has(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (const keyA of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar shallow = (objA, objB) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { shallow } from 'zustand/shallow'`.\"\n    );\n  }\n  return shallow$1(objA, objB);\n};\n\nexport { shallow as default, shallow$1 as shallow };\n","import ReactExports from 'react';\nimport useSyncExternalStoreExports from 'use-sync-external-store/shim/with-selector.js';\nimport { createStore } from 'zustand/vanilla';\n\nconst { useDebugValue } = ReactExports;\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;\nconst identity = (arg) => arg;\nfunction useStoreWithEqualityFn(api, selector = identity, equalityFn) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createWithEqualityFnImpl = (createState, defaultEqualityFn) => {\n  const api = createStore(createState);\n  const useBoundStoreWithEqualityFn = (selector, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector, equalityFn);\n  Object.assign(useBoundStoreWithEqualityFn, api);\n  return useBoundStoreWithEqualityFn;\n};\nconst createWithEqualityFn = (createState, defaultEqualityFn) => createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;\n\nexport { createWithEqualityFn, useStoreWithEqualityFn };\n","import { useCallback, useMemo } from 'react';\nimport { shallow } from 'zustand/shallow';\nimport { useStoreWithEqualityFn } from 'zustand/traditional';\n\nimport { Space, useSpaceStore } from '../store/spaceStore';\n\n/**\n * Hook for managing spaces using Zustand\n * Provides functions to manipulate spaces and access their state\n */\nexport function useSpace() {\n    // Select state slices reactively using useStoreWithEqualityFn\n    const spaces = useStoreWithEqualityFn(\n        useSpaceStore,\n        state => state.spaces,\n        shallow\n    ) as Record<string, Space>;\n\n    const activeSpaceId = useStoreWithEqualityFn(\n        useSpaceStore,\n        state => state.activeSpaceId,\n        shallow\n    );\n\n    const openSpaceIds = useStoreWithEqualityFn(\n        useSpaceStore,\n        state => state.openSpaceIds,\n        shallow\n    );\n\n    const pilotMode = useStoreWithEqualityFn(\n        useSpaceStore,\n        state => state.pilotMode,\n        shallow\n    );\n\n    // Select actions individually (references should be stable)\n    const addSpaceAction = useSpaceStore(state => state.addSpace);\n    const removeSpaceAction = useSpaceStore(state => state.removeSpace);\n    const setActiveSpaceAction = useSpaceStore(state => state.setActiveSpace);\n    const openSpaceAction = useSpaceStore(state => state.openSpace);\n    const closeSpaceAction = useSpaceStore(state => state.closeSpace);\n    const updateSpaceAction = useSpaceStore(state => state.updateSpace);\n    const updateSpaceGenericSharedStateAction = useSpaceStore(state => state.updateSpaceGenericSharedState);\n\n    // Memoize the derived space list\n    const spaceList = useMemo(() => {\n        return Object.entries(spaces).map(([id, space]) => ({ id, name: space.name }));\n    }, [spaces]);\n\n    // Memoize the list of open spaces\n    const openSpaces = useMemo(() => {\n        return openSpaceIds\n            .map(id => spaces[id])\n            .filter((space): space is Space => space !== undefined);\n    }, [spaces, openSpaceIds]);\n\n    // Define actions using useCallback with stable action references\n    const createSpace = useCallback((name: string, initialSharedState = {}) => {\n        return addSpaceAction({ name, sharedState: initialSharedState });\n    }, [addSpaceAction]);\n\n    const deleteSpace = useCallback((id: string) => {\n        removeSpaceAction(id);\n    }, [removeSpaceAction]);\n\n    const setActive = useCallback((id: string | null) => {\n        setActiveSpaceAction(id);\n    }, [setActiveSpaceAction]);\n\n    const openSpace = useCallback((id: string) => {\n        openSpaceAction(id);\n    }, [openSpaceAction]);\n\n    const closeSpace = useCallback((id: string) => {\n        closeSpaceAction(id);\n    }, [closeSpaceAction]);\n\n    const updateSharedState = useCallback((spaceId: string, changes: Partial<Record<string, any>>) => {\n        updateSpaceGenericSharedStateAction({ spaceId, changes });\n    }, [updateSpaceGenericSharedStateAction]);\n\n    const updateSpaceProperties = useCallback((id: string, changes: Partial<Omit<Space, 'id'>>) => {\n        updateSpaceAction({ id, ...changes });\n    }, [updateSpaceAction]);\n\n    const getSpaceById = useCallback((id: string) => {\n        return useSpaceStore.getState().spaces[id];\n    }, []);\n\n    const setPilotMode = useCallback((mode: 'MANUAL' | 'AUTO') => {\n        useSpaceStore.getState().setPilotMode(mode);\n    }, []);\n\n    return {\n        // State\n        spaceList,\n        activeSpaceId,\n        openSpaces,\n        openSpaceIds,\n        pilotMode,\n\n        // Actions\n        createSpace,\n        deleteSpace,\n        setActive,\n        setPilotMode,\n        openSpace,\n        closeSpace,\n        updateSharedState,\n        updateSpaceProperties,\n        getSpaceById\n    };\n} \n","import React, { useCallback, useState, useEffect } from 'react';\r\nimport { useContextMenu } from '../../hooks/useContextMenu';\r\nimport { useSpace } from '../../hooks/useSpace';\r\nimport { Plus, FileUp, FileDown, History, X, FolderOpen, Edit } from 'lucide-react';\r\nimport { ContextMenuItem } from '../../types';\r\nimport { actionRegistry } from '../../actions/handlers/actionRegistry';\r\n\r\nexport const SpaceMenu: React.FC = () => {\r\n    const { open } = useContextMenu();\r\n    const [isHovered, setIsHovered] = useState(false);\r\n    const { \r\n        spaceList, \r\n        activeSpaceId,\r\n        openSpaces,\r\n        createSpace, \r\n        setActive,\r\n        openSpace,\r\n        closeSpace,\r\n        updateSpaceProperties \r\n    } = useSpace();\r\n\r\n    const handleExportSpace = useCallback(() => {\r\n        const space = spaceList.find(s => s.id === activeSpaceId);\r\n        if (!space) return;\r\n\r\n        const dataStr = JSON.stringify(space, null, 2);\r\n        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);\r\n        \r\n        const exportFileDefaultName = `${space.name}.json`;\r\n        \r\n        const linkElement = document.createElement('a');\r\n        linkElement.setAttribute('href', dataUri);\r\n        linkElement.setAttribute('download', exportFileDefaultName);\r\n        linkElement.click();\r\n    }, [spaceList, activeSpaceId]);\r\n\r\n    const handleImportSpace = useCallback(() => {\r\n        const input = document.createElement('input');\r\n        input.type = 'file';\r\n        input.accept = '.json';\r\n        \r\n        input.onchange = (e) => {\r\n            const file = (e.target as HTMLInputElement).files?.[0];\r\n            if (!file) return;\r\n\r\n            const reader = new FileReader();\r\n            reader.onload = (event) => {\r\n                try {\r\n                    const spaceData = JSON.parse(event.target?.result as string);\r\n                    const newSpaceId = createSpace(spaceData.name, spaceData.sharedState);\r\n                    if (newSpaceId) {\r\n                        setActive(newSpaceId);\r\n                    }\r\n                } catch (error) {\r\n                    console.error('Error importing space:', error);\r\n                }\r\n            };\r\n            reader.readAsText(file);\r\n        };\r\n        \r\n        input.click();\r\n    }, [createSpace, setActive]);\r\n\r\n    const handleRenameSpace = useCallback(() => {\r\n        const space = spaceList.find(s => s.id === activeSpaceId);\r\n        if (!space || !activeSpaceId) return;\r\n\r\n        const newName = prompt('Nouveau nom du space:', space.name);\r\n        if (newName && newName !== space.name) {\r\n            updateSpaceProperties(activeSpaceId, { name: newName });\r\n        }\r\n    }, [spaceList, activeSpaceId, updateSpaceProperties]);\r\n\r\n    // Enregistrer les actions\r\n    useEffect(() => {\r\n        actionRegistry.registerActionHandler('space.new', () => {\r\n            const newSpaceId = createSpace('Nouveau Space');\r\n            if (newSpaceId) {\r\n                setActive(newSpaceId);\r\n            }\r\n        });\r\n\r\n        actionRegistry.registerActionHandler('space.import', handleImportSpace);\r\n        actionRegistry.registerActionHandler('space.export', handleExportSpace);\r\n        actionRegistry.registerActionHandler('space.rename', handleRenameSpace);\r\n        actionRegistry.registerActionHandler('space.close', (params: { spaceId: string }) => {\r\n            const spaceId = params.spaceId || activeSpaceId;\r\n            if (spaceId) {\r\n                closeSpace(spaceId);\r\n            }\r\n        });\r\n        actionRegistry.registerActionHandler('space.open', (params: { spaceId: string }) => {\r\n            if (params.spaceId) {\r\n                openSpace(params.spaceId);\r\n                setActive(params.spaceId);\r\n            }\r\n        });\r\n\r\n        return () => {\r\n            actionRegistry.unregisterActionHandler('space.new');\r\n            actionRegistry.unregisterActionHandler('space.import');\r\n            actionRegistry.unregisterActionHandler('space.export');\r\n            actionRegistry.unregisterActionHandler('space.rename');\r\n            actionRegistry.unregisterActionHandler('space.close');\r\n            actionRegistry.unregisterActionHandler('space.open');\r\n        };\r\n    }, [createSpace, handleImportSpace, handleExportSpace, handleRenameSpace, closeSpace, openSpace, setActive, activeSpaceId]);\r\n\r\n    const handleContextMenu = useCallback((e: React.MouseEvent) => {\r\n        e.preventDefault();\r\n        \r\n        const recentSpaces = spaceList.slice(-10).reverse();\r\n        const hasActiveSpace = !!activeSpaceId;\r\n        \r\n        const menuItems: ContextMenuItem[] = [\r\n            {\r\n                id: 'new',\r\n                label: 'Nouveau Space',\r\n                actionId: 'space.new',\r\n                icon: Plus\r\n            },\r\n            {\r\n                id: 'import',\r\n                label: 'Importer Space',\r\n                actionId: 'space.import',\r\n                icon: FileUp\r\n            },\r\n            {\r\n                id: 'export',\r\n                label: 'Exporter Space',\r\n                actionId: 'space.export',\r\n                icon: FileDown,\r\n                disabled: !hasActiveSpace\r\n            },\r\n            {\r\n                id: 'rename',\r\n                label: 'Renommer Space',\r\n                actionId: 'space.rename',\r\n                icon: Edit,\r\n                disabled: !hasActiveSpace\r\n            },\r\n            {\r\n                id: 'close',\r\n                label: 'Fermer Space Actif',\r\n                actionId: 'space.close',\r\n                icon: X,\r\n                disabled: !hasActiveSpace\r\n            }\r\n        ];\r\n\r\n        // Ajouter la liste des espaces ouverts\r\n        if (openSpaces.length > 0) {\r\n            menuItems.push(\r\n                {\r\n                    id: 'separator1',\r\n                    label: '---',\r\n                    actionId: 'area.separator'\r\n                },\r\n                {\r\n                    id: 'open',\r\n                    label: 'Espaces Ouverts',\r\n                    actionId: 'space.open',\r\n                    icon: FolderOpen,\r\n                    children: openSpaces.map(space => ({\r\n                        id: `open-${space.id}`,\r\n                        label: space.name,\r\n                        actionId: 'space.open',\r\n                        metadata: { spaceId: space.id }\r\n                    }))\r\n                }\r\n            );\r\n        }\r\n\r\n        // Ajouter la liste des espaces récents\r\n        if (recentSpaces.length > 0) {\r\n            menuItems.push(\r\n                {\r\n                    id: 'separator2',\r\n                    label: '---',\r\n                    actionId: 'area.separator'\r\n                },\r\n                {\r\n                    id: 'recent',\r\n                    label: 'Spaces Récents',\r\n                    actionId: 'space.recent',\r\n                    icon: History,\r\n                    children: recentSpaces.map(space => ({\r\n                        id: `recent-${space.id}`,\r\n                        label: space.name,\r\n                        actionId: 'space.open',\r\n                        metadata: { spaceId: space.id }\r\n                    }))\r\n                }\r\n            );\r\n        }\r\n        \r\n        open({\r\n            position: { x: e.clientX, y: e.clientY },\r\n            items: menuItems,\r\n            menuClassName: 'space-context-menu'\r\n        });\r\n    }, [open, spaceList, activeSpaceId, openSpaces]);\r\n\r\n    return (\r\n        <>\r\n            <style>\r\n                {`\r\n                    .space-context-menu {\r\n                        z-index: 9999 !important;\r\n                    }\r\n                `}\r\n            </style>\r\n            <div \r\n                onContextMenu={handleContextMenu}\r\n                onClick={handleContextMenu}\r\n                onMouseEnter={() => setIsHovered(true)}\r\n                onMouseLeave={() => setIsHovered(false)}\r\n                style={{ \r\n                    cursor: 'pointer',\r\n                    padding: '8px',\r\n                    color: 'white',\r\n                    display: 'flex',\r\n                    alignItems: 'center',\r\n                    gap: '8px',\r\n                    userSelect: 'none',\r\n                    backgroundColor: isHovered ? 'rgba(255, 255, 255, 0.1)' : 'transparent',\r\n                    transition: 'background-color 0.2s ease'\r\n                }}\r\n            >\r\n                <FolderOpen size={26} />\r\n            </div>\r\n        </>\r\n    );\r\n}; \r\n","import { useEffect } from 'react';\nimport { areaRegistry } from '../store/registries/areaRegistry';\nimport { AreaRole } from '../types/karmyc';\n\n/**\n * Hook to register a custom area type\n */\nexport function useRegisterAreaType<T = any>(\n    areaType: string,\n    component: React.ComponentType<any>,\n    initialState: T,\n    options?: {\n        displayName?: string;\n        icon?: React.ComponentType;\n        defaultSize?: { width: number, height: number };\n        supportedActions?: string[];\n        role?: AreaRole;\n        supportFullscreen?: boolean;\n    }\n): void {\n    useEffect(() => {\n        // Register the component in the unique registry\n        areaRegistry.registerComponent(areaType, component);\n\n        // Register initial state if supported\n        areaRegistry.registerInitialState(areaType, initialState);\n\n        // Register additional options\n        if (options) {\n            if (options.displayName) {\n                areaRegistry.registerDisplayName(areaType, options.displayName);\n            }\n\n            if (options.icon) {\n                areaRegistry.registerIcon(areaType, options.icon);\n            }\n\n            if (options.defaultSize) {\n                areaRegistry.registerDefaultSize(areaType, options.defaultSize);\n            }\n\n            if (options.supportedActions) {\n                areaRegistry.registerSupportedActions(areaType, options.supportedActions);\n            } \n            // Ajout du rôle dans le registre si fourni\n            if (options.role) {\n                // fallback temporaire : stocker dans areaRegistry (sera utilisé plus tard)\n                (areaRegistry as any)._roleMap = (areaRegistry as any)._roleMap || {};\n                (areaRegistry as any)._roleMap[areaType] = options.role;\n            }\n\n            // Enregistrement de l'option supportFullscreen\n            if (options.supportFullscreen !== undefined) {\n                (areaRegistry as any)._supportFullscreenMap = (areaRegistry as any)._supportFullscreenMap || {};\n                (areaRegistry as any)._supportFullscreenMap[areaType] = options.supportFullscreen;\n            }\n        }\n\n        // Clean up when component unmounts\n        return () => {\n            areaRegistry.unregisterAreaType(areaType);\n        };\n    }, [\n        areaType,\n        component,\n        initialState,\n        options,\n        options?.displayName,\n        options?.defaultSize,\n        options?.supportedActions,\n        options?.icon,\n        options?.role,\n        options?.supportFullscreen\n    ]);\n} \n","import { useEffect, useMemo } from 'react';\nimport { coreRegistry } from '../store/registries/coreRegistry';\nimport { IKarmycConfig, IKarmycOptions, LayoutPreset } from '../types/karmyc';\nimport { useKarmycStore } from '../store/areaStore';\nimport { AREA_ROLE } from '../types/actions';\n\ninterface IKarmycConfigWithLayouts {\n    plugins: IKarmycOptions['plugins'];\n    validators: IKarmycOptions['validators'];\n    initialAreas: IKarmycOptions['initialAreas'];\n    keyboardShortcutsEnabled: boolean;\n    builtInLayouts: LayoutPreset[];\n    initialLayout: string;\n    options: {\n        resizableAreas: boolean;\n        manageableAreas: boolean;\n        multiScreen: boolean;\n        builtInLayouts: LayoutPreset[];\n    };\n}\n\n/**\n * Combined hook that provides both configuration and initialization for the Karmyc system.\n */\nexport function useKarmyc(options: IKarmycOptions = {}): IKarmycConfigWithLayouts {\n    const config = useMemo(() => {\n        // Filtrer les zones invalides\n        const validAreas = (options.initialAreas ?? []).filter(area => {\n            // Vérifier si le rôle est valide\n            if (area.role && !Object.values(AREA_ROLE).includes(area.role)) {\n                console.warn(`Zone invalide ignorée: rôle \"${area.role}\" non reconnu`);\n                return false;\n            }\n            // Vérifier si le type est défini\n            if (!area.type) {\n                console.warn('Zone invalide ignorée: type non défini');\n                return false;\n            }\n            return true;\n        });\n\n        const config = {\n            // Default values\n            plugins: options.plugins ?? [],\n            validators: options.validators ?? [],\n            initialAreas: validAreas,\n            keyboardShortcutsEnabled: options.keyboardShortcutsEnabled ?? true,\n            builtInLayouts: options.builtInLayouts ?? [],\n            initialLayout: options.initialLayout ?? 'default',\n            options: {\n                resizableAreas: options.resizableAreas ?? true,\n                manageableAreas: options.manageableAreas ?? true,\n                multiScreen: options.multiScreen ?? true,\n                builtInLayouts: options.builtInLayouts ?? []\n            }\n        };\n\n        return config;\n    }, [\n        options.plugins,\n        options.validators,\n        options.initialAreas,\n        options.keyboardShortcutsEnabled,\n        options.builtInLayouts,\n        options.initialLayout,\n        options.resizableAreas,\n        options.manageableAreas,\n        options.multiScreen\n    ]);\n\n    // Initialize the system and add initial areas\n    useEffect(() => {\n        let isMounted = true;\n\n        const initializeSystem = async () => {\n            try {\n                // Convert config to IKarmycConfig expected by coreRegistry\n                const coreConfig: IKarmycConfig = {\n                    areas: {\n                        types: [],\n                        layout: {}\n                    },\n                    actions: {\n                        plugins: config.plugins,\n                        validators: config.validators\n                    },\n                    contextMenu: {\n                        actions: []\n                    }\n                };\n\n                // Initialize the system with the provided configuration\n                coreRegistry.initialize(coreConfig);\n\n                if (!isMounted) return;\n\n                // Update store options with validation\n                const validOptions = {\n                    ...config.options,\n                    keyboardShortcutsEnabled: config.keyboardShortcutsEnabled,\n                    builtInLayouts: config.builtInLayouts,\n                    initialLayout: config.initialLayout\n                };\n\n                useKarmycStore.setState(state => ({\n                    ...state,\n                    options: validOptions\n                }));\n            } catch (error) {\n                console.error('[KarmycInitializer] Error during initialization:', error);\n                if (isMounted) {\n                    // Réinitialiser le store en cas d'erreur\n                    useKarmycStore.setState(state => ({\n                        ...state,\n                        options: createDefaultConfig().options\n                    }));\n                }\n            }\n        };\n\n        initializeSystem();\n\n        // Clean up when component unmounts\n        return () => {\n            isMounted = false;\n        };\n    }, [config]);\n\n    // Return the configuration to be used with KarmycProvider\n    return config;\n}\n\nfunction createDefaultConfig(): IKarmycConfigWithLayouts {\n    return {\n        plugins: [],\n        validators: [],\n        initialAreas: [],\n        keyboardShortcutsEnabled: true,\n        builtInLayouts: [],\n        initialLayout: 'default',\n        options: {\n            resizableAreas: true,\n            manageableAreas: true,\n            multiScreen: true,\n            builtInLayouts: []\n        }\n    };\n} \n","import { useEffect, useState } from 'react';\nimport { type StateCreator, type StoreApi } from 'zustand';\nimport { actionRegistry } from '../actions/handlers/actionRegistry';\nimport { Action, IActionPlugin } from '../types/actions';\n\n// Type de fonction pour les plugins Zustand\nexport type ZustandPlugin<T> = {\n    name: string;\n    onStoreChange?: (state: T, prevState: T) => void;\n    onStoreInit?: (store: StoreApi<T>) => void;\n    transformState?: (state: T) => Partial<T>;\n    actions?: Record<string, (...args: any[]) => void>;\n};\n\n/**\n * Hook to integrate the plugin system with Zustand\n * @param store The Zustand store to extend with plugins\n * @param initialPlugins The plugins to initialize\n */\nexport function usePluginSystem<T>(\n    store: StoreApi<T>,\n    initialPlugins: ZustandPlugin<T>[] = []\n) {\n    const [plugins, setPlugins] = useState<ZustandPlugin<T>[]>(initialPlugins);\n    const [registeredActionPlugins, setRegisteredActionPlugins] = useState<IActionPlugin[]>([]);\n\n    // Register plugins on mount and unregister them on unmount\n    useEffect(() => {\n        // Initializer Zustand plugins\n        const unsubscribers: (() => void)[] = [];\n\n        plugins.forEach(plugin => {\n            // Initialize plugin with store\n            if (plugin.onStoreInit) {\n                plugin.onStoreInit(store);\n            }\n\n            // Subscribe to store changes for this plugin\n            if (plugin.onStoreChange) {\n                let previousState = store.getState();\n                const unsubscribe = store.subscribe((state) => {\n                    if (state !== previousState) {\n                        plugin.onStoreChange?.(state, previousState);\n                        previousState = state;\n                    }\n                });\n                unsubscribers.push(unsubscribe);\n            }\n        });\n\n        // Clean up subscriptions on unmount\n        return () => {\n            unsubscribers.forEach(unsubscribe => unsubscribe());\n        };\n    }, [store, plugins]);\n\n    // Handle action plugin registration/unregistration\n    useEffect(() => {\n        // Convert Zustand plugins to action plugins\n        const actionPlugins = plugins\n            .filter(plugin => plugin.actions && Object.keys(plugin.actions).length > 0)\n            .map(plugin => {\n                const actionPlugin: IActionPlugin = {\n                    id: plugin.name,\n                    priority: 500, // Default medium priority\n                    actionTypes: null, // Handle all action types\n                    handler: (action: Action) => {\n                        // Check if this plugin has an action for this type\n                        if (plugin.actions && action.type in plugin.actions) {\n                            plugin.actions[action.type](action.payload);\n                        }\n                    }\n                };\n                return actionPlugin;\n            });\n\n        // Register new action plugins\n        actionPlugins.forEach(plugin => {\n            actionRegistry.registerPlugin(plugin);\n        });\n        setRegisteredActionPlugins(actionPlugins);\n\n        // Clean up on unmount\n        return () => {\n            registeredActionPlugins.forEach(plugin => {\n                actionRegistry.unregisterPlugin(plugin.id);\n            });\n        };\n    }, [plugins]);\n\n    // Functions to manage plugins\n    const registerPlugin = (plugin: ZustandPlugin<T>) => {\n        // Vérifier si un plugin avec le même nom existe déjà\n        const existingPlugin = plugins.find(p => p.name === plugin.name);\n        if (existingPlugin) {\n            throw new Error(`Plugin with name \"${plugin.name}\" already exists`);\n        }\n        setPlugins(prev => [...prev, plugin]);\n    };\n\n    const unregisterPlugin = (pluginName: string) => {\n        setPlugins(prev => prev.filter(p => p.name !== pluginName));\n    };\n\n    // Function to transform state using all plugins\n    const applyPluginTransformations = (state: T): T => {\n        let transformedState = { ...state };\n\n        for (const plugin of plugins) {\n            if (plugin.transformState) {\n                const changes = plugin.transformState(transformedState);\n                transformedState = { ...transformedState, ...changes };\n            }\n        }\n\n        return transformedState;\n    };\n\n    return {\n        plugins,\n        registerPlugin,\n        unregisterPlugin,\n        applyPluginTransformations\n    };\n}\n\n// Type for set in Zustand\ntype SetState<T> = (\n    partial: T | Partial<T> | ((state: T) => T | Partial<T>),\n    replace?: boolean | undefined,\n    ...args: any[]\n) => void;\n\n/**\n * Creates a Zustand middleware to integrate the plugin system\n */\nexport const createPluginMiddleware = <T>(plugins: ZustandPlugin<T>[]) => {\n    return (config: StateCreator<T>) => (set: SetState<T>, get: () => T, api: StoreApi<T>) => {\n        // Initialize plugins with store\n        plugins.forEach(plugin => {\n            if (plugin.onStoreInit) {\n                plugin.onStoreInit(api);\n            }\n        });\n\n        // Apply plugin transformations on state changes\n        // Appliquer les transformations des plugins sur les changements d'état\n        const pluginsSet: SetState<T> = (updater: T | Partial<T> | ((state: T) => T | Partial<T>), replace?: boolean, ...args: any[]) => {\n            const applyUpdate = (state: T) => {\n                let newState = typeof updater === 'function'\n                    ? (updater as Function)(state)\n                    : updater;\n\n                // Appliquer les transformations des plugins\n                for (const plugin of plugins) {\n                    if (plugin.transformState) {\n                        const changes = plugin.transformState(newState as T);\n                        newState = { ...newState, ...changes };\n                    }\n                }\n\n                return newState;\n            };\n\n            const prevState = get();\n\n            // Mettre à jour l'état\n            set(applyUpdate as any, replace, ...args);\n\n            // Notifier les plugins du changement\n            const currentState = get();\n            plugins.forEach(plugin => {\n                if (plugin.onStoreChange) {\n                    plugin.onStoreChange(currentState, prevState);\n                }\n            });\n        };\n\n        return config(pluginsSet, get, api);\n    };\n};\n\nexport default usePluginSystem; \n","import { useCallback } from 'react';\r\nimport { useSpaceStore } from '../store/spaceStore';\r\n\r\nexport interface UseSpaceHistoryOptions {\r\n    enabled?: boolean;\r\n    maxHistorySize?: number;\r\n}\r\n\r\nexport function useSpaceHistory(spaceId: string | null, options: UseSpaceHistoryOptions = {}) {\r\n    const { enabled = true } = options;\r\n\r\n    const undoSharedState = useSpaceStore(state => state.undoSharedState);\r\n    const redoSharedState = useSpaceStore(state => state.redoSharedState);\r\n\r\n    const space = useSpaceStore(state => spaceId ? state.spaces[spaceId] : null);\r\n    const canUndo = Boolean(space?.sharedState?.pastDiffs?.length);\r\n    const canRedo = Boolean(space?.sharedState?.futureDiffs?.length);\r\n\r\n    const undo = useCallback(() => {\r\n        if (!enabled || !spaceId || !canUndo) return;\r\n        undoSharedState(spaceId);\r\n    }, [enabled, spaceId, canUndo, undoSharedState]);\r\n\r\n    const redo = useCallback(() => {\r\n        if (!enabled || !spaceId || !canRedo) return;\r\n        redoSharedState(spaceId);\r\n    }, [enabled, spaceId, canRedo, redoSharedState]);\r\n\r\n    const clearHistory = useCallback(() => {\r\n        if (!enabled || !spaceId) return;\r\n        useSpaceStore.setState(state => {\r\n            const space = state.spaces[spaceId];\r\n            if (space) {\r\n                space.sharedState.pastDiffs = [];\r\n                space.sharedState.futureDiffs = [];\r\n            }\r\n        });\r\n    }, [enabled, spaceId]);\r\n\r\n    return {\r\n        canUndo,\r\n        canRedo,\r\n        undo,\r\n        redo,\r\n        clearHistory,\r\n        pastDiffs: space?.sharedState?.pastDiffs ?? [],\r\n        futureDiffs: space?.sharedState?.futureDiffs ?? []\r\n    };\r\n} \r\n","import { useEffect } from \"react\";\nimport { KeyboardShortcut, keyboardShortcutRegistry } from \"../store/registries/keyboardShortcutRegistry\";\n\n\n/**\n * Hook to register keyboard shortcuts for an area type\n */\nexport function useAreaKeyboardShortcuts(\n    areaType: string,\n    shortcuts: KeyboardShortcut[]\n): void {\n    useEffect(() => {\n        // Ajouter le areaType à chaque raccourci\n        const shortcutsWithAreaType = shortcuts.map(shortcut => ({\n            ...shortcut,\n            areaType: shortcut.isGlobal ? undefined : areaType\n        }));\n\n        // Enregistrer les raccourcis\n        keyboardShortcutRegistry.registerShortcuts(areaType, shortcutsWithAreaType);\n\n        // Nettoyer lors du démontage\n        return () => {\n            keyboardShortcutRegistry.unregisterShortcuts(areaType);\n        };\n    }, [areaType, shortcuts]);\n} \n"],"names":["createStoreImpl","createState","state","listeners","Set","setState","partial","replace","nextState","Object","is","previousState","assign","forEach","listener","getState","api","getInitialState","initialState","subscribe","add","delete","destroy","env","MODE","console","warn","clear","process","NODE_ENV","shimModule","exports","React","require$$0","objectIs","x","y","useState","useEffect","useLayoutEffect","useDebugValue","checkIfSnapshotChanged","inst","latestGetSnapshot","getSnapshot","value","nextValue","error","shim","window","document","createElement","_useState","forceUpdate","useSyncExternalStoreShim_production","useSyncExternalStore","__REACT_DEVTOOLS_GLOBAL_HOOK__","registerInternalModuleStart","Error","didWarnOld18Alpha","didWarnUncachedGetSnapshot","startTransition","cachedValue","useSyncExternalStoreShim_development","registerInternalModuleStop","withSelectorModule","require$$1","useRef","useMemo","withSelector_production","useSyncExternalStoreWithSelector","getServerSnapshot","selector","isEqual","instRef","current","hasValue","memoizedSelector","nextSnapshot","hasMemo","memoizedSnapshot","currentSelection","memoizedSelection","nextSelection","maybeGetServerSnapshot","withSelector_development","ReactExports","useSyncExternalStoreExports","didWarnAboutEqualityFn","identity","arg","createImpl","createStore","useBoundStore","equalityFn","slice","getServerState","useStore","create","NOTHING","Symbol","for","DRAFTABLE","DRAFT_STATE","errors","plugin","thing","data","die","args","e","msg","apply","getPrototypeOf","isDraft","isDraftable","isPlainObject","Array","isArray","constructor","isMap","isSet","objectCtorString","prototype","toString","proto","Ctor","hasOwnProperty","call","Function","each","obj","iter","getArchtype","Reflect","ownKeys","key","entry","index","type_","has","prop","set","propOrOldValue","t","target","Map","latest","copy_","base_","shallowCopy","base","strict","isPlain","descriptors","getOwnPropertyDescriptors","keys","i","length","desc","writable","configurable","get","enumerable","freeze","deep","isFrozen","dontMutateFrozenCollections","entries","currentScope","plugins","getPlugin","pluginKey","getCurrentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer2","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","path","childValue","finalizeProperty","scope_","finalized_","resultEach","isSet2","generatePatches_","parentState","targetObject","rootPath","targetIsSet","res","assigned_","concat","autoFreeze_","propertyIsEnumerable","objectTraps","source","getDescriptorFromProto","draft_","readPropFromProto","peek","prepareCopy","createProxy","current2","currentState","markChanged","Number","isNaN","deleteProperty","getOwnPropertyDescriptor","owner","defineProperty","setPrototypeOf","arrayTraps","useStrictShallowCopy_","fn","arguments","this","parseInt","parent","proxyMap_","proxySet_","isManual_","traps","revoke","proxy","Proxy","revocable","createProxyProxy","push","currentImpl","copy","immer","config","produce","recipe","defaultBase","self","base2","hasError","p","ip","produceWithPatches","patches","inversePatches","autoFreeze","setAutoFreeze","useStrictShallowCopy","setUseStrictShallowCopy","createDraft","finishDraft","applyPatches","patch","op","applyPatchesImpl","applyPatches_","bind","initializer","store","updater","a","AREA_BORDER_WIDTH","TOOLBAR_HEIGHT","AREA_MIN_CONTENT_WIDTH","AREA_PLACEMENT_TRESHOLD","AREA_TAB_HEIGHT","stableViewport","lastAppliedWidth","lastAppliedHeight","resizeStartTime","getAreaRootViewport","currentViewport","top","left","height","Math","floor","querySelector","getBoundingClientRect","width","now","Date","__AREA_RESIZING__","widthChange","abs","heightChange","significantChange","setAreaResizing","isResizing","viewportMap","_setAreaViewport","_viewportMap","getAreaViewport","areaId","_","viewport","interpolate","b","capToRange","low","high","min","max","resolveVec2","Vec2","vecOrX","fromEvent","clientX","clientY","dot","v1","v2","vec1","vec2","_x","_y","atOrigin","vec","v","addX","addY","sub","subX","subY","subXY","scale","anchor","new","scaleX","scaleY","scaleXY","rotate","rad","cos","sin","newY","multiplyMat2","mat2","multiplyVec2","lerp","round","hypot","eq","toJSON","__objectType","ORIGIN","AreaIdContext","createContext","computeAreaRowToMinSize","rootId","areaLayout","rowToMinSize","type","compute","id","layout","items","areas","map","item","orientation","reduce","acc","computeAreaToParentRow","areaToParentRow","layoutItem","rowLayout","j","viewportCalculationHistory","lastCalculation","totalCalculations","failedIds","reportedProblems","reset","setInterval","lastValidViewportSize","computeAreaToViewport","mutableLayout","JSON","parse","stringify","areaToViewport","visitedIds","computeArea","area","contentArea","rootLayoutItem","computeRow","row","rowId","missingAreaIds","filter","MIN_AREA_SIZE","zeroSizeCount","size","totalArea","equalSize","normalizationFactor","finalTotal","currentLeft","currentTop","totalAllocatedWidth","totalAllocatedHeight","areaInfo","isLastArea","areaWidth","areaHeight","nextAreaViewport","idsWithoutViewport","getHoveredAreaId","position","areaState","draggedElementDimensions","centerPosition","hoveredStackId","hoveredAreaId","closestAreaId","minDistance","Infinity","distanceToLeft","distanceToRight","distanceToTop","distanceToBottom","distance","getAreaToOpenPlacementInViewport","relativeX","relativeY","centerX","centerY","distanceToCenterX","distanceToCenterY","centerThresholdX","centerThresholdY","placement","joinAreas","mergeArea","mergeInto","sourceIndex","targetIndex","sourceArea","targetArea","newSize","removedAreaId","resultAreas","splice","hexRegex","hexToRGB","hex","r","g","exec","c","hexToBinary","substr","rgbToBinary","rgb","n","hexToRGBA","hexToRGBAString","alpha","join","rgbToString","rgbaToString","rgba","rgbToHSL","rgbColor","cmin","cmax","delta","h","l","s","toFixed","hslToRGB","m","hexColorRegex","shortHexColorRegex","cssColorNameToHex","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","goldenrod","gold","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavenderblush","lavender","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","getRgbaFromCssColor","color","test","out","split","toLowerCase","ActionPriority","AREA_ROLE","LEAD","FOLLOW","SELF","areaStorage","areaRegistry","registerComponent","areaType","component","existing","registerInitialState","registerDisplayName","name","displayName","registerIcon","icon","registerDefaultSize","defaultSize","registerSupportedActions","actions","supportedActions","getComponent","getDisplayName","getIcon","getDefaultSize","getSupportedActions","getRegisteredTypes","from","unregisterAreaType","validateArea","isValid","validatePosition","validateContextMenuItem","label","actionId","trackedConnections","getTrackedConnectionState","fromEntries","stores","api2","devtools","devtoolsOptions","enabled","anonymousActionType","options","extensionConnector","__REDUX_DEVTOOLS_EXTENSION__","_e","connection","connectionInformation","connect","existingConnection","newConnection","extractConnectionInformation","isRecording","nameOrAction","action","send","setStateFromDevtools","originalIsRecording","init","store2","dispatchFromDevtools","dispatch","didWarnAboutReservedActionType","originalDispatch","message","_a","payload","parseJsonThen","stateFromDevtools","nextLiftedState","lastComputedState","computedStates","stringified","f","parsed","createJSONStorage","getStorage","storage","getItem","str2","str","Promise","then","setItem","newValue","removeItem","toThenable","input","onFulfilled","_onRejected","_onFulfilled","catch","onRejected","persist","baseOptions","localStorage","serialize","deserialize","partialize","version","merge","persistedState","hasHydrated","hydrationListeners","finishHydrationListeners","thenableSerialize","errorInSync","thenable","serializedValue","savedSetState","configResult","stateFromStorage","hydrate","cb","postRehydrationCallback","onRehydrateStorage","storageValue","deserializedStorageValue","migrate","migratedState","_a2","setOptions","newOptions","clearStorage","getOptions","rehydrate","onHydrate","onFinishHydration","oldImpl","_b","migrationResult","migrated","skipHydration","newImpl","byteToHex","getRandomValues","rnds8","Uint8Array","native","randomUUID","crypto","v4","buf","offset","rnds","random","rng","arr","unsafeStringify","applyDiff","diff","newState","changes","change","oldValue","immerConfig","spaces","activeSpaceId","openSpaceIds","pilotMode","addSpace","spaceData","newId","uuidv4","newSpace","description","sharedState","pastDiffs","futureDiffs","removeSpace","spaceId","setActiveSpace","setPilotMode","mode","openSpace","includes","closeSpace","updateSpace","space","updateSpaceGenericSharedState","prevState","actionType","actionPayload","currentSpace","actualChanges","diffs","compareValues","prev","next","prevObj","nextObj","prevKeys","nextKeys","undefined","generateDiff","timestamp","clearErrors","undoSharedState","diffToUndo","pop","stateAfterUndo","redoSharedState","diffToRedo","invertedDiffToRedo","stateAfterRedo","getSpaceById","getAllSpaces","getActiveSpace","getActiveSpaceId","getOpenSpaces","getSpaceErrors","getPilotMode","persistConfig","spacesToPersist","restOfSpace","restOfSharedState","loadedState","validatedSpaces","spacesFromStorage","baseSpaces","allSpaceIds","spaceFromStorage","spaceFromCode","baseShared","loadedShared","useSpaceStore","toolsEventBus","publish","event","initialAreaSliceState","_id","updateLayout","activeAreaId","joinPreview","viewports","areaToOpen","lastSplitResultData","lastLeadAreaId","addArea","removeArea","setActiveArea","updateArea","setAreaToOpen","updateAreaToOpenPosition","finalizeAreaPlacement","cleanupTemporaryStates","setViewports","setRowSizes","splitArea","setJoinPreview","joinOrMoveArea","getLastSplitResult","getActiveArea","getAreaById","getAllAreas","getAreaErrors","getLastLeadAreaId","createInitialScreenState","findParentRowAndIndices","sourceAreaId","targetAreaId","layoutId","findIndex","parentRow","simplifyLayoutNodeIfNeeded","layoutNode","survivingChildRef","survivingChildId","grandParentRowId","grandParentRow","rowIndexInGrandparent","sizeToPreserve","findFirstAreaId","createAreaSlice","generatedAreaId","log","activeScreenAreas","screens","activeScreenId","role","_roleMap","areaWithId","existingSpaces","newSpaceId","validation","lastUpdated","areaIndex","activeTabId","parentRowId","find","parentId","some","idx","areaData","newRole","layoutData","before","sourceId","newAreaId","adjustedPosition","rootViewport","determinedTargetAreaId","targetId","determinedPlacement","detectionDimensions","sourceParentRowIdForCleanup","survivingChildIdFromSourceSimplification","sourceParentRowId","sourceParentRow","totalSize","factor","found","sourceData","allowStackMixedRoles","sourceRole","targetRole","newStackId","newStack","originalSize","newRowId","insertIndex","affectedAreas","totalAffectedSize","sum","newNestedRow","newRootRow","recalculatedViewports","typedRowLayout","sizes","areaIdToSplit","horizontal","areaToSplit","originalAreas","duplicatedAreas","child","originalArea","newRow","separatorIndex","baseId","areasToAdd","currentId","simplifyRecursively","mergeRowsOfSameOrientation","changed","childId","childRow","parentSize","totalChildSize","newAreas","na","referenced","mark","node","cleanOrphanRows","originalParentRowId","grandParentId","parentRowCopy","mergeIntoDirection","areaIndexToRemove","joinResult","joinAreasUtil","resultingLayoutItem","allRemovedIds","itemId","descendantIds","queue","visited","shift","areaRef","findAllDescendantAreaIds","updatedRow","String","windowId","useKarmycStore","areaSlice","nextScreenId","layout_preset","addScreen","newScreenId","defaultAreaId","newScreenAreasState","content","switchScreen","screenId","removeScreen","isDetached","maxClassicId","classicIdsLeft","sort","url","URL","location","href","searchParams","history","replaceState","duplicateScreen","sourceScreen","detachArea","detachedFromAreaId","originScreen","features","open","initializeKarmycStore","optionsParam","mergedOptions","syncTimeout","SYNC_DEBOUNCE_MS","addEventListener","local","localScreens","incomingLastUpdated","localLastUpdated","hasChanges","localScreen","currentScreen","clearTimeout","setTimeout","isVisible","metadata","menuClassName","customContextMenuContent","menuType","useContextMenuStore","openContextMenu","positionValidation","invalidItems","flatMap","openCustomContextMenu","closeContextMenu","updateContextMenuPosition","updateContextMenuItems","ActionRegistry","validators","actionHandlers","menuActionsByType","defaultValidators","registerPlugin","onRegister","unregisterPlugin","onUnregister","registerValidator","validator","unregisterValidators","registerActionHandler","handler","menuActions","unregisterActionHandler","validateAction","valid","handleAction","validationResult","sortedPlugins","values","priority","actionTypes","executeAction","params","getMenuActions","actionIds","order","actionRegistry","coreRegistry","initialize","useAreaDragAndDrop","setAreaToOpenAction","updateAreaToOpenPositionAction","finalizeAreaPlacementAction","dragRef","lastUpdateRef","performance","rafRef","isUpdatingRef","areaToOpenTargetId","currentPositionVec2","areaToOpenTargetViewport","calculatedPlacement","updatePosition","useCallback","requestAnimationFrame","globalDragOverHandler","preventDefault","handleDragStart","body","style","userSelect","rect","currentTarget","startX","startY","dragImage","opacity","pointerEvents","appendChild","dataTransfer","effectAllowed","setData","setDragImage","contains","removeChild","handleDragOver","types","dropEffect","handleDrop","dataString","getData","stopPropagation","elementsUnderCursor","elementsFromPoint","element","classList","areaElement","closest","potentialTargetId","dataset","areaid","stackLayout","sourceRow","updatedSourceAreas","normalizedAreas","updatedLayout","isLocked","handleDragEnd","cancelAnimationFrame","removeEventListener","toPascalCase","string","camelCase","match","p1","p2","toUpperCase","toCamelCase","charAt","mergeClasses","classes","className","array","Boolean","trim","indexOf","hasA11yProp","props","startsWith","defaultAttributes","xmlns","viewBox","fill","stroke","strokeWidth","strokeLinecap","strokeLinejoin","Icon","forwardRef","absoluteStrokeWidth","children","iconNode","rest","ref","tag","attrs","createLucideIcon","iconName","Component","AppWindow","rx","d","ArrowBigDown","Copy","ry","EllipsisVertical","cx","cy","Ellipsis","ExternalLink","FileDown","FileUp","FolderOpen","History","LockOpen","Lock","Maximize2","Minimize2","Plus","SquarePen","Trash","X","useRegisterActionHandler","useTranslationStore","setTranslationFunction","useTranslation","fallback","SwitchAreaTypeContextMenu","roleMap","registeredTypes","columns","title","col","newType","_jsx","ControlledMenu","anchorPoint","onClose","transition","direction","_jsxs","flex","margin","padding","marginBottom","textAlign","borderBottom","paddingBottom","display","alignItems","gap","cursor","onClick","handleChangeType","onMouseDown","_Fragment","marginTop","backgroundColor","borderRadius","handleSetSpace","AreaDragButton","isDragging","setIsDragging","manageableAreas","isFullscreen","enableFullscreen","supportsFullscreen","_supportFullscreenMap","selectAreaButtonRef","spaceColor","allAreas","leadArea","leadSpaceId","leadSpace","draggable","onDragStart","onDragOver","onDrop","onDragEnd","onContextMenu","openSelectArea","CopyIcon","XIcon","areaContainer","exitFullscreen","webkitExitFullscreen","msExitFullscreen","previousLayout","previousRootId","currentLayout","currentRootId","requestFullscreen","webkitRequestFullscreen","msRequestFullscreen","handleFullscreenChange","fullscreenElement","webkitFullscreenElement","msFullscreenElement","Minimize2Icon","Maximize2Icon","LockIcon","LockOpenIcon","AreaTabs","memo","dragIndicator","setDragIndicator","draggingTabId","setDraggingTabId","handleTabDragEnd","onDragLeave","relatedTarget","isActive","indicatorClass","handleTabClick","sourceRowId","handleTabDragStart","overAreaId","midPoint","handleTabDragOver","onDropAreaId","indicatedTargetId","indicatedPosition","workingAreas","onDropAreaOriginalIndex","movedArea","targetIndexInModifiedArray","finalInsertionIndex","handleTabDrop","handleAreaDragFromCorner","corner","setResizePreview","initialMousePosition","lastMousePosition","currentOnMove","currentOnMouseUp","getActiveScreenState","rootState","initialActiveScreenState","initialLayout","initialRootId","createNewArea","setupJoinMoveHandlers","sourceAreaData","splitResult","currentActiveScreenStateAfterSplit","newRowLayout","every","equalSizes","rowToResize","sepIndex","setResizePreviewFn","isHorizontalRow","areaBeforeId","areaAfterId","initialSizes","sizeToShare","timeoutId","debounceDelay","lastT","performGlobalUpdate","minSize","adjustedSizes","total","normalizedSizes","triggerDebouncedUpdate","cancelDebouncedUpdate","currentActiveState","currentRow","areaToViewportMap","v0","sharedViewport","viewportSize","minT","t0","t1","val","tempSize0","tempSize1","tempSizes","tempTotalSize","finalSize0","finalSize1","finalRowState","finalSizes","finalTotalSize","finalNormalizedSizes","count","setupResizeHandlers","initialParentRow","sourceAreaIndex","actualEligibleAreaIds","immediateSiblings","eligibleId","vp","sourceVp","targetVp","deltaX","deltaY","movingInDirection","eligibleAreaIds","preview","initialDirectionDetermined","determineInitialDirection","currentPos","handleMouseMove","handleMouseUp","isMovingInwards","moveVec","absX","absY","isMainlyVertical","determineIfMovingInwards","moveEvent","ErrorDisplay","border","AreaErrorBoundary","super","getDerivedStateFromError","componentDidCatch","errorInfo","render","useContextMenu","openAction","closeAction","close","ScreenSwitcher","filteredScreenIds","PlusIcon","ExternalLinkIcon","TrashIcon","disabled","handleContextMenu","background","minWidth","toolsBarRegistry","cleanupToolsRegistry","registryKey","useToolsSlot","identifier","alignment","allowedLayerTypes","callback","getComponents","useToolsRegistrySubscription","useReducer","Tools","combineAndDedupe","componentArrays","componentMap","flat","comp","getMenuComponentsById","getMenuComponentsByType","menuComponents","getStatusComponentsById","getStatusComponentsByType","statusComponents","getToolbarTopInnerById","getToolbarTopInnerByType","toolbarTopInnerComponents","getToolbarBottomInnerById","getToolbarBottomInnerByType","toolbarBottomInnerComponents","handleFocus","multiScreen","currentArea","currentSpaceId","useToolsState","useToolsScreenState","hasTopOuter","hasBottomOuter","hasTopInner","hasBottomInner","topOuterHeight","bottomOuterHeight","renderToolbar","components","leftComponents","centerComponents","rightComponents","minHeight","right","bottom","onFocusCapture","tabIndex","overflow","flexDirection","AreaComponent","raised","isChildOfStack","active","viewportRef","resizableAreas","Provider","spaceToUse","dir","nativeEvent","zIndex","innerWidth","innerHeight","AreaStack","activeArea","isComponentReady","setIsComponentReady","checkComponent","AreaPreview","dimensions","Area","allAreasData","isLayoutRow","isStack","isHorizontalOrVerticalRow","activeAreaIdForRender","dataForRender","componentForRender","getParentMenuComponents","getParentStatusComponents","parentMenuComponents","parentStatusComponents","hasParentTopOuter","hasParentBottomOuter","parentTopOuterHeight","parentBottomOuterHeight","adjustedViewport","containerStyle","contentViewport","handleDragAreaResize","areasLength","initialRootState","initialActiveScreenId","initialActiveScreenAreas","activeLayout","activeRootId","initialAreaToViewport","a0","a1","getMinSize","m0","m1","tMin0","tMin1","lastUpdateTime","animationFrameId","animate","tempFinalSizes","latestFinalPercentages","initialRowState","normalizedPercentages","updateFromMousePosition","onDrag","simpleDragHandler","AreaRowSeparators","separators","nextArea","nextViewport","separatorRect","handleMouseDown","DropZone","setAreaToOpenDimensions","newDimensions","placementLinesMemo","lines","placementLines","treshold","O","w","nw_0","ne_0","se_0","sw_0","nw_1","ne_1","se_1","sw_1","stack","pathData","p0","x1","y1","x2","y2","AreaToOpenPreview","initialDimensions","areaToOpenDimensions","JoinAreaPreview","arrowWidth","ContextMenu","renderMenuItems","SubMenu","MenuItem","itemMetadata","ContextMenuProvider","DetachedWindowCleanup","handleUnload","spaceHistoryStore","addEntry","clearHistory","historyPlugin","HIGH","historyEntry","getActionDescription","elementType","useArea","removeAreaAction","createArea","setActive","update","getActive","getById","getAll","getErrors","KarmycInitializer","onError","initialized","defaultPlugins","customPlugins","allPlugins","pluginIds","storeState","activeScreenAreasState","areasToInitialize","initialAreas","newAreaIds","areaConfig","defaultRowLayout","newLayoutMap","root","shortcutsStorage","globalShortcuts","keyboardShortcutRegistry","shortcuts","allShortcuts","shortcut","KarmycContext","KarmycProvider","isInitialLoad","isUpdatingUrl","lastActiveScreenId","lastScreenCount","lastScreenOrder","screenIdFromUrl","URLSearchParams","search","timer","currentScreenCount","currentScreenOrder","deletedScreenId","deletedScreenIndex","oldActiveIndex","newActiveScreenId","currentUrl","currentScreenParam","handleKeyDown","keyboardShortcutsEnabled","activeModifiers","ctrlKey","altKey","shiftKey","metaKey","activeAreaType","isGlobal","requiredModifiers","modifierKeys","allModifiersMatch","modKey","optionalModifiers","optionalModifierKeys","activeMod","systemShortcuts","modifiers","checkShouldPreventDefault","selectActiveScreenAreas","Karmyc","useContext","lastViewportRef","setViewport","resizePreview","areaRoot","handleResize","newViewport","layoutSize","currentRootItem","newViewportMap","currentStoreViewports","map1","map2","keys1","keys2","rect1","rect2","areViewportMapsEqual","oldViewport","getAreaVisualViewport","activeScreen","currentGlobalViewportMap","baseViewport","areaIndexInRow","siblingIndex","siblingId","siblingViewport","isFirst","vp0","vp1","sharedRect","totalPixelWidth","newPixelWidth0","newPixelWidth1","newWidth","newLeft","totalPixelHeight","newPixelHeight0","newPixelHeight1","newHeight","newTop","visualViewport","joinViewport","shallow$1","objA","objB","keysA","keyA","useStoreWithEqualityFn","useSpace","shallow","addSpaceAction","removeSpaceAction","setActiveSpaceAction","openSpaceAction","closeSpaceAction","updateSpaceAction","updateSpaceGenericSharedStateAction","spaceList","openSpaces","createSpace","initialSharedState","deleteSpace","updateSharedState","updateSpaceProperties","SpaceMenu","isHovered","setIsHovered","handleExportSpace","dataStr","dataUri","encodeURIComponent","exportFileDefaultName","linkElement","setAttribute","click","handleImportSpace","accept","onchange","file","files","reader","FileReader","onload","readAsText","handleRenameSpace","newName","prompt","recentSpaces","reverse","hasActiveSpace","menuItems","Edit","onMouseEnter","onMouseLeave","useRegisterAreaType","supportFullscreen","useKarmyc","validAreas","builtInLayouts","isMounted","async","coreConfig","contextMenu","validOptions","initializeSystem","usePluginSystem","initialPlugins","setPlugins","registeredActionPlugins","setRegisteredActionPlugins","unsubscribers","onStoreInit","onStoreChange","unsubscribe","actionPlugins","pluginName","applyPluginTransformations","transformedState","transformState","useSpaceHistory","canUndo","canRedo","undo","redo","useAreaKeyboardShortcuts","shortcutsWithAreaType"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,25,26,27,28,29,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,96,97]}